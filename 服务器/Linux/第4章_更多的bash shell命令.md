# 第4章_更多的bash shell命令

本章会深入 Linux 系统管理命令，演示如何通过命令行命令来探查 Linux 系统的内部信息，然后会讲解一些可用于处理系统数据文件的命令。

## 1.监测程序

对 Linux 系统管理员而言，最难缠的一项任务是跟踪运行在系统中的程序——尤其是现在，图形化桌面集成了大量的程序来生成一个完整的桌面环境。系统中始终运行着大量的程序。

好在有几个命令行工具可以提供帮助。本节将介绍能帮你在 Linux 系统中管理程序的一些基础工具。

### 1.1 探查进程

当程序在系统中运行时，它被称为**进程**（process）。要想监测这些进程，必须熟悉`ps`命令的用法。`ps`命令堪比工具中的瑞士军刀，能够输出系统中运行的所有程序的大量信息。

遗憾的是，伴随稳健性而来的还有复杂性：数不清的选项或许让`ps`命令成了最难掌握的命令。大多数系统管理员在找到一组能够提供所需信息的选项之后，会一直坚持只使用这些选项。

在默认情况下，`ps`命令并没有提供太多的信息：

```bash
$ ps
  PID  TTY          TIME     CMD
  3081 pts/0        00:00:00 bash
  3209 pts/0        00:00:00 ps
$
```

也没什么特别之处。`ps`命令默认只显示运行在当前终端中属于当前用户的那些进程。在这个例子中，只有 bash shell 在运行（记住，shell 只是运行在系统中的另一个程序而已），当然`ps`命令本身也在运行。

`ps`命令的基本输出显示了程序的进程 ID（process ID，PID）、进程运行在哪个终端（TTY）及其占用的 CPU 时间。

> **注意**
>
> `ps`命令令人头疼的地方（也正是它如此复杂的原因）在于它曾经有两个版本。每个版本都有自己的一套命令行选项，控制着显示哪些信息以及如何显示。最近，Linux 开发人员已经将这两种`ps`命令格式合并到单个`ps`命令中（当然，同时也加入了他们自己的风格）。

Linux 系统中使用的 GNU `ps`命令支持以下 3 种类型的命令行选项：

- Unix 风格选项，选项前加单连字符
- BSD 风格选项，选项前不加连字符
- GNU 长选项，选项前加双连字符

下面将进一步解析这 3 种选项类型，并举例演示其用法。

1. **Unix风格选项**

   Unix 风格选项源自贝尔实验室开发的 AT&T Unix 系统中的`ps`命令。这些选项如表 4-1 所示。

   **表 4-1　Unix 风格的 `ps` 命令选项**

   | 选项            | 描述                                                      |
   | :-------------- | :-------------------------------------------------------- |
   | `-A`            | 显示所有进程                                              |
   | `-N`            | 显示与指定参数不符的所有进程                              |
   | `-a`            | 显示除控制进程（session leader ）和无终端进程外的所有进程 |
   | `-d`            | 显示除控制进程外的所有进程                                |
   | `-e`            | 显示所有进程                                              |
   | `-C *cmdlist*`  | 显示包含在`*cmdlist*`列表中的进程                         |
   | `-G *grplist*`  | 显示组ID在`*grplist*`列表中的进程                         |
   | `-U *userlist*` | 显示属主的用户ID在`*userlist*`列表中的进程                |
   | `-g *grplist*`  | 显示会话或组ID在`*grplist*`列表中的进程                   |
   | `-p *pidlist*`  | 显示PID在`*pidlist*`列表中的进程                          |
   | `-s *sesslist*` | 显示会话ID在`*sesslist*`列表中的进程                      |
   | `-t *ttylist*`  | 显示终端ID在`*ttylist*` 列表中的进程                      |
   | `-u *userlist*` | 显示有效用户ID在`*userlist*`列表中的进程                  |
   | `-F`            | 显示更多的额外输出（相对`-f`选项而言）                    |
   | `-O *format*`   | 显示默认的输出列以及`*format*`列表指定的特定列            |
   | `-M`            | 显示进程的安全信息                                        |
   | `-c`            | 显示进程的额外的调度器信息                                |
   | `-f`            | 显示完整格式的输出                                        |
   | `-j`            | 显示作业信息                                              |
   | `-l`            | 显示长列表                                                |
   | `-o *format*`   | 仅显示由`*format*`指定的列                                |
   | `-y`            | 不显示进程标志                                            |
   | `-Z`            | 显示安全上下文信息                                        |
   | `-H`            | 以层级格式显示进程（显示父进程）                          |
   | `-n *namelist*` | 定义要在`WCHAN`输出列中显示的值                           |
   | `-w`            | 采用宽输出格式，不限宽度显示                              |
   | `-L`            | 显示进程中的线程                                          |
   | `-V`            | 显示`ps`命令的版本号                                      |

   上面的选项已经不少了，但没列出的还有很多！使用`ps`命令的关键不在于记住所有可用的选项，而在于记住对你来说最有用的那些。大多数 Linux 系统管理员会牢记自己的一组常用选项，以用来提取有用的进程信息。如果需要查看系统中运行的所有进程，可以使用`-ef`选项组合（`ps`命令允许像这样把选项合并在一起）。

   ```bash
   $ ps -ef
   UID          PID    PPID  C STIME TTY          TIME CMD
   root           1       0  0 12:14 ?        00:00:02 /sbin/init splash
   root           2       0  0 12:14 ?        00:00:00 [kthreadd]
   root           3       2  0 12:14 ?        00:00:00 [rcu_gp]
   root           4       2  0 12:14 ?        00:00:00 [rcu_par_gp]
   root           5       2  0 12:14 ?        00:00:00
   [kworker/0:0-events]
   root           6       2  0 12:14 ?        00:00:00
   [kworker/0:0H-kblockd]
   root           7       2  0 12:14 ?        00:00:00
   [kworker/0:1-events]
   ...
   rich        2209    1438  0 12:17 ?        00:00:01 /usr/libexec/
   gnome-terminal-
   rich        2221    2209  0 12:17 pts/0    00:00:00 bash
   rich        2325    2221  0 12:20 pts/0    00:00:00 ps -ef
   $
   ```

   为了节省篇幅，这里略去了不少输出。但正如你所看到的，Linux 系统中运行着大量的进程。这个例子用了两个选项：`-e`选项指定显示系统中运行的所有进程；`-f`选项则扩充输出内容以显示一些有用的信息列。

   - **UID**：启动该进程的用户
   - **PID**：进程 ID
   - **PPID**：父进程的 PID（如果该进程是由另一个进程启动的）
   - **C**：进程生命期中的 CPU 利用率
   - **STIME**：进程启动时的系统时间
   - **TTY**：进程是从哪个终端设备启动的
   - **TIME**：运行进程的累计 CPU 时间
   - **CMD**：启动的程序名称

   由此得到了合理的信息量，这也正是很多系统管理员乐于看到的。如果还想获得更多的信息，可以使用`-l`选项，产生长格式输出。

   ```bash
   $ ps -l
   F S  UID PID   PPID  C  PRI  NI ADDR  SZ   WCHAN  TTY     TIME       CMD
   0 S  500 3081  3080  0  80   0  -     1173 do_wai pts/0   00:00:00   bash
   0 R  500 4463  3081  1  80   0  -     1116 -      pts/0   00:00:00   ps
   $
   ```

   注意使用了`-l`选项之后多出的那几列。

   - **F**：内核分配给进程的系统标志
   - **S**：进程的状态（`O`代表正在运行；`S`代表在休眠；`R`代表可运行，正等待运行；`Z`代表僵化，已终止但找不到其父进程；`T`代表停止）
   - **PRI**：进程的优先级（数字越大，优先级越低）
   - **NI**：谦让度（nice），用于决定优先级
   - **ADDR**：进程的内存地址
   - **SZ**：进程被换出时所需交换空间的大致大小
   - **WCHAN**：进程休眠的内核函数地址

2. **BSD风格选项**

   了解了 Unix 风格选项之后，来看看 BSD 风格选项。伯克利软件发行版（Berkeley Software Distribution，BSD）是加州大学伯克利分校开发的一个 Unix 版本。BSD 与 AT&T Unix 系统有许多细微的差别，由此引发了多年来的诸多 Unix 纷争。BSD 版的`ps`命令选项如表 4-2 所示。

   **表4-2　BSD风格的`ps`命令选项**

   | 选项           | 描述                                                         |
   | :------------- | :----------------------------------------------------------- |
   | `T`            | 显示与当前终端关联的所有进程                                 |
   | `a`            | 显示与任意终端关联的所有进程                                 |
   | `g`            | 显示包括控制进程在内的所有进程                               |
   | `r`            | 仅显示运行中的进程                                           |
   | `x`            | 显示所有进程，包括未分配任何终端的进程                       |
   | `U *userlist*` | 显示属于`*userlist*`列表中某个用户ID所有的进程               |
   | `p *pidlist*`  | 显示PID在`*pidlist*`列表中的进程                             |
   | `t *ttylist*`  | 显示与`*ttylist*`列表中的某个终端关联的进程                  |
   | `O *format*`   | 除了标准列，还输出由`*format*`指定的列                       |
   | `X`            | 以寄存器格式显示数据                                         |
   | `Z`            | 在输出中包含安全信息                                         |
   | `j`            | 显示作业信息                                                 |
   | `l`            | 采用长格式显示                                               |
   | `o *format*`   | 仅显示由`*format*`指定的列                                   |
   | `s`            | 采用信号格式显示                                             |
   | `u`            | 采用基于用户的格式显示                                       |
   | `v`            | 采用虚拟内存格式显示                                         |
   | `N *namelist*` | 定义要在`WCHAN`输出列中显示的值                              |
   | `O *order*`    | 定义信息列的显示顺序                                         |
   | `S`            | 将子进程的数值统计信息（比如CPU和内存使用情况）汇总到父进程中 |
   | `c`            | 显示真实的命令名称（用以启动该进程的程序名称）               |
   | `e`            | 显示命令使用的环境变量                                       |
   | `f`            | 用层级格式来显示进程，显示哪些进程启动了哪些进程             |
   | `h`            | 不显示头信息                                                 |
   | `k *sort*`     | 指定用于排序输出的列                                         |
   | `n`            | 使用数值显示用户ID、组ID以及`WCHAN`信息                      |
   | `w`            | 为更宽的终端屏幕生成宽输出                                   |
   | `H`            | 将线程显示为进程                                             |
   | `m`            | 在进程之后显示线程                                           |
   | `L`            | 列出所有的格式说明符                                         |
   | `V`            | 显示`ps`命令的版本                                           |

   如你所见，Unix 和 BSD 风格的选项有很多重叠之处。从一种风格的选项中得到的信息基本上也能从另一种风格中获取。大部分时候，只要选择自己喜欢的风格即可（比如你在使用 Linux 之前就已经习惯了 BSD 环境）。

   在使用 BSD 风格的选项时，`ps`命令会自动改变输出以模仿 BSD 格式。下面是使用`l`选项的输出。

   ```bash
   $ ps l
   $ ps l
   F   UID     PID    PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY TIME COMMAND
   4  1000    1491    1415  20   0 163992  6580 poll_s Ssl+ tty2 0:00 /usr/li
   4  1000    1496    1491  20   0 225176 58712 ep_pol Sl+  tty2 0:05 /usr/li
   0  1000    1538    1491  20   0 192844 15768 poll_s Sl+  tty2 0:00 /usr/li
   0  1000    2221    2209  20   0  10608  4740 do_wai Ss  pts/0 0:00 bash
   0  1000    2410    2221  20   0  11396  1156 -      R+  pts/0 0:00 ps l
   $
   ```

   注意，尽管上述很多输出列跟使用 Unix 风格选项时是一样的，但还是有一些不同之处。

   - **VSZ**：进程占用的虚拟内存大小（以 KB 为单位）
   - **RSS**：进程在未被交换出时占用的物理内存大小
   - **STAT**：代表当前进程状态的多字符状态码

   很多系统管理员喜欢 BSD 风格的`l`选项，因为能输出更详细的进程状态码（`STAT`列）。多字符状态码能比 Unix 风格输出的单字符状态码更清楚地表明进程的当前状态。

   第一个字符采用了与 Unix 风格的`S`输出列相同的值，表明进程是在休眠、运行还是等待。第二个字符进一步说明了进程的状态。

   - `<`：该进程以高优先级运行
   - `N`：该进程以低优先级运行
   - `L`：该进程有锁定在内存中的页面
   - `s`：该进程是控制进程
   - `l`：该进程拥有多线程
   - `+`：该进程在前台运行

   从先前展示的简单例子中可以看出，`bash`命令处于休眠状态，但同时它也是一个控制进程（会话中的主进程），而`ps`命令则运行在系统前台。

3. **GNU长选项**

   GNU 开发人员在经过改进的新`ps`命令中加入了另外一些选项，其中一些 GNU 长选项复制了现有的 Unix 或 BSD 风格选项的效果，而另外一些则提供了新功能。表 4-3 列出了可用的 GNU 长选项。

   **表4-3　GNU风格的`ps`命令选项**

   | 选项                | 描述                                       |
   | :------------------ | :----------------------------------------- |
   | `--deselect`        | 显示除命令行中列出的进程之外的其他进程     |
   | `--Group *grplist*` | 显示组 ID 在`*grplist*`列表中的进程        |
   | `--User *userlist*` | 显示用户 ID 在`*userlist*`列表中的进程     |
   | `--group *grplist*` | 显示有效组 ID 在`*grplist*`列表中的进程    |
   | `--user *userlist*` | 显示有效用户 ID 在`*userlist*`列表中的进程 |
   | `--pid *pidlist*`   | 显示`pid`在`*pidlist*`列表中的进程         |
   | `--ppid *pidlist*`  | 显示父`pid`在`pidlist`列表中的进程         |
   | `--sid *sidlist*`   | 显示会话 ID 在`sidlist`列表中的进程        |
   | `--tty *ttylist*`   | 显示终端设备 ID 在`*ttylist*`列表中的进程  |
   | `--format *format*` | 仅显示由`format`指定的列                   |
   | `--context`         | 显示额外的安全信息                         |
   | `--cols *n*`        | 将屏幕宽度设置为`*n*`列                    |
   | `--columns *n*`     | 将屏幕宽度设置为`*n*`列                    |
   | `--cumulative`      | 包含已停止的子进程的信息                   |
   | `--forest`          | 用层级结构显示出进程和父进程之间的关系     |
   | `--headers`         | 在每页输出中都显示列名                     |
   | `--no-headers`      | 不显示列名                                 |
   | `--lines *n*`       | 将屏幕高度设置为`*n*`行                    |
   | `--rows *n*`        | 将屏幕高度设置为`*n*`行                    |
   | `--sort *order*`    | 指定用于排序输出的列                       |
   | `--width *n*`       | 将屏幕宽度设置为`*n*`列                    |
   | `--help`            | 显示帮助信息                               |
   | `--info`            | 显示调试信息                               |
   | `--version`         | 显示`ps`命令的版本号                       |

   可以混用 GNU 长选项和 Unix 或 BSD 风格的选项来定制输出。作为一个 GNU 长选项，`--forest`选项着实讨人喜欢。该选项能够使用 ASCII 字符来绘制可爱的图表以显示进程的层级信息：

   ```
    1981 ?          00:00:00 sshd
    3078 ?          00:00:00  \_ sshd
    3080 ?          00:00:00      \_ sshd
    3081 pts/0      00:00:00          \_ bash
   16676 pts/0      00:00:00              \_ ps
   ```

   这种格式可以轻而易举地跟踪子进程和父进程！

### 1.2 实时监测进程

`ps`命令虽然在收集系统中运行进程的信息时非常有用，但也存在不足之处：只能显示某个特定时间点的信息。如果想观察那些被频繁换入和换出内存的进程，`ps`命令就不太方便了。

这正是`top`命令的用武之地。与`ps`命令相似，`top`命令也可以显示进程信息，但采用的是实时方式。图 4-1 是`top`命令运行时的截图。

**图4-1　`top`命令运行时的输出**

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220528203232560-b4206483a9a003c23781d40e1c291c9d-da490f.png" alt="image-20220528203232560"  />

输出的第一部分显示的是系统概况：第一行显示了当前时间、系统的运行时长、登录的用户数以及系统的平均负载。

平均负载有 3 个值，分别是最近 1 分钟、最近 5 分钟和最近 15 分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近 1 分钟的高负载值也很常见。但如果近 15 分钟内的平均负载都很高，就说明系统可能有问题了。

> **注意**
>
> Linux 系统管理的难点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统中通常运行的程序。某个系统的高负载可能对其他系统来说就是普通水平。最好的做法是注意在正常情况下系统的负载情况，这样将更容易判断系统何时负载不足。

第二行显示了进程（`top`称其为 task）概况：多少进程处于运行、休眠、停止以及僵化状态（僵化状态指进程已结束，但其父进程没有响应）。

下一行显示了 CPU 概况。`top`会根据进程的属主（用户或是系统）和进程的状态（运行、空闲或等待）将 CPU 利用率分成几类输出。

紧跟其后的两行详细说明了系统内存的状态。前一行显示了系统的物理内存状态：总共有多少内存、当前用了多少，以及还有多少空闲。后一行显示了系统交换空间（如果分配了的话）的状态。

最后一部分显示了当前处于运行状态的进程的详细列表，有些列跟`ps`命令的输出类似。

- **PID**：进程的 PID
- **USER**：进程属主的用户名
- **PR**：进程的优先级
- **NI**：进程的谦让度
- **VIRT**：进程占用的虚拟内存总量
- **RES**：进程占用的物理内存总量
- **SHR**：进程和其他进程共享的内存总量
- **S**：进程的状态（`D`代表可中断的休眠，`R`代表运行，`S`代表休眠，`T`代表被跟踪或停止，`Z`代表僵化）
- **%CPU**：进程使用的 CPU 时间比例
- **%MEM**：进程使用的可用物理内存比例
- **TIME+**：自进程启动到目前为止所占用的 CPU 时间总量
- **COMMAND**：进程所对应的命令行名称，也就是启动的程序名

在默认情况下，`top`命令在启动时会按照 %CPU 值来对进程进行排序，你可以在`top`命令运行时使用多种交互式命令来重新排序。每个交互式命令都是单字符，在`top`命令运行时键入可改变`top`的行为。键入`f`允许你选择用于对输出进行排序的字段，键入`d`允许你修改轮询间隔（polling interval），键入`q`可以退出`top`。用户对`top`命令输出有很大的控制权。利用该工具，你经常能找出占用系统大量资源的罪魁祸首。当然，找到之后，下一步就是结束这些进程。这也正是接下来的话题。

### 1.3 结束进程

身为系统管理员，所需掌握的一项关键技能是知道何时以及如何结束一个进程。有时候，进程会被挂起，此时只需动动手让进程重新运行或结束就行了。有时候，进程会霸占着 CPU 且拒绝让出。在这两种情景下，都需要能够控制进程的命令。Linux 沿用了 Unix 的进程间通信方法。

在 Linux 中，进程之间通过**信号**来通信。进程的信号是预定义好的一个消息，进程能识别该消息并决定忽略还是做出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的应用程序能接收和处理标准 Unix 进程信号。这些信号如表 4-4 所示。

**表4-4　Linux进程信号**

| 信号 | 名称   | 描述                         |
| :--- | :----- | :--------------------------- |
| 1    | `HUP`  | 挂起                         |
| 2    | `INT`  | 中断                         |
| 3    | `QUIT` | 结束运行                     |
| 9    | `KILL` | 无条件终止                   |
| 11   | `SEGV` | 段错误                       |
| 15   | `TERM` | 尽可能终止                   |
| 17   | `STOP` | 无条件停止运行，但不终止     |
| 18   | `TSTP` | 停止或暂停，但继续在后台运行 |
| 19   | `CONT` | 在`STOP`或`TSTP`之后恢复执行 |

在 Linux 中有两个命令可以向运行中的进程发出进程信号：`kill`和`pkill`。

1. **`kill`命令**

   `kill`命令可以通过 PID 向进程发送信号。在默认情况下，`kill`命令会向命令行中列出的所有 PID 发送`TERM`信号。遗憾的是，你只能使用进程的 PID 而不能使用其对应的程序名，这使得`kill`命令有时并不好用。

   要发送进程信号，必须是进程的属主或 root 用户：

   ```bash
   $ kill 3940
   -bash: kill: (3940) - Operation not permitted
   $
   ```

   `TERM`信号会告诉进程终止运行。但不服管教的进程通常会忽略这个请求。如果要强制终止，则`-s`选项支持指定其他信号（用信号名或信号值）。

   从下例可以看到，`kill`命令不会有任何输出：

   ```bash
   $ kill -s HUP 3940
   $
   ```

   要检查`kill`命令是否生效，可以再次执行`ps`或`top`命令看看那些进程是否已经停止运行。

2. **`pkill`命令**

   `pkill`命令可以使用程序名代替 PID 来终止进程，这就方便多了。除此之外，`pkill`命令也允许使用通配符，当系统出问题时，这是一个非常有用的工具：

   ```bash
   $ pkill http*
   $
   ```

   该命令将杀死所有名称以 http 起始的进程，比如 Apahce Web Server 的 httpd 服务。

   > **警告**
   >
   > 以 root 身份使用`pkill`命令时要格外小心。命令中的通配符很容易意外地将系统的重要进程终止。这可能会导致文件系统损坏。

## 2.监测磁盘空间

系统管理员的另一项重要任务是监测系统磁盘的使用情况。不管运行的是简单的 Linux 桌面还是大型的 Linux 服务器，你都需要知道还有多少磁盘空间可供应用程序使用。

有几个命令行命令可以帮助你管理 Linux 系统中的存储设备。本节将介绍在日常系统管理中会用到的核心命令。

### 2.1 挂载存储设备

如第 3 章所述，Linux 文件系统会将所有的磁盘都并入单个虚拟目录。在使用新的存储设备之前，需要将其放在虚拟目录中。这项工作称为**挂载**（mounting）。

在今天的图形化桌面环境中，大多数 Linux 发行版能自动挂载特定类型的**可移动存储设备**。所谓可移动存储设备（显然）指的是那种可以从 PC 中轻易移除的媒介，比如 DVD 和 U 盘。

如果你使用的发行版不支持自动挂载和卸载可移动存储设备，则只能手动操作了。本节将介绍一些可以帮你管理可移动存储设备的 Linux 命令行命令。

1. **`mount`命令**

   用于挂载存储设备的命令叫作`mount`。在默认情况下，`mount`命令会输出当前系统已挂载的设备列表。但是，除了标准存储设备，较新版本的内核还会挂载大量用作管理目的的虚拟文件系统。这使得`mount`命令的默认输出非常杂乱，让人摸不着头脑。如果知道设备分区使用的文件系统类型，可以像下面这样过滤输出。

   ```bash
   $ mount -t ext4
   /dev/sda5 on / type ext4 (rw,relatime,errors=remount-ro)
   $ mount -t vfat
   /dev/sda2 on /boot/efi type vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=iso88591,shortname=mixed,errors=remount-ro)
   /dev/sdb1 on /media/rich/54A1-7D7D type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remountro,uhelper=udisks2)
   $
   ```

   `mount`命令提供了 4 部分信息。

   - 设备文件名
   - 设备在虚拟目录中的挂载点
   - 文件系统类型
   - 已挂载设备的访问状态

   在上面例子的最后一行输出中，U 盘被 GNOME 桌面自动挂载到了挂载点 /media/rich/54A1-7D7D。vfat 文件系统类型说明它是在 Microsoft Windows PC 中格式化的。

   要手动在虚拟目录中挂载设备，需要以 root 用户身份登录，或是以 root 用户身份运行`sudo`命令。下面是手动挂载设备的基本命令：

   ```bash
   mount -t type device directory
   ```

   其中，`type`参数指定了磁盘格式化所使用的文件系统类型。Linux 可以识别多种文件系统类型。如果与 Windows PC 共用移动存储设备，那么通常需要使用下列文件系统类型。

   - **vfat**：Windows FAT32 文件系统，支持长文件名
   - **ntfs**：Windows NT 及后续操作系统中广泛使用的高级文件系统
   - **exfat**：专门为可移动存储设备优化的 Windows 文件系统
   - **iso9660**：标准 CD-ROM 和 DVD 文件系统

   大多数 U 盘会使用 vfat 文件系统格式化。如果需要挂载数据 CD 或 DVD，则必须使用 iso9660 文件系统类型。

   后面两个参数指定了该存储设备的设备文件位置以及挂载点在虚拟目录中的位置。例如，手动将 U 盘 /dev/sdb1 挂载到 /media/disk，可以使用下列命令：

   ```bash
   mount -t vfat /dev/sdb1 /media/disk
   ```

   一旦存储设备被挂载到虚拟目录，root 用户就拥有了对该设备的所有访问权限，而其他用户的访问则会被限制。可以通过目录权限（参见第 7 章）指定用户对设备的访问权限。

   如果需要使用`mount`命令的一些高级特性，可以参见表 4-5 中列出的相关选项。

   **表 4-5　`mount`命令选项**

   | 选项         | 描述                                                    |
   | :----------- | :------------------------------------------------------ |
   | `-a`         | 挂载 /etc/fstab 文件中指定的所有文件系统                |
   | `-f`         | 模拟挂载设备，但并不真正挂载                            |
   | `-F`         | 和`-a`选项一起使用时，同时挂载所有文件系统              |
   | `-v`         | 详细模式，显示挂载设备的每一步操作                      |
   | `-i`         | 不使用 /sbin/mount.filesystem 下的任何文件系统协助文件  |
   | `-l`         | 自动给 ext2、ext3、ext4 或 XFS 文件系统添加文件系统标签 |
   | `-n`         | 挂载设备，但不在 /etc/mtab 已挂载设备文件中注册         |
   | `-p *num*`   | 进行加密挂载时从文件描述符`*num*`中获得口令             |
   | `-s`         | 忽略该文件系统不支持的挂载选项                          |
   | `-r`         | 将设备挂载为只读                                        |
   | `-w`         | 将设备挂载为可读写（默认选项）                          |
   | `-L *label*` | 将设备按指定的`*label*`挂载                             |
   | `-U *uuid*`  | 将设备按指定的`*uuid*`挂载                              |
   | `-O`         | 和`-a`选项一起使用，限制其所作用的文件系统              |
   | `-o`         | 给文件系统添加特定的选项                                |

   `-o`选项允许在挂载文件系统时添加一系列以逗号分隔的额外选项。常用选项如下。

   - `ro`：以只读形式挂载
   - `rw`：以读写形式挂载
   - `user`：允许普通用户挂载该文件系统
   - `check=none`：挂载文件系统时不执行完整性校验
   - `loop`：挂载文件

2. **`umount`命令**

   移除可移动设备时，不能直接将设备拔下，应该先**卸载**。

   > **提示**
   >
   > Linux 不允许直接弹出已挂载的 CD 或 DVD。如果在从光驱中移除 CD 或 DVD 时遇到麻烦，那么最大的可能是它还在虚拟目录中挂载着。应该先卸载，然后再尝试弹出。

   卸载设备的命令是`umount`（是的，你没看错，命令名中并没有字母“n”，这一点有时候很让人困惑）。`umount`命令的格式非常简单：

   ```bash
   umount [directory | device ]
   ```

   `umount`命令支持通过设备文件或者挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，则系统将不允许卸载该设备。

   ```bash
   $ umount /home/rich/mnt
   umount: /home/rich/mnt: device is busy
   umount: /home/rich/mnt: device is busy
   $ cd /home/rich
   $ umount /home/rich/mnt
   $ ls -l mnt
   total 0
   $
   ```

   在本例中，因为命令行提示符仍然位于已挂载设备的文件系统中，所以`umount`命令无法卸载该镜像文件。一旦命令提示符移出其镜像文件系统，`umount`命令就能成功卸载镜像文件了。

   > 如果在卸载设备时，系统提示设备繁忙，无法卸载，那么通常是有进程还在访问该设备或使用该设备上的文件。这时可用`lsof`命令获得相关进程的信息，然后将进程终止。`lsof`命令的用法很简单：`lsof /path/to/device/node`，或者`lsof /path/to/mount/point`。

### 2.2 使用**`df`**命令

有时需要知道在某台设备上还有多少磁盘空间。`df`命令可以方便地查看所有已挂载磁盘的使用情况：

```bash
$ df -t ext4 -t vfat
Filesystem     1K-blocks       Used Available Use% Mounted on
/dev/sda5       19475088    7326256  11136508  40% /
/dev/sda2         524272          4    524268   1% /boot/efi
/dev/sdb1         983552     247264    736288  26% /media/
rich/54A1-7D7D
$
```

`df`命令会逐个显示已挂载的文件系统。与`mount`命令类似，`df`命令会输出内核挂载的所有虚拟文件系统，因此可以使用`-t`选项来指定文件系统类型，进而过滤输出结果。该命令的输出如下。

- 设备文件位置
- 包含多少以 1024 字节为单位的块
- 使用了多少以 1024 字节为单位的块
- 还有多少以 1024 字节为单位的块可用
- 已用空间所占的百分比
- 设备挂载点

`df`命令的大部分选项你根本不会用到。常用选项之一是`-h`，该选项会以人类易读（human-readable）的形式显示磁盘空间，通常用 M 来替代兆字节，用 G 来替代吉字节：

```bash
$ df -h
Filesystem             Size  Used Avail Use% Mounted on
/dev/sda5         19G  7.0G   11G  40% /
/dev/sda2        512M  4.0K  512M   1% /boot/efi
/dev/sdb1        961M  242M  720M  26% /media/rich/54A1-7D7D
$
```

现在不用再费心琢磨这些丑陋的块数了，所有的磁盘空间大小都是以“正常”的存储单位显示的。`df`命令在排查系统磁盘空间问题时非常有价值。

> **注意**
>
> 记住，Linux 系统后台一直有进程在处理文件。`df`命令的出值反映的是 Linux 系统认为的当前值。正在运行的进程有可能创建或删除了某个文件，但尚未释放该文件。这个值是不会被计算进闲置空间的。

### 2.3 使用`du`命令

通过`df`命令，很容易发现哪个磁盘存储空间不足。系统管理员面临的下一个问题是如何应对这种情况。

另一个能助你一臂之力的是`du`命令。`du`命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这有助于你快速判断系统中是否存在磁盘占用“大户”。

在默认情况下，`du`命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，并以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说，输出内容可不少。下面是`du`命令的部分输出：

```bash
$ du
484      ./.gstreamer-0.10
8        ./Templates
8        ./Download
8        ./.ccache/7/0
24       ./.ccache/7
368      ./.ccache/a/d
384      ./.ccache/a
424      ./.ccache
8        ./Public
8        ./.gphpedit/plugins
32       ./.gphpedit
72       ./.gconfd
128      ./.nautilus/metafiles
384      ./.nautilus
8        ./Videos
8        ./Music
16       ./.config/gtk-2.0
40       ./.config
8        ./Documents
```

每行最左侧的数字是每个文件或目录所占用的磁盘块数。注意，这个列表是从目录层级的最底部开始，然后沿着其中包含的文件和子目录逐级向上的。

单纯的`du`命令作用并不大。我们更想知道每个文件和目录各占用了多大的磁盘空间，但如果还需逐页翻找的话就没什么意义了。

下面这些选项能让`du`命令的输出更加清晰易读。

- `-c`：显示所有已列出文件的总大小
- `-h`：按人类易读格式输出大小，分别用 K 表示千字节、M 表示兆字节、G 表示吉字节
- `-s`：输出每个参数的汇总信息

系统管理员的下一步任务是使用一些文件处理命令来操作大量数据。这正是下一节的主题。

## 3.处理数据文件

当有大量数据时，处理这些数据并从中提取有用信息通常不是件容易事。通过上一节的`du`命令可知，系统命令很容易输出让人难以招架的过量信息。

Linux 系统提供了一些可以帮助你管理大量数据的命令行工具。本节涵盖了每位系统管理员以及日常 Linux 用户都应该知道的基本命令，这些命令能够让其生活变得更加轻松。