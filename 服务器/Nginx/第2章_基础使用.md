# 第2章_基础使用

## 1.目录结构

进入 Nginx 的主目录我们可以看到这些文件夹

```bash
- nginx
	- client_body_temp
	- conf
	- fastcgi_temp html
	- logs
	- proxy_temp
	- sbin scgi_temp
	- uwsgi_temp
```

其中这几个文件夹在刚安装后是没有的，主要用来存放运行过程中的临时文件

```bash
- client_body_temp
- fastcgi_temp
- proxy_temp
- scgi_temp
```

**conf**

用来存放配置文件相关

**html**

用来存放静态文件的默认目录 html、css 等

**sbin**

nginx 的主程序

**logs**

用来记录每个用户的访问日志，占用会不断增大，需要注意

## 2.基本运行原理

Master 是一个主进程，在读取配置文件后，会开启多个子进程处理响应。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220519214911034-5eb37e8e658a973cf48974e1ba051111-dfc1e1.png" alt="image-20220519214911034" style="zoom:80%;" />

```bash
[root@myServer1 nginx]# ps -ef | grep nginx
root      25192      1  0 21:22 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
nobody    25194  25192  0 21:22 ?        00:00:00 nginx: worker process
```

## 3.Nginx配置与应用场景

### 3.1 基础配置

```bash
# 启动时创建业务进程的数量，默认为 1，最好跟内核数量一样
worker_processes  1;
events {
	# 单个业务进程可接受连接数，默认 1024
    worker_connections  1024;
}
http {
	# 引入另一个文件，记录了 http mime 类型，例如 text/html
    include       mime.types;
    # 默认类型，这里表示如果 mime 类型没匹配上，则使用二进制流的方式传输
    default_type  application/octet-stream;
    # 使用 linux 的 sendfile(socket, file, len) 高效网络传输，也就是数据 0 拷贝
    sendfile        on;
    # 保持连接时超时的时间
    keepalive_timeout  65;
    server {
    	# 监听端口号
        listen       80;
        # 主机名
        server_name  localhost;
        # 匹配路径
        location / {
            # 若想拒绝还可以使用 deny all;
        	# 文件根目录
            root   html;
            # 默认页名称
            index  index.html index.htm;
        }
        # 报错编码对应页面
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

**sendfile**

- 未开启

  ![image-20220519212827050](https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220519212827050-5cc256b48b7cb5bdaccc649b4e1280f3-ab6120.png)

- 开启后

  ![image-20220519212856093](https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220519212856093-6541e2270a2ca75065bf644c756ff4f4-84521b.png)

### 3.2 虚拟主机

#### 1.网络传输概览

![image-20220519212951909](https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220519212951909-2fe240b285ba45f6df19333a0296d9f2-33ca83.png)

原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务。

#### 2.在本机指定虚拟域名解析

修改本机的`C:\Windows\System32\drivers\etc\hosts`文件

```bash
192.168.11.101 myServer1
```

在本机上`ping myServer1`可以发现自动解析为`192.168.11.101`

#### ==3.公网域名配置==

申请好域名后，将该域名与服务器的`IP`地址进行链接

> 可以指定为内网的`IP`，这样当 DNS 服务器解析域名后会指向内网，此时就可以通过该域名直接访问内网了。

例如制定了`*.youyi.com`到`192.168.11.101`上。

#### ==4.Nginx虚拟主机域名配置==

在`/`目录下新建`www`文件夹作为网站根目录

```bash
[root@myServer1 /]# mkdir www
```

在`www`目录下新建两个文件夹`directory1`、`directory2`

```bash
[root@myServer1 www]# mkdir directory1
[root@myServer1 www]# mkdir directory2
```

分别在两个文件夹下新建`index.html`文件

修改`nginx.conf`文件，将`server`标签下的`location`分别指向`www`根目录下的`directory1`和`directory2`

```bash
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   /www/directory1;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
        listen       81;
        server_name  localhost;
        location / {
            root   /www/directory2;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

```

重新加载`nginx`服务器

```bash
[root@myServer1 conf]# systemctl reload nginx.service
```

分别访问`myServer1:80/`和`myServer1:81`：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521165518834-ce910827476705340e8dc2ae88314788-ba7e92.png" alt="image-20220521165518834" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521165536761-a370fce13d1e70ea5fd6490b78e2419c-1a5d08.png" alt="image-20220521165536761" style="zoom:80%;" />

**也可以修改域名**

```bash
    server {
        listen       80;
        server_name  directory1.youyi.com;
        location / {
            root   /www/directory1;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
        listen       80;
        server_name  directory2.youyi.com;
        location / {
            root   /www/directory2;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

```

> **注意**
>
> 需要配置公网域名`*.youyi.com`指向`192.168.11.101`，或者在本机的`hosts`文件中配置
>
> ```bash
> 192.168.11.101 directory1.youyi.com
> 192.168.11.101 directory2.youyi.com
> ```

结果如下

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521173422101-6433767b21938e3eb548473f7ae14133-f64556.png" alt="image-20220521173422101" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521173430377-3427feebf7b2c7138b3bd38792ffd376-ffb240.png" alt="image-20220521173430377" style="zoom:80%;" />

#### 5.servername匹配规则

我们需要注意的是 servername 匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。如果都没有匹配上，则会优先访问第一个`server`站点。

**完整匹配**

我们可以在同一 servername 中匹配多个域名

```bash
server_name vod.youyi.com www1.youyi.com;
```

**通配符匹配**

```bash
server_name *.youyi.com
```

**通配符结束匹配**

```bash
server_name vod.*;
```

**正则匹配**

以符号`~`开头表示开启正则匹配

```bash
server_name ~^[0-9]+\.youyi\.com$;
```

## ==4.反向代理==

**如何理解反向**

当客户端主动使用代理连接服务器时是正向，当代理做用于服务器端，负责处理客户端需求时是反向。其本质上是相同的，都是一个**网关**，只是站的角度不同。

Nginx 属于`隧道式代理`，数据必须要经过 Nginx 在客户端和服务端之间传递，数据传输的速度取决于 Nginx 的带宽。

还有一种`lvs`负载均衡器，属于`DR模型`，客户端传给服务端的数据要经过`lvs`的分发，但是服务端传给客户端时不需经过`lvs`，但是功能较少。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521174839787-930d4eca464f336e7bdce1d9a18a48f9-30c4c2.png" alt="image-20220521174839787" style="zoom:80%;" />

```bash
location / {
	# 和 root 属性二选一
	# 表示访问该地址时重定向到 www.baidu.com，注意要加上协议 http
	# 此时地址栏显示的还是原来访问的地址
	proxy_pass http://www.baidu.com;
   }
```

> **注意**
>
> - 地址要写准确，例如若省略了`www`则 Nginx 会返回 302 状态并让浏览器重定向到`www.baidu.com`，此时地址栏就会改变

### 4.1 基于反向代理的负载均衡

**负载均衡**：一种冗余设计，提高系统的可用性，通过搭建服务器集群，当一台系统宕机后，请求会转移到其他系统上提供相同的服务。

配置`192.168.11.101`的`nginx.conf`文件指定集群地址：

```bash
# 在 server 标签外定义别名 httpds，该名字可任意
upstream httpds {
	server 192.168.11.102;
	server 192.168.11.103;

}

server {
	listen       80;
	server_name  localhost;
    location / {
    # 指定 httpds
    proxy_pass http://httpds;
	}
	...
}
```

访问`192.168.11.101`可以发现访问在`102`和`103`之间依次改变。

### 4.2 负载均衡策略

- `轮询`

默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求。

- `权重`

  指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。

  ```bash
  upstream httpd {
  server 127.0.0.1:8050 weight=10 down;
  server 127.0.0.1:8060 weight=1;
  server 127.0.0.1:8060 weight=1 backup;
  }
  ```

  - `weight`：默认为1，weight 越大，负载的权重就越大
  - `down`（不怎么用）：表示当前的 server 暂时不参与负载
  - `backup`（不怎么用）： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器

- `ip_hash`：根据客户端的 ip 地址转发同一台服务器，可以保持回话

- `least_conn`：最少连接访问，优先转发到连接次数较少的服务器

- `url_hash`：需要第三方插件，根据用户访问的 url 定向转发请求

- `fair`：需要第三方插件，根据后端服务器响应时间转发请求，会有流量倾斜的风险

## 5.动静分离

### 5.1 使用场景

把静态资源放到`Nginx`中，动态资源由`Tomcat`处理。

首先将项目部署到`192.168.11.103`的`Tmocat`中，在`192.168.11.101`的`Nginx`配置文件中修改代理地址：

```bash
location / {
	# 103 的 Tomcat 地址
	proxy_pass http://192.168.11.103:8080;
}
```

访问`192.168.11.101`：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521210255122-6039e24bd88a0785727509d087304ae8-918d74.png" alt="image-20220521210255122" style="zoom:67%;" />



可以发现`CSS`和图片等信息都能加载，这些资源现在都是从`103`机器上得到的，接下来把它们移动到`101`的`Nginx`服务器中。

首先删除`103`上的`CSS`和图片资源，再访问`192.168.11.101`时就会发现已经不会加载不到这些资源了。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521210914774-6c7b5e616ad9f5b2890274e75aa53f37-3e9c7c.png" alt="image-20220521210914774" style="zoom:67%;" />

接下来将资源移动到`101`的`nginx`中：

```bash
[root@myServer1 html]# pwd
/usr/local/nginx/html
[root@myServer1 html]# ll
总用量 8
-rw-r--r--. 1 root root 497 5ﾔﾂ  19 21:12 50x.html
drwxr-xr-x. 2 root root  61 5ﾔﾂ  21 21:19 css
drwxr-xr-x. 2 root root 126 5ﾔﾂ  21 21:19 img
-rw-r--r--. 1 root root 615 5ﾔﾂ  19 21:12 index.html
```

配置`nginx.conf`文件，对每一类资源设置其相应的`location`：

```bash
location / {
	proxy_pass http://192.168.11.103:8080;
}

location /css {
	root   html;
	index  index.html index.htm;
}

location /img {
	root   html;
	index  index.html index.htm;
}
```

再次访问`192.168.11.101`可以发现成功加载了所有资源：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220521212206632-0fa8463822b9e13ed445c7dee0d63326-7116ad.png" alt="image-20220521212206632" style="zoom:80%;" />

**使用正则**

location 前缀

- `/`：通用匹配，任何请求都会匹配到
- `=`：精准匹配，不是以指定模式开头
- `~`：正则匹配，区分大小写
- `~*`：正则匹配，不区分大小写
- `^~`：非正则匹配，匹配以指定模式开头的 location

**location 匹配顺序**

- 多个正则 location 直接按**书写顺序**匹配，成功后就不会继续往后面匹配
- 普通（非正则）location 会一直往下，直到找到匹配度最高的（最大前缀匹配）
- 当普通 location 与正则 location 同时存在，如果正则匹配成功，则不会再执行普通匹配
- 所有类型 location 存在时，`=`匹配 > `^~`匹配 > 正则匹配 > 普通（最大前缀匹配）

```bash
location ~*/(css|img) {
	root   html;
	index  index.html index.htm;
} 
```

> **alias 与 root**
>
> ```Bash
> location /css {
> 	alias /usr/local/nginx/static/css/;
> 	index index.html index.htm;
> }
> ```
>
> `root`用来设置根目录，而`alias`在接受请求的时候在路径上不会加上 location。
>
> - alias 指定的目录是准确的，即 location 匹配访问的 path 目录下的文件直接是在 alias 目录下查找的
> - root 指定的目录是 location 匹配访问的 path 目录的上一级目录，这个 path 目录一定要是真实存在 root 指定目录下的
> - 使用 alias 标签的目录块中不能使用 rewrite 的 break（具体原因不明），另外，alias 指定的目录后面必须要加上`/`符号！！
> - alias 虚拟目录配置中，location 匹配的 path 目录如果后面不带`/`，那么访问的 url 地址中这个 path 目录后面加不加`/`不影响访问，访问时它会自动加上`/`，但是如果 location 匹配的 path 目录后面加上`/`，那么访问的 url 地址中这个 path 目录必须要加上`/`，访问时它不会自动加上`/`。如果不加上`/`，访问就会失败！
> - root 目录配置中，location 匹配的 path 目录后面带不带`/`，都不会影响访问

### 5.2 UrlRewrite伪静态配置

可以用来隐藏请求的服务名和参数。

rewrite 是实现 URL 重写的关键指令，根据 regex（正则表达式）部分内容，重定向到 replacement，结尾是 flag 标记。

`rewrite <regex> <replacement> [flag];`

`关键字 正则 替代内容 flag标记`

- 关键字：其中关键字 error_log 不能改变
- 正则：perl 兼容正则表达式语句进行规则匹配
- 替代内容：将正则匹配的内容替换成 replacement
- flag标记：rewrite 支持的 flag 标记

rewrite 参数的标签段位置：server、location、if

`flag`标记说明：

- last：本条规则匹配完成后，继续向下匹配新的 location URI 规则
- break：本条规则匹配完成即终止，不再匹配后面的任何规则
- redirect：返回 302 临时重定向，浏览器地址会显示跳转后的 URL 地址
- permanent：返回 301 永久重定向，浏览器地址栏会显示跳转后的 URL 地址

**实例**

```bash
location / {
    # ()表示入参的参数，用$来接受参数
    rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 break;
|
```

### 5.3 同时使用负载均衡

通过防火墙配置模拟真是部署环境：`Tomcat`服务器只能被内网访问，无法被外网直接访问，只能通过`nginx`服务器。

应用服务器防火墙配置：

**开启防火墙**

```bash
systemctl start firewalld
```

**重启防火墙**

```bash
systemctl restart firewalld
```

**指定端口和ip访问**

```Bash
firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.11.101" port protocol="tcp" port="8080" accept"
```

**重载规则**

```bash
firewall-cmd --reload
```

**查看已配置规则**

```Bash
firewall-cmd --list-all
```

此时外网已经无法访问`192.168.11.103:8080`，只能通过`Nginx`反向代理服务器访问。这时`Nginx`服务器就是一台**网关服务器**，可以管理`动静分离`、`URL rewrite`、`负载均衡`、`反向代理`等功能。

**移除规则**

```Bash
firewall-cmd --permanent --remove-rich-rule="rule family="ipv4" source
address="192.168.44.101" port port="8080" protocol="tcp" accept"
```

**网关配置**

```Bash
upstream httpds {
	server 192.168.11.102 weight=8 down;
	server 192.168.11.103:8080 weight=1 backup;
}
location / {
	rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 redirect;
	proxy_pass http://httpds;
}
```

## 6.防盗链

对于资源的访问不是由本站点发起的，而是由其他站点或非正当访问发起的，该种行为被称为**盗链**。有时候我们是不禁止这种行为的，但是当需要防盗链时，可以通过检查`http`请求头中的`refer`属性来判断该请求是否由本站点发起的。

```bash
valid_referers none | blocked | server_names | strings ....;
```

- `none`：检测 Referer 头域不存在的情况
- `blocked`：检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以“http://” 或 “https://” 开头。
- `server_names`：设置一个或多个 URL ，检测 Referer 头域的值是否是这些 URL 中的某一个

### 6.1 返回错误码

在需要防盗链的`location`中配置

```bash
location ~*/(js|img|css) {
	# 表示只允许 refer 是 192.168.11.101 的访问请求
    valid_referers 192.168.11.101;
    # 如果是其他站点访问
    if ($invalid_referer) {
    	# 返回错误码
        return 403;
    }
    root html;
    index index.html index.htm;
}
```

### 6.2 使用 curl 测试

```Bash
# -I：返回相应的头信息
$ curl -I http://192.168.11.101/img/Snipaste_2022-01-08_01-46-40.png
HTTP/1.1 403 Forbidden
Server: nginx/1.21.6
Date: Sun, 22 May 2022 13:50:11 GMT
Content-Type: text/html
Content-Length: 153
Connection: keep-alive
```

带上`192.168.11.101`的引用之后就可以访问了：

```bash
# -e：带上引用 refer
$ curl -e "http://192.168.11.101" -I http://192.168.11.101/img/Snipaste_2022-01-08_01-46-40.png
HTTP/1.1 200 OK
Server: nginx/1.21.6
Date: Sun, 22 May 2022 13:52:14 GMT
Content-Type: image/png
Content-Length: 16353
Last-Modified: Sat, 21 May 2022 12:19:28 GMT
Connection: keep-alive
ETag: "6288d8d0-3fe1"
Accept-Ranges: bytes
```

> 如果希望没有`refer`时也可以正常访问（直接访问该资源），可设置`none`参数：
>
> ```bash
> location ~*/(js|img|css) {
> 	# 表示只允许 refer 是 192.168.11.101 或没有 refer 的访问请求
>     valid_referers none 192.168.11.101;
>     if ($invalid_referer) {
>         return 403;
>     }
>     root html;
>     index index.html index.htm;
> }
> ```

### 6.3 指定返回错误页面

在 html 目录下新建一个`403.html`作为错误页面。修改配置文件：

```bash
# 新添加一个 error_page 配置
error_page   403  /403.html;
location = /403.html {
	root   html;
}

# or

# 直接返回错误页面地址
location ~*/(css|img) {
	valid_referers 192.168.11.101;
	if ($invalid_referer) {
		return /403.html;
	}
	root   html;
	index  index.html index.htm;
}
```

### 6.4 返回报错图片

不返回错误码或错误页面，而是直接`rewrite`到错误图片：

```bash
location ~*/(css|img) {
	valid_referers 192.168.11.101;
	if ($invalid_referer) {
		rewrite ^/ /img/xxx.png break;
	}
	root   html;
	index  index.html index.htm;
}
```

## 7.高可用配置

创建一个虚拟 IP 地址供服务访问，具体请求发送到哪台服务器上由`keepalived`来决定。这样当主机宕机后，keepalived 只需将请求发送到活跃的服务器上，用户访问时只需访问虚拟 IP 地址即可。

### 7.1 安装Keepalived

#### 1.编译安装

下载地址

https://www.keepalived.org/download.html#

使用 ./configure 编译安装

如遇报错提示

```bash
configure: error:
!!! OpenSSL is not properly installed on your system. !!!
!!! Can not include OpenSSL headers files. !!!
```

安装依赖

```bash
yum install openssl-devel
```

#### 2.yum安装

```Bash
yum install keepalived
```

> 安装 keepalived 出现==错误==：
>
> ```shell
> --> 正在处理依赖关系 libmysqlclient.so.18()(64bit)，它被软件包 1:net-snmp-agent-libs-5.7.2-49.el7_9.1.x86_64 需要
> --> 解决依赖关系完成
> 错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.1.x86_64 (updates)
>           需要：libmysqlclient.so.18()(64bit)
> 错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.1.x86_64 (updates)
>           需要：libmysqlclient.so.18(libmysqlclient_18)(64bit)
>  您可以尝试添加 --skip-broken 选项来解决该问题
>  您可以尝试执行：rpm -Va --nofiles --nodigest
> ```
>
> 缺少插件，需要下载安装：
>
> ```shell
> wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm
> rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm
> ```
>
> 安装完成后，重新尝试安装keepalived
>
> ```shell
> yum install keepalived
> ```

### 7.2 配置

使用 yum 安装后配置文件在`/etc/keepalived/keepalived.conf`

**最小配置**

第一台机器

```bash
! Configuration File for keepalived

global_defs {
   router_id 101
}

vrrp_instance youyi {
    state MASTER
    # 网卡类型
    interface ens33
    virtual_router_id 51
    # 优先级
    priority 100
    # 间隔检测时间
    advert_int 1
    # 组的认证配置
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    # 虚拟 IP
    virtual_ipaddress {
        192.168.11.200
    }
}
```

第二台机器

```bash
! Configuration File for keepalived

global_defs {
   router_id 103
}

vrrp_instance youyi {
    state BACKUP
    # 网卡类型
    interface ens33
    virtual_router_id 51
    # 优先级
    priority 50
    # 间隔检测时间
    advert_int 1
    # 组的认证配置
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    # 虚拟 IP
    virtual_ipaddress {
        192.168.11.200
    }
}
```

> `vrrp_instance`、`virtual_router_id`和`authentication`要相同，这样才能配置到一个组中

启动服务

```bash
systemctl start keepalived
```

## 8.Https证书配置

**不安全的http协议**

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220519214250787-b3739f57e6f0b19658fdc38828ac3737-6a11f3.png" alt="image-20220519214250787" style="zoom:150%;" />

**非对称加密**

公钥加密，私钥解密；私钥加密，公钥解密；公钥不能揭秘公钥。

但是非对称加密也是不安全的，拦截者可能会截获公钥然后篡改数据发送到服务器，得到服务器传回的私密信息后分配一个假私钥，然后糊弄客户端。为了保证中间数据不会被篡改，CA 机构诞生了。

**CA机构**

服务端首先向 CA 机构提交公钥认证，认证通过后 CA 机构会用自己的私钥对提交的公钥进行非对称加密，制作成证书。当客户端申请公钥时，直接将证书下发回去。操作系统中内置了 CA 机构的公钥。如果操作系统能够顺利解开该证书得到服务器的公钥，说明该证书没有经过篡改。 

**自签名**

- OpenSSL

  是一款开源软件，可以用来生成证书。其包含：SSL 协议库、应用程序以及密码算法库

- 图形化工具 XCA

  下载地址：https://www.hohnstaedt.de/xca/index.php/download

## 9.在线证书申请

### 9.1 申请域名

### 9.2 申请服务器

注意修改防火墙端口开放。

### 9.3 安装lnmp环境

该环境集成了 nginx、mysql、PHP，可在`oneinstack.com`进行配置然后生成安装命令。

### 9.4 解析域名到主机

### 9.5 在线申请证书

申请 SSL 证书，绑定域名。

### 9.6 配置Nginx证书

查看 nginx 是否安装 http_ssl_module 模块。

```javascript
$ /usr/local/nginx/sbin/nginx -V
```

如果出现 configure arguments: –with-http_ssl_module, 则已安装（下面的步骤可以跳过，进入 nginx.conf 配置）。

> ### http_ssl_module
>
> 下载安装包
>
> ```javascript
> $ cd /usr/local/src
> $ wget http://nginx.org/download/nginx-1.15.9.tar.gz
> ```
>
> 解压安装包。
>
> ```javascript
> $ tar -zxvf nginx-1.15.9.tar.gz
> ```
>
> 配置 SSL 模块。
>
> ```javascript
> $ cd nginx-1.15.9
> $ ./configure --prefix=/usr/local/nginx --with-http_ssl_module
> ```
>
> 使用 make 命令编译（使用make install会重新安装nginx），此时当前目录会出现 objs 文件夹。
>
> 用新的 nginx 文件覆盖当前的 nginx 文件。
>
> ```javascript
> $ cp ./objs/nginx /usr/local/nginx/sbin/
> ```
>
> 再次查看安装的模块（configure arguments: –with-http_ssl_module说明ssl模块已安装）。
>
> ```javascript
> $ /usr/local/nginx/sbin/nginx -V
> 
> nginx version: nginx/1.15.9
> ...
> configure arguments: --with-http_ssl_module
> ```

下载 Nginx 证书，包含两个文件`.key`、`.pem`，传到服务器上`nginx`目录下的`conf`文件夹下。

**修改 Nginx 配置文件**

新添加一个`server`标签：

```bash
server {
	# 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块
	listen 443 ss1;
	# 指定需要证书访问的域名，多个以空格隔开
	server_name youyi.com www.youyi.com;
	
	# 自动从 Nginx 的 conf 路径下找
	ss1_certificate xxx.pem;
	ss1_certificate_key xxx.key;
}
```

http 重定向 https

```javascript
server {
    listen       80;
    server_name  youyi.com www.youyi.com;
    return 301 https://$server_name$request_uri;
}
```

## 10.扩展

**安装 Discuz BBS开源**

将压缩包解压到`html`文件夹下，直接通过浏览器访问`/upload`（可以重命名）文件夹就可以在线安装。
