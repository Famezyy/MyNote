# 第10章_日期处理

## 1.Date

如果字段属性是`Date`而非`LocalDateTime`时，通常我们会在`application.properties`里面配置如下：

```properties
spring.mvc.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
spring.jackson.serialization.write-dates-as-timestamps=false
```

`spring.jackson`开头的配置会被`JacksonProperties`类获取进行使用。当返回 json 格式的时候，Jackson 就会根据配置文件中日期格式化的配置对结果进行处理。

但是如果字段属性为`LocalDateTime`这种配置就失去了作用。

## 2.LocalDateTime

### 2.1 GET请求

#### ==1.配置全局的日期Converter==

若 GET 请求的参数或 POJO 中存在日期类型的字段，可以配置全局的日期转换器`localDateTimeConvert`：

```java
@Configuration
public class DateConverterConfig {
    @Bean
    public Converter<String, LocalDate> localDateConverter() {
          return new Converter<String, LocalDate>() {
            @Override
            public LocalDate convert(String source) {
                return LocalDate.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
            }
        };
    }

    @Bean
    public Converter<String, LocalDateTime> localDateTimeConverter() {
        return new Converter<String, LocalDateTime>() {
            @Override
            public LocalDateTime convert(String source) {
                return LocalDateTime.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            }
        };
    }
}
```

同样适用于`LocalDateTime`的返回值。

> 由于需要泛型信息来指定转换的对象，因此不能返回一个`lambda`表达式，否则会报错。
>
> 可以等`requestMappingHandlerAdapter`注册完成之后再添加自己的`converter`就不会注册到`FormattingConversionService`中：
>
> ```java
> @Bean
> @ConditionalOnBean(name = "requestMappingHandlerAdapter")
> public Converter<String, LocalDateTime> localDateTimeConverter() {
>     return source -> LocalDateTime.parse(source, DateTimeUtils.DEFAULT_FORMATTER);
> }
> ```

#### 2.使用ControllerAdvice配合initBinder

这是在 controller 做环切（这里面还可以全局异常捕获），在参数进入 handler 之前进行转换；转换为我们相应的对象。

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(LocalDate.class, new PropertyEditorSupport() {
            @Override
            public void setAsText(String text) throws IllegalArgumentException {
                setValue(LocalDate.parse(text, DateTimeFormatter.ofPattern("yyyy-MM-dd")));
            }
        });
        binder.registerCustomEditor(LocalDateTime.class, new PropertyEditorSupport() {
            @Override
            public void setAsText(String text) throws IllegalArgumentException {
                setValue(LocalDateTime.parse(text, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            }
        });
        binder.registerCustomEditor(LocalTime.class, new PropertyEditorSupport() {
            @Override
            public void setAsText(String text) throws IllegalArgumentException {
                setValue(LocalTime.parse(text, DateTimeFormatter.ofPattern("HH:mm:ss")));
            }
        });
    }
}
```

### 2.2 POST请求

若请求的返回体中存在日期类型的字段，或者 POST 请求中存在日期类型的字段，则不是由转换器负责，而是由 Jackon 负责转换。

#### 1.配置application.yml文件

```yaml
spring:
    jackson:
        date-format: yyyy-MM-dd HH:mm:ss
        time-zone: GMT+8
```

- 支持 content-type=application/json 请求中格式为 `yyyy-MM-dd HH:mm:ss`的字符串，后台用`@RequestBody`接收，及返回值 date 转为`yyyy-MM-dd HH:mm:ss`格式 string
- 不支持 content-type=application/json 请求中 yyyy-MM-dd 等类型的字符串转为`Date`
- 不支持 java8 日期 api，例如`LocalDate`

#### ==2.配置全局Jackson序列化器==

```java
@Configuration
public class JacksonConfig {

    /** 默认日期时间格式 */
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    /** 默认日期格式 */
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    /** 默认时间格式 */
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = new ObjectMapper();

        // 忽略json字符串中不识别的属性
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 忽略无法转换的对象 
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        // PrettyPrinter 格式化输出
        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        // NULL不参与序列化
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

        // 指定时区
        objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));
        // 日期类型字符串处理
        objectMapper.setDateFormat(new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT));

        // java8日期日期处理
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
        objectMapper.registerModule(javaTimeModule);

        converter.setObjectMapper(objectMapper);
        return converter;
    }
}
```

- 支持 content-type=application/json 请求中格式为`yyyy-MM-dd HH:mm:ss`的字符串，后台用`@RequestBody`接收，及返回值 Date 转为`yyyy-MM-dd HH:mm:ss`格式 String
- 支持 java8 日期 api，例如`LocalDate`
- 不支持 content-type=application/json 请求中`yyyy-MM-dd`等类型的字符串转为`Date`

### 2.3 单独指定字段

#### 1.@DateTimeFormat

使用 spring 自带注解`@DateTimeFormat(pattern = "yyyy-MM-dd")`，如下：

```java
@DateTimeFormat(pattern = "yyyy-MM-dd")
private LocalDate startDate;
```

- 若同时配置了全局转换器，则注解会失效，当参数使用注解指定的格式时，该值会为 null，支持`Date`

- 只适用于**GET**的请求字段

#### 2.@JsonFormat

```java
@JsonFormat( pattern = "yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
private Date createdDate;

@JsonFormat( pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime createdTime;
```

- 适用于请求的返回字段和**POST**的请求字段（即发生序列化时）
- 会覆盖全局配置

