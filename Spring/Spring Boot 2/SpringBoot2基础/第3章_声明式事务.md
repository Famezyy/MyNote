# 第3章_声明式事务

## 1.声明式事务

### 1.1 简单环境搭建

1. 导入相关依赖：数据源，数据驱动，Spring-jdbc模块

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>

<!-- 数据源 -->
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
```

2. 配置数据源，JdbcTemplate（Spring 提供简化数据库操作的工具） 操作数据

```java
@Configuration
@ComponentScan("com.youyi.boot.tx")
public class TxConfig {
    @Bean
    public DataSource dataSource() throws PropertyVetoException {
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setUser("root");
        dataSource.setPassword("root");
        dataSource.setDriverClass("com.mysql.jdbc.Driver");
        // 需配置 timezone
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8");

        return dataSource;
    }

    // Spring 对 @Configuration 类会特殊处理，给容器中添加组件的方法，多次调用都只是从容器中找组件而已，不会再次执行方法创建组件
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

3. 创建 UserDao

```java
@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void insert() {
        String sql = "INSERT INTO tbl_user(username, age) VALUES(?, ?)";
        String username = UUID.randomUUID().toString().substring(0, 5);
        jdbcTemplate.update(sql, username, 19);
    }
}
```

4. 创建 UserService

```java
public class UserService {

    @Autowired
    private UserDao userDao;

    public void insertUser() {
        userDao.insert();
        System.out.println("insert finished");
    }
}
```

5. 测试

```java
@Test
public void test01() {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class);
    UserService bean = applicationContext.getBean(UserService.class);
    bean.insertUser();
    applicationContext.close();
}
```

### 1.2 实现事务

1. 标注`@EnableTransactionManagement`开启基于注解的事务管理功能

   ```java
   @Configuration
   @ComponentScan("com.youyi.boot.tx")
   // 开启基于注解的事务管理
   @EnableTransactionManagement
   public class TxConfig {
   ```

2. 给方法上标注`@Transactional`表示当前方法是一个事务

   ```java
   @Transactional
   public void insertUser() {
       userDao.insert();
       System.out.println("insert finished");
   }
   ```

3. 配置事务管理器来管理事务

   ```java
   // 注册事务管理器在容器中
   @Bean
   public PlatformTransactionManager platformTransactionManager() throws PropertyVetoException {
       return new DataSourceTransactionManager(dataSource());
   }
   ```

### 1.3 实现原理

`@EnableTransactionManagement`导入`TransactionManagementConfigurationSelector`给容器中导入组件：

1. `AutoProxyRegistrar`：给容器中注册`InfrastructureAdvisorAutoProxyCreator`组件
   - `InfrastructureAdvisorAutoProxyCreator`：继承后置处理器，在对象创建后包装对象，返回一个代理对象（增强器），代理对象执行方法，利用拦截器链执行调用

2. `ProxyTransactionManagementConfiguration`：给容器中注册事务增强器

   - 添加一个`AnnotationTransactionAttributeSource`用来解析事务注解

   - 添加一个`TransactionInterceptor`，保存事务属性信息，事务管理器，继承了`MethodInterceptor`

在目标方法执行时，执行拦截器链：

1. 先获取事务相关属性
2. 获取`PlatformTransactionManager`，如果事先没有添加指定任何`TransactionManager`，最终会从容器中按照类型获取一个`PlatfromTransactionManager`
3. 目标方法执行时，如果异常，利用事务管理器回滚操作——最终调用`Connection.rollback()`
4. 如果正常，利用事务管理器提交事务——最终调用`Connection.commit()`

