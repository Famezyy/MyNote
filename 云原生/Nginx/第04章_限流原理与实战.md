# 第04章_限流原理与实战

限流技术用来控制在高并发、大流量的场景中服务接口请求的速率，例如秒杀、抢购等场景。假设某个接口能够扛住的 QPS 为 10000，此时有 20000 个请求进来，经过限流模块，会先放 10000 个请求，其余的请求会阻塞一段时间，不至于返回 404。

## 1.限流策略原理与参考实现

接口限流的算法主要有以下 4 种：

- **计数器**：在一段时间窗口内，处理请求的最大数量固定，超过部分不做处理
- **漏桶**：漏桶大小固定，处理速度固定，但请求进入的速度不固定（请求过多时多余的会被丢弃）
- **令牌桶**：令牌桶大小固定，令牌产生速度固定，但是消耗令牌的速度不固定；每个请求都会从令牌桶中取出令牌，如果没有令牌就丢弃这次请求
- **滑动窗口**：为了解决计数器精度问题，将一段窗口时间划分为更小的单位，每过一个时间单位就将窗口整体向右移动一个单位，每次计算窗口内的最大数量

### 1.1 计数器限流

```java
class CounterLimiter {
    // 起始时间
    private static long startTime = System.currentTimeMillis();
    // 时间窗口的间隔
    private static long interval = 1000;
    // 每秒限制数量
    private static long maxCount = 2;
    // 累加器
    private static AtomicLong accumulator = new AtomicLong();

    // 判断是否超出限制
    public static boolean tryAcquire() {
        long now = System.currentTimeMillis();
        // 还在时间窗口内，判断累加和是否超出限制
        if (now < startTime + interval) {
            long count = accumulator.incrementAndGet();
            if (count <= maxCount)
            	return true;
            else
            	return false;
        }
        // 超过了时间窗口，重新设置起始时间和累加器
        else {
            synchronized (CounterLimiter.class) {
                if (now > startTime + interval) {
                    accumulator.set(0);
                    startTime = now;
                }
            }
            return false;
        }
    }
}
```

下面创建 2 个线程，分别执行 10 次获取操作，每次间隔 200 毫秒，总计运行 2 秒钟：

```java
@Test
void test() {
    ExecutorService pool = Executors.newFixedThreadPool(10);
    CountDownLatch cd = new CountDownLatch(2);
    AtomicInteger count = new AtomicInteger(0);
    Runnable r = () -> {
        for (int i = 0; i < 10; i++) {
            if (CounterLimiter.tryAcquire()) {
                count.incrementAndGet();
            }
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {}
        }
        cd.countDown();
    };
    pool.submit(r);
    pool.submit(r);
    try {
        cd.await();
    } catch (InterruptedException e) {}
    System.out.println("运行时间：2s, 通过总数：" + count.get() + ", 执行总数：20, 通过的比例：" + (float) count.get() / 20);
}
```

结果

```bash
运行时间：2s, 通过总数：4, 执行总数：20, 通过的比例：0.2
```

计算器算法无法解决以下场景问题：如果在前一个时间单位的最后请求数达到最大值 maxCount，并且后一个时间单位的最开始请求数达到最大值 maxCount，此时在这一段时间范围内请求数达到了最大值的两倍 2 * maxCount。

### 1.2 漏桶限流

大致规则如下：

- 请求以任意速率流入漏桶，可以放入桶中则意味着可以接受请求，并不意味着立即处理
- 漏桶的容量固定，出水（处理请求）速率固定
- 如果处理速度太慢，桶内水量（请求数）超过桶的容量，则后面的请求就会溢出，表示拒绝

代码如下：

```java
class LeakBucketLimiter {
    // 漏斗容量
    private int capacity;
    // 等待队列
    private BlockingQueue<Thread> queue;

    public LeakBucketLimiter(int rate, int capacity) {
        this.capacity = capacity;
        this.queue = new ArrayBlockingQueue<>(capacity);
        // 创建一个定时任务，每隔 1000 / rate MS 执行队列头部的任务
        Executors.newScheduledThreadPool(1).scheduleWithFixedDelay(() -> {
            try {
                // take 为阻塞方法
                Thread t = queue.take();
                synchronized (t) {
                    t.notify();
                }
            } catch (InterruptedException e) {}
        }, 0, 1000 / rate, TimeUnit.MILLISECONDS);
    }

    @SneakyThrows
    public boolean tryAcquire() {
	if (queue.size() < capacity) {
	    synchronized (Thread.currentThread()) {
            // 双重判断队列容量小于最大容量
            if (queue.size() < capacity) {
                // 将当前线程放入队列中，并调用 wait 方法使当前线程等待
                queue.add(Thread.currentThread());
                Thread.currentThread().wait();
                return true;
            } else {
                return false;
            }
	    }
	}
	return false;
    }
}
```

漏桶的出水速度固定，因而不能有效应对突发流量，但能起到平滑突发流量的作用。

### 1.3 令牌桶限流

令牌桶算法以一个设定的速率产生令牌并放入令牌桶，每次用户请求都得申请令牌，如果令牌不足就会拒绝请求。令牌的数量也是有上限的，随着流逝的时间越长，会不断往桶里加入越多令牌，如果令牌发放的速度比申请速度快，令牌桶就会放满令牌。

另外，令牌的发放速率可以设置，从而可以对突发流量进行有效的应对。

令牌桶的大致规则如下：

- 进水口按照某个速度向桶中放入令牌
- 令牌的容量固定，但放行的速度不固定，只要桶中还有剩余令牌，请求就能申请成功
- 如果令牌的发放速度慢于申请速度，则桶内无令牌时请求会被拒绝

参考实现如下：

```java
class TokenBucketLimiter {
    // 上次令牌发放时间
    private long lastOutTime;
    // 令牌桶容量
    private int capacity;
    // 令牌发放速率，个/秒
    private int rate;
    // 当前令牌数量
    private int tokens;

    public TokenBucketLimiter(int capacity, int rate) {
        this.lastOutTime = System.currentTimeMillis();
        this.capacity = capacity;
        this.rate = rate;
        this.tokens = capacity;
    }

    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long gap = now - lastOutTime;
        tokens = Math.min(capacity, (int) (tokens + gap * rate / 1000));
        if (tokens >= 1) {
            tokens--;
            lastOutTime = now;
            return true;
        } else {
            return false;
        }
    }
}
```

令牌桶的好处之一就是可以方便地应对突发流量。比如可以改变令牌的发放速度，算法能按照新的发送速率调大令牌的发放数量。

### 1.4 滑动窗口

参考 Sentinel 滑动窗口实现

```java
class LeapArray {
    // 每个窗口长度
    private long windowLengthInMs;
    // 窗口数组
    private AtomicReferenceArray<WindowWrap> array;
    // 重入锁，保证重制窗口时的线程安全
    private ReentrantLock lock = new ReentrantLock();
    // 窗口总长度
    private int intervalInMs;

    /**
     * 
     * @param windowCount:  窗口个数
     * @param intervalInMs: 所有窗口的总长度
     */
    public LeapArray(int windowCount, int intervalInMs) {
        this.windowLengthInMs = intervalInMs / windowCount;
        this.array = new AtomicReferenceArray<>(windowCount);
        this.intervalInMs = intervalInMs;
    }

    /*
     * 获取当前时间窗口
     */ 
    public WindowWrap getCurrentWindow() {
        long now = System.currentTimeMillis();
        // 确定数组下标
        int idx = calculateIndex(now);
        // 判断起始时间
        long windowStart = getWindowStart(now);
        WindowWrap old = array.get(idx);
        while (true) {
            if (old == null) {
            	WindowWrap newWindow = new WindowWrap(windowLengthInMs, windowStart, new LongAdder());
            if (array.compareAndSet(idx, null, newWindow))
                return newWindow;
            else {
                Thread.yield();
            }
            } else if (old.getStartTime() == windowStart) {
            	return old;
            } else if (old.getStartTime() < windowStart) {
            if (lock.tryLock()) {
                try {
                	return resetWindow(old, windowStart);
                } finally {
                	lock.unlock();
                }
            } else {
                Thread.yield();
            }
            } else if (old.getStartTime() > windowStart) {
            	return new WindowWrap(windowLengthInMs, windowStart, new LongAdder());
            }
        }
    }

    /*
     * 重制窗口
     */
    private WindowWrap resetWindow(WindowWrap old, long windowStart) {
        old.setStartTime(windowStart);
        old.getPass().reset();
        return old;
    }

    private long getWindowStart(long now) {
		return now - now % windowLengthInMs;
    }

    private int calculateIndex(long now) {
        long id = now / windowLengthInMs;
        return (int) (id % array.length());
    }

    /*
     * 获取所有有效窗口內的请求数
     */
    public int getReqNum(long now) {
        int ans = 0;
        for (int i = 0; i < array.length(); i++) {
            WindowWrap wrap = array.get(i);
            if (wrap != null && now - wrap.getStartTime() <= intervalInMs) {
                ans += wrap.getPass().sum();
            }
        }
        return ans;
    }
}

/*
 * 滑动窗口的指标操作类
 */
class ArrayMetric {
    private final LeapArray data;
    private final int limit;

    public ArrayMetric(int windowCount, int intervalInMs, int limit) {
        this.data = new LeapArray(windowCount, intervalInMs);
        this.limit = limit;
    }

    private void addPass() {
		data.getCurrentWindow().getPass().add(1L);
    }

    public boolean tryAcquire() {
        if (data.getReqNum(System.currentTimeMillis()) < limit) {
            addPass();
            return true;
        }
        return false;
    }
}

@Data
@AllArgsConstructor
class WindowWrap {
    private long windowLengthInMs;
    private long startTime;
    private LongAdder pass;
}

```

## 2.分布式计数器限流

### 2.1 Nginx Lua分布式计数器限流

本小节以对用户 IP 计数器限流为例实现单 IP 在一定时间周期（如 10 秒）內只能访问一定次数（如 10 次）的限流功能。架构如下：

<img src="img/第04章_限流原理与实战/image-20240115011912357.png" alt="image-20240115011912357" style="zoom:67%;" />

首先是限流计数器脚本 RedisKeyRateLimiter.lua

```lua
local redisOp = require "luaScript.module.demo.RedisOperator"
local _Module = {}

function _Module:new(key)
    local obj = setmetatable({}, _Module)
    self.__index = self
    local red = redisOp:new()
    red:open()
    obj.red = red
    obj.key = "count_rate_limit:" .. key
    return obj;
end

-- 判断是否能通过流量控制，注意这里存在线程安全问题！
function _Module:acquire()
    local current = self.red:incrValue(self.key)
    -- 判断是否大于限制次数
    local isLimited = current and current ~= ngx.null and tonumber(current) > 10
    if isLimited then
        return false
    end

    if not current or current == ngx.null then
        self.red:setValue(self.key, 1)
        -- 限流的时间范围，10 秒
        self.red:expire(self.key, 10)
    end
    return true
end

-- 取得访问次数
function _Module:getCount()
    local current = self.red:getValue(self.key)
    if current and current ~= ngx.null then
        return tonumber(current)
    end
    return 0
end

function _Module:close()
    self.red:close()
end

return _Module
```

接下来是 AccessAuthNginx.lua 脚本，该脚本使用 RedisKeyRateLimiter.lua 完成针对同一 IP 的限流操作：

```lua
local cjson = require "cjson"
local RedisKeyRateLimiter = require "luaScript.module.demo.RedisKeyRateLimiter"
-- 定义出错的 JSON 对象
local errorOut = {resp_code=-1,resp_msg="限流出错",datas={}}
-- 取得用户 ip
local shortKey = ngx.var.remote_addr;
if not shortKey or shortKey == ngx.null then
    errorOut.resp_msg = "ip 不能为空"
    ngx.say(cjson.encode(errorOut))
    return
end

-- 拼接 key
local key = "ip:" .. shortKey
local limiter = RedisKeyRateLimiter:new(key)
local isPassed = limiter:acquire()

-- 如果通过流量控制
if isPassed then
    ngx.var.count = limiter:getCount()
end

limiter:close()

-- 如果没有通过
if not isPassed then
    errorOut.resp_msg = "限流了"
    ngx.say(cjson.encode(errorOut))
end
```

最后是 Nginx 的配置文件

```nginx
location = /access/demo/nginx/lua {
    set $count 0;
    access_by_lua_file luaScript/module/demo/AccessAuthNginx.lua;
    content_by_lua_block {
        ngx.say("当前访问总数：", ngx.var.count)
    }
}
```

上面的代码中设置的限流规则为单 IP 10 秒内限制访问 10 次，因此在浏览器中刷新 10 次后再次访问就会被限流。

以上代码存在两处缺陷：

- 线程安全问题：计数器的读取和自增通过两次 Redis 操作完成，不具备原子性，多线程访问（如设置了多个网关或者设置了 `worker_processes` 大于 1）下会出现线程安全问题
- 性能问题：同一次限流操作需要多次访问 Redis，存在多次网络传输

### 2.2 Redis Lua分布式计数器限流

Redis 允许将 Lua 脚本加载到 Redis 服务器中执行，可以调用大部分 Redis 指令，并且保证了原子性。本小节架构如下：

<img src="img/第04章_限流原理与实战/image-20240115021526919.png" alt="image-20240115021526919" style="zoom:67%;" />

首先是限流的计数器脚本 RedisRateLimiter.lua

```lua
-- 该脚本在 redis 中执行
-- 返回 0 表示拒绝
local cacheKey = KEYS[1]
local data = redis.call("incr", cacheKey)
local count = tonumber(data)
-- 首次访问设置过期时间
if count == 1 then
    redis.call("expire", cacheKey, 10)
end
if count > 10 then
    return 0
end
return count
```

需要将这个脚本加载到 Redis 中，并且获取其加载后的 sha1 编码，以供 Nginx 的脚本使用。加载到 Redis 的 Linux Shell 命令如下：

```bash
redis-cli -a 123456 script load "$(cat /home/RedisRateLimiter.lua)"     
"0adf08f9a10cdb5ba149516b8a03fb14b7663558"
```

然后是 AccessAuthEvalsha.lua

```lua
local redisExecutor = require("luaScript.module.demo.RedisOperator")
local cjson = require "cjson"
local errorOut = { respCode = -1, resp_msg = "限流出错", datas = {} }
-- 取得用户的ip
local shortKey =  ngx.var.remote_addr

-- 没有限流关键字段， 提示错误
if not shortKey or shortKey == ngx.null then
    errorOut.resp_msg = "shortKey 不能为空"
    ngx.say(cjson.encode(errorOut))
    return
end

-- 拼接计数的 redis key
local key = "ip:" .. shortKey

local rateLimiterSha = "0adf08f9a10cdb5ba149516b8a03fb14b7663558"

--创建自定义的redis操作对象
local red = redisExecutor:new()
--打开连接
red:open()
local connection=red:getConnection()

--执行限流的 redis 内部脚本，传入 1 个参数 key
local resp, err = connection:evalsha(rateLimiterSha, 1, key)
--归还连接到连接池
red:close()

--这里要注意判空的方式
if not resp or resp == ngx.null then
    errorOut.resp_msg = err
    ngx.say(cjson.encode(errorOut))
    return
end

local count = tonumber(resp)
-- 如果通过流控
if count == 0 then
    errorOut.resp_msg = "抱歉，被限流了"
    ngx.say(cjson.encode(errorOut))
    return
end

--设置ngx的变量
ngx.var.count = count
-- 注意，在这里直接输出，会导致content 阶段的指令被跳过
-- ngx.say( "目前的访问总数：",count,"<br>");
```

最后是 Nginx 配置文件

```nginx
location = /access/demo/evalsha/lua {
    set $count 0;
    access_by_lua_file luaScript/module/demo/AccessAuthEvalsha.lua;
    content_by_lua_block {
    	ngx.say("目前的访问总数：", ngx.var.count)
    }
}
```

> **扩展：eval()**
>
> redis Eval 命令基本语法如下：
>
> ```bash
> eval script numkeys key [key ...] arg [arg ...] 
> ```
>
> 参数说明：
>
> - `numkeys`：用于指定键名参数的个数
> - `key [key ...]`： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问（KEYS[1] ， KEYS[2] ，以此类推）。
> - `arg [arg ...]`：附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似（ARGV[1] 、 ARGV[2] ，诸如此类）
>
> 返回值为 ture 时会转换为 integer 1，false 时会转换为 `nil`。
>
> 所以可以不把 redis lua 执行脚本部署在 redis 服务器中，可以将其定义在 OpenResty 中：
>
> ```lua
> local resp, err = connection:eval([[
>  local cacheKey = KEYS[1]
>  local data = redis.call("incr", cacheKey)
>  local count = tonumber(data)
>  -- 首次访问设置过期时间
>  if count == 1 then
>      redis.call("expire", cacheKey, 10)
>  end
>  if count > 10 then
>      return 0
>  end
>  return count
>  ]], 1, key)
> ```
>
> redis 中可以直接使用 `cjson` 命令操作 JSON：
>
> ```bash
> 127.0.0.1:6379> eval 'local test = cjson.encode({test=1}) return test' 0
> "{\"test\":1}"
> 127.0.0.1:6379> eval 'local test = cjson.decode("{\"test\":1}") return test.test' 0
> (integer) 1
> ```

## 3.Nginx漏桶限流

### 3.1 入门

使用 Nginx 可以通过配置的方式完成接入层的限流，其 ngx_http_limit_req_module 模块所提供的 `limit_req_zone` 和 `limit_req` 两个指令使用漏桶算法进行限流。其中 `limit_req_zone` 指令用于定义一个限流的具体规则（或计数内存区），`limit_req` 指令应用前者定义的规则完成限流动作。

假定要配置 Nginx 虚拟主机的限流规则为单 IP 限制为每秒 1 次请求，整个应用限制为每秒 10 次请求，具体配置如下：

```nginx
# 第一条规则为 perip，每个相同客户端 IP 的请求限速在 6 次/分钟
limit_req_zone $binary_remote_addr zone=perip:10m rate=6r/m;
# 第二条规则名称为 perserver，同一虚拟主机的请求限速在 10 次/秒
limit_req_zone $server_name zone=perserver:1m rate=10r/s;

server {
    server_name localhost;
    default_type 'text/html';
    charset utf-8;
    
    limit_req zone=perip;
    limit_req zone=perserver;
    
    location /nginx/ratelimit/demo {
        echo "-uri=$uri -remote_addr=$remote_addr" "-server_name=$server_name";
    }
}
```

上面的配置通过 `limit_req_zone` 指令定义了两条限流规则：第一条规则名称为 `perip`，将来自每个相同客户端 IP 的请求限速在 6 次/分钟（1 次/10 秒）；第二条限流规则名称为 `perserver`，用于将同一虚拟主机的请求限速在 10 次/秒。

第一次访问时：

```bash
-uri=/nginx/ratelimit/demo -remote_addr=125.196.194.101 -server_name=localhost
```

10 秒内访问次数超过 1 次后：

```bash
503 Service Temporarily Unavailable
openresty/1.21.4.3
```

### 3.2 指令介绍

`limit_req_zone` 用于定义一个限流的具体规则，`limit_req` 应用前者定义的规则，这两个指令要配合使用。

#### 1.limit_req_zone

用于 `http` 上下文中，语法格式如下：

```nginx
limit_req_zone key zone=name:size rate=rate [sync];
```

- `key`

  一个表达式，其运行时的值将作为流量计数的标识，key 表达式包含变量、文本和它们的组合。例如上面的示例中，`$binary_remote_addr` 和 `$server_name` 为两个 Nginx 变量， `$binary_remote_addr` 为客户端 IP 地址的二进制值，`$server_name` 为虚拟机主机名称。在限流规则应用后，它们的值将作为限流关键字，同一个 key 值会在限流的共享内存区域保存一份请求计数，而 `limit_req_zone` 限流指令所配置的速度限制只会对同一个 key 值发生作用。

- `zone`

  用于定义存储相同 key 值的请求计数的共享内存区域，格式为 `name:size`，`name` 表示共享内存区域的名称，`size` 为共享内存区域的大小。上面的示例中，`perip:10m` 表示一个名字为 `perip`、大小为 10MB 的内存区域。1MD 大约能存储 16000 个 IP 地址，10MB 大约可以存储 16 万个 IP 地址，即可以对 16 万个客户端进行并发限速，当共享内存区域耗尽时，Nginx 会使用 LRU 算法淘汰最长时间为使用的 key 值。

- `rate`

  用于设置最大访问速率，`rate=10r/s` 表示一个 key 值每秒最多能计数的访问数为 10 个，`rate=6r/m` 表示一个 key 值每分钟最多能访问 6 次。由于 Nginx 的漏桶限流算法的时间计算是基于毫秒的，当设置的速度为 6r/m 时，即每 10 秒内单个 IP 只允许通过 1 个请求，从第 11 秒开始才允许通过第二个请求。

`limit_req_zone` 指令只是定义限流的规则和共享内存区域，规则生效需要靠 `limit_req` 指令。

#### 2.limit_req

用于 `http`、`server`、`location` 配置块中，语法格式如下：

```nginx
limit_req zone=name [burst=number1] [nodelay | delay=number2];
```

- `zone`

  指定限流共享内存区域与限流规则指令 `limit_req_zone` 中的 `name` 对应。

- `burst`

  突发属性，表示可以处理的突发请求数量，这个参数设置了一个大小为 `number1` 的爆发缓冲区，当有大量请求过来时，**超过了限流频率的请求**会被先放到爆发缓冲区内，直到爆发缓冲区满后才拒绝。

  该参数的配置使得 Nginx 限流具备一定的突发流量的缓冲能力。但是 `burst` 仅仅是让爆发的请求先放到队里中，然后慢慢处理，其处理速度是由 `limit_req_zone` 规则指令配置的速度决定的，在速率低的情况下，其缓冲效果其实并不太理想。

- `delay=number2 | nodelay`

  配置了 `burst` 后如果想迅速处理爆发的话，可以配置 `nodelay` 参数，队列中的请求会立即处理，同时将队列中的槽位标记为已占用，然后按照给定的 `rate` 释放槽位；如果设置了 `delay=number2` 的话则表示允许突发处理最多 `number1` 个请求，其中前 `number2` 个请求将直接被处理，其他请求会被放进队列中按照指定的速率进行处理，超过 `number1` 的请求将被拒绝，直到队列中有新的槽位。

## 4.实战：分布式令牌桶限流

本小节的限流通过 Lua + Java 完成。首先在 Lua 脚本中完成限流的计算，在 Java 代码中进行组织和调用。

### 4.1 Lua脚本

```lua
-- 申请令牌，-1 表示 fail，1 表示 success
-- @param key: 限流关键字
-- @param apply: 申请的令牌数量
local function acquire(key, apply)
    local times = redis.call('TIME')
    -- times[1]：UNIX 时间戳，秒数
    -- times[2]：微秒数
    -- 转换为毫秒数
    local cur_mill_second = (times[1] * 1000000 + times[2]) / 1000;
    -- redis.call 会抛出异常，导致执行中断；而 redis.pcall 则会忽略异常，返回错误信息。
    local cacheInfo = redis.pcall("HMGET", key, "last_mill_second", "pre_permits", "max_permits", "rate")
    -- 上次申请的时间
    local last_mill_second = cacheInfo[1]
    -- 之前剩余的令牌数
    local pre_permits = tonumber(cacheInfo[2])
    -- 桶的容量
    local max_permits = tonumber(cacheInfo[3])
    -- 令牌的发放速度
    local rate = cacheInfo[4]
    -- 本次可以申请的令牌数
    local cur_permits = max_permits
    
    -- 当字段不存在时该字段会返回 false
    if (type(last_mill_second) ~= 'boolean' and last_mill_second ~= nil) then
        -- 计算新增加的令牌数
        local reverse_permits = math.floor((cur_mill_second - last_mill_second) / 1000 * rate)
        -- 令牌总数
        local expect_cur_permits = reverse_permits + pre_permits
        -- 可以申请的令牌数
        cur_permits = math.min(expect_cur_permits, cur_permits)
    end
    
    local result = -1;
    -- 有足够的令牌
    if (cur_permits - apply >= 0) then
        -- 保存剩余令牌
        redis.pcall("HSET", key, "pre_permits", cur_permits - apply)
        -- 保存时间
        redis.pcall("HSET", key, "last_mill_second", cur_mill_second)
        result = 1
    else
        result = -1
    end
    return result
end

-- 初始化，1 表示 success
-- @param key
-- @param max_permits 桶的容量
-- @param rate 令牌的发放速度
local function init(key, max_permits, rate)
    redis.pcall("HMSET", key, "max_permits", max_permits, "rate", rate, "pre_permits", max_permits)
    return 1;
end

-- 删除限流 key
local function delete(key)
    redis.pcall("DEL", key)
    return 1;
end

local key = KEYS[1]
local method = ARGV[1]
if method == 'acquire' then
    return acquire(key, ARGV[2])
elseif method == 'init' then
    return init(key, ARGV[2], ARGV[3])
elseif method == 'delete' then
    return delete(key)
else
    -- ignore
end
```

### 4.2 Java代码

lua 脚本既可以在 Java 中调用，也可以在 Nginx 中调用。本小节介绍在 Java 中如何调用。

**配置实体类**

```java
@Data
@ConfigurationProperties(prefix = "application.rate.limit.redis")
public class RedisRateLimitProperties {
    private List<RedisRateLimiter.LimiterInfo> limiterInfos;
}
```

**限流类**

```java
@Slf4j
public class RedisRateLimiter implements InitializingBean {

    private static final String RATE_LIMITER_KEY_PREFIX = "rate_limiter:";
    public static final String RATE_LIMITER_LUA_SHA1 = RATE_LIMITER_KEY_PREFIX + "sha1";

    private RedisRateLimitProperties redisRateLimitProperties;

    private RedisTemplate<String, String> redisTemplate;

    // lua 脚本的实例
    private static RedisScript<Long> rateLimiterScript = null;

    private Map<String, LimiterInfo> limiterInfoMap = new ConcurrentHashMap<>();

    public RedisRateLimiter(RedisRateLimitProperties redisRateLimitProperties,
	    RedisTemplate<String, String> redisTemplate) {
	this.redisRateLimitProperties = redisRateLimitProperties;
	this.redisTemplate = redisTemplate;
	try (InputStream in = this.getClass().getClassLoader().getResourceAsStream("script/rate_limiter.lua")) {
	    byte[] bytes = new byte[in.available()];
	    in.read(bytes);
	    String script = new String(bytes, Charset.forName("UTF-8"));
	    rateLimiterScript = new DefaultRedisScript<>(script, Long.class);
	} catch (Exception e) {
	    e.printStackTrace();
	}

    }

    @Builder
    @Data
    public static class LimiterInfo {
	private String key;
	@Builder.Default
	private String type = "default";
	private Integer maxPermits;
	private Integer rate;

	public String fullKey() {
	    return RATE_LIMITER_KEY_PREFIX + type + ":" + key;
	}

	public String cashKey() {
	    return type + ":" + key;
	}
    }

    /**
     * 限流检测：是否超过 redis 计数限制器的限制
     *
     * @param cacheKey 计数器的key
     * @return true 成功获得令牌
     */
    public boolean tryAcquire(String cashKey) {
	if (cashKey == null) {
	    return true;
	}
	if (cashKey.indexOf(":") <= 0) {
	    cashKey = "default:" + cashKey;
	}
	LimiterInfo limiterInfo = limiterInfoMap.get(cashKey);
	if (limiterInfo == null) {
	    return true;
	}
	Long acquire = redisTemplate.execute(rateLimiterScript, Collections.singletonList(limiterInfo.fullKey()),
		"acquire", "1");
	return acquire == 1;
    }

    /**
     * 加载配置文件中的限速配置
     */
    @Override
    public void afterPropertiesSet() throws Exception {

	try {
	    List<LimiterInfo> limiterInfos = redisRateLimitProperties.getLimiterInfos();
	    if (null == limiterInfos) {
		return;
	    }
	    for (LimiterInfo limiterInfo : limiterInfos) {
		initLimitKey(limiterInfo);
	    }
	    log.info("redis rate limit inited !");
	} catch (Exception e) {
	    log.error("redis rate limit  error.....", e);
	}
    }

    /**
     * 创建一个限流的 key
     *
     * @param limiterInfo 限流的类型
     */
    public void initLimitKey(LimiterInfo limiterInfo) {

	if (null == rateLimiterScript) {
	    return;
	}
	String maxPermits = limiterInfo.getMaxPermits().toString();
	String rate = limiterInfo.getRate().toString();

	// 执行redis 脚本
	Long result = redisTemplate.execute(rateLimiterScript, Collections.singletonList(limiterInfo.fullKey()), "init",
		maxPermits, rate);

	limiterInfoMap.put(limiterInfo.cashKey(), limiterInfo);
    }

    /**
     * 创建一个限流的 key
     *
     * @param type       类型
     * @param key        id
     * @param maxPermits 上限
     * @param rate       速度
     */
    public void initLimitKey(String type, String key, Integer maxPermits, Integer rate) {
	LimiterInfo limiterInfo = LimiterInfo.builder().type(type).key(key).maxPermits(maxPermits).rate(rate).build();
	initLimitKey(limiterInfo);
	/**
	 * 缓存秒杀 lua 的 sha 编码，方便在其他地方获取
	 */
	cacheRateLimiterSha1();
    }

    /**
     * 获取 redis lua 脚本的 sha1 编码,并缓存到 redis
     */
    public String cacheRateLimiterSha1() {
	String sha1 = rateLimiterScript.getSha1();
	redisTemplate.opsForValue().set(RATE_LIMITER_LUA_SHA1, sha1);
	return sha1;
    }

}
```

配置类

```java
@Configuration
@EnableConfigurationProperties(RedisRateLimitProperties.class)
public class RedisConfiguration {

    @Bean
    RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {

	RedisSerializer<String> stringRedisSerializer = new StringRedisSerializer();
	// 定义RedisTemplate，并设置连接工程
	RedisTemplate<String, String> redisTemplate = new RedisTemplate<>();
	// key 的序列化采用 StringRedisSerializer
	redisTemplate.setKeySerializer(stringRedisSerializer);
	redisTemplate.setHashKeySerializer(stringRedisSerializer);
	// value 值的序列化采用 GenericJackson2JsonRedisSerializer
    // 注意这里不要使用 jsonSeRializer，否则在判断方法名时会匹配不上！
	redisTemplate.setValueSerializer(stringRedisSerializer);
	redisTemplate.setHashValueSerializer(stringRedisSerializer);
	// 设置连接工厂
	redisTemplate.setConnectionFactory(connectionFactory);
	redisTemplate.setEnableTransactionSupport(false);
	return redisTemplate;
    }

    @Bean
    RedisRateLimiter redisRateLimiter(RedisRateLimitProperties redisRateLimitProperties,
	    RedisTemplate<String, String> redisTemplate) {
	return new RedisRateLimiter(redisRateLimitProperties, redisTemplate);
    }
}
```

**测试类**

将脚本放在 `test/resources` 下并执行测试

```java
@SpringBootTest
@Slf4j
public class RedisRateLimiterTest {

    @Autowired
    RedisRateLimiter redisRateLimiter;

    private ExecutorService pool = Executors.newFixedThreadPool(10);

    @Test
    @SneakyThrows
    public void testRedisRateLimiter() {
	redisRateLimiter.initLimitKey("seckill", "101", 2, 2);
	// 记录限制的次数
	AtomicInteger reject = new AtomicInteger();
	long start = System.currentTimeMillis();
	final int thread = 2;
	final int turns = 20;
	CountDownLatch cd = new CountDownLatch(thread);
	for (int i = 0; i < thread; i++) {
	    pool.submit(() -> {
		try {
		    for (int j = 0; j < turns; j++) {
			boolean tryAcquire = redisRateLimiter.tryAcquire("seckill:101");
			if (!tryAcquire) {
			    reject.getAndIncrement();
			}
			Thread.sleep(200);
		    }
		} catch (Exception e) {
		    e.printStackTrace();
		}
		cd.countDown();
	    });
	}
	cd.await();
	float time = (System.currentTimeMillis() - start) / 1000F;
	log.info("时长: " + time);
	log.info("限制的次数: " + reject.get());
	log.info("通过的次数: " + (thread * turns - reject.get()));
    }
}
```

两条线程各执行 20 次，每次休眠 200 毫秒，总计耗时 4 秒，运行 40 次，得到以下结果：

```bash
[main] INFO 时长: 4.334
[main] INFO 限制的次数: 32
[main] INFO 通过的次数: 8
```

## 5.实战：秒杀

在开发高并发系统时常用的三把利器：**缓存**、**降级**和**限流**。缓存的目的是提升系统访问速度和增大系统能处理的容量；降级是当服务出现问题或者影响到核心流程的性能时需要暂时屏蔽掉服务请求；但是有些场景不能用缓存和降级来解决，例如稀缺资源（秒杀、抢购）、写服务（评论、下单）、频繁的复杂查询（如评论的最后几页），因此需要有一种手段来限制这些场景的并发请求量，即限流。

### 5.1 业务功能和技术难点

#### 1.业务功能

从业务角度来说秒杀非常简单：根据先后顺序下订单减库存，主要有以下特点：

- 秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功，这种场景下需要借助分布式锁等保障数据一致性
- 秒杀时大量用户会在同一时间同时进行桥沟，网站瞬时访问流量激增，此时就需要削峰和限流

从系统角度来说，秒杀系统的业务功能分成两大维度：商户维度和用户维度。

1. **商户维度**

   商户维度主要涉及两个操作：

   - **增加秒杀**

     通过后台的管理控制台界面增加特定商品、特定数量、特定时段的秒杀。

   - **暴露秒杀**

     将符合条件的秒杀暴露给用户，以便互联网用户能参与商品的秒杀。

2. **用户维度**

   用户维度也涉及两个操作：

   - **减库存**

     在减库存时需要考虑如何避免同一用户重复秒杀的行为，而且在多个微服务并发的情况下需要保障库存数据的一致性，避免超卖的情况。

   - **下订单**

     减库存后需要下订单，即在订单表中添加订单记录，记录购买用户的姓名、手机号、购买的商品 ID 等。

#### 2.技术难点

**（1）限流**

需要限制大部分流量而只允许少部分流量进入服务后端。

**（2）分布式缓存**

秒杀系统最大的瓶颈一般都是数据库读写，如果能够把部分数据或业务逻辑转移到分布式缓存，效率就会极大提升。

**（3）可拓展**

秒杀系统的服务节点一定是可以弹性拓展的。如果流量来了就可以按照流量预估进行服务节点的动态增加和摘除。

**（4）超卖或者少买**

如果并发同步处理没有做好，往往会造成多减库存或者少减库存。

**（5）削峰**

限流完成后，对于后端系统而言，秒杀系统仍然会瞬时涌入大量请求，所以在抢购一开始会有很高的瞬间峰值，此时可以通过消息队列异步处理请求，从而平稳流量。

### 5.2 系统架构

#### 1.分层架构

#### 2.限流架构

#### 3.分布式锁架构

#### 4.削峰架构

### 5.3 参考实现

### 5.4 网关实现秒杀限流

### 5.5 Nginx实现秒杀限流