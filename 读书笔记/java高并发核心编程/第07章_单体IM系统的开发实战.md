# 第07章_单体IM系统的开发实战

## 1.自定义Protobuf编解码器

使用 Netty 内置的 Protobuf 编解码器虽然可以解决简单的 Protobuf 协议的传输问题，但是对于复杂的 Head-Content 协议（例如数据包头部存在魔数、版本号字段等）的解析，就需要自定义 Protobuf 编码器和解码器。

数据包中的**魔数**可以理解为通信的口令，如果口令不对，就不是安全的数据包，不符合自定义协议规范。通过魔数检验，服务端能够在第一时间识别出不符合规范的数据包。

### 1.1 自定义Protobuf编码器

继承`MessageToByteEncoder`，实现`encode()`方法，大致过程如下：

- 写入待发送的 Protobuf POJO 实例的二进制字节长度
- 写入其他的字段，如魔数、版本号
- 写入 Protobuf POJO 实例的二进制字节码内容

代码如下：

```java
public class ProtobufEncoder extends MessageToByteEncoder<Msg> {
    @Override
    protected void encode(ChannelHandlerContext ctx, Msg msg, ByteBuf out) throws Exception {
        // 写入魔数
        out.writeShort(ImSystemConstant.MAGIC_CODE);
        // 写入版本
        out.writeShort(ImSystemConstant.VERSION);

        byte[] byteArray = msg.toByteArray();
        int length = byteArray.length;
        // 写入内容长度
        out.writeInt(length);
        // 写入内容
        out.writeBytes(byteArray);
    }
}
```

### 1.2 自定义Protobuf解码器

继承`ByteToMessageDecoder`，实现`decode()`方法，大致过程如下：

- 读取长度，如果长度为数不够就终止读取
- 读取魔数、版本号等其他字段
- 按照净长度读取内容，如果内容的字节数不够，则恢复到之前的起始位置，然后终止读取

代码如下：

```java
public class ProtobufDecoder extends ByteToMessageDecoder {

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        Optional<Msg> objectOpt = decode0(ctx, in);
        if (objectOpt.isPresent())
            out.add(objectOpt.get());
    }

    private Optional<Msg> decode0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        // 判断 header 长度，2（short）+ 2（short）+ 4（int）
        if (in.readableBytes() < 8)
            return Optional.empty();
        // 记录下当前的读指针，用于异常恢复
        in.markReaderIndex();

        // 读取魔数
        short magicCode = in.readShort();
        if (magicCode != ImSystemConstant.MAGIC_CODE)
            throw new Exception("魔数不匹配: " + ctx.channel().remoteAddress());

        // 读取版本
        short version = in.readShort();
        if (version != ImSystemConstant.VERSION)
            throw new Exception("版本不匹配: " + ctx.channel().remoteAddress());

        // 读取内容长度
        int length = in.readInt();
        if (length < 0)
            ctx.close();

        // 如果可读长度小于 header 的长度，则重制读指针，等待下次读取
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return Optional.empty();
        }

        byte[] array = new byte[length];
        in.readBytes(array, 0, length);

        Msg msg = Msg.parseFrom(array);
        return Optional.of(msg);
    }

}
```

### 1.3 Protobuf消息格式的设计

IM 系统设计的消息格式大体可以分为三种类型：请求消息、应答消息、命令消息。每个往来的消息报文基本上会包含一个序列号和一个类型定义，序列号用来唯一区分一个消息，类型用来决定消息的处理方式。

消息格式大致有以下几个参考的原则：

**1.消息类型使用enum定义**

可以定义一个 HeadType 枚举类型，包含系统用到的所有消息类型。

**2.使用一个Protobuf消息结构定义一类消息**

**3.给应答消息加上成功标记和应答序号**

成功标记是一个用于描述应答是否成功的标记，建议使用 bool 类型；应答序号用于当一个请求有多个响应时，则发送端可以为每个响应消息包含一个应答的序号，最后一个响应消息包含一个结束标记。接收端在处理时，根据应答序号和结束标记可以合并所有的响应消息。

**4.编解码从顶层消息开始**

建议定义一个外层的消息，把所有的消息类型全部封装在一起。在通信时可以从外层消息开始编码或解码。

```protobuf
syntax = "proto3";
package com.youyi.zhao.bean.msg;

enum HeadType {
    LOGIN_REQUEST = 0;         // 登录请求
    LOGIN_RESPONSE = 1;        // 登录响应
    LOGOUT_REQUEST = 2;        // 登出请求
    LOGOUT_RESPONSE = 3;       // 登出响应
    HEART_BEAT = 4;            // 心跳请求
    MESSAGE_REQUEST = 5;       // 聊天消息请求
    MESSAGE_RESPONSE = 6;      // 聊天消息响应
    MESSAGE_NOTIFICATION = 7;  // 服务器通知
}

message Message {
    HeadType       type = 1;                  // 通用字段: 消息类型
    uint64         sequence = 2;              // 通用字段：消息序列号
    string         session_id = 3;            // 通用字段：会话 id
    LoginRequest   loginRequest = 4;          // 登录请求
    LoginResponse  loginResponse = 5;         // 登录响应
    MessageRequest  messageRequest = 6;       // IM 消息请求
    MessageResponse  messageResponse = 7;     // IM 消息响应
    MessageNotification  notification = 8;    // 系统通知
    MessageHeartBeat     heartBeat = 9;       // 心跳
}

// LoginRequest 对应的 HeadType 为 LOGIN_REQUEST
// 消息名称去掉下划线，更加符合 Java 的类名规范
message LoginRequest {
    string uid = 1;           // 用户唯一 id
    string deviceId = 2;      // 设备 ID
    string token = 3;         // 用户 token
    uint32 platform = 4;      // 客户端平台 windows、mac、android、ios、web
    string app_version = 5;   // APP 版本号
}

message LoginResponse {
    bool result = 1;    // true 表示发送成功，false 表示发送失败
    uint32 code = 2;    // 错误码
    string info = 3;    // 错误描述
    uint32 expose = 4;  // 错误描述是否提示给用户:1-提示;0-不提示
}

message MessageHeartBeat {
    uint32 seq = 1;
    string uid = 2;
    string json = 3;
}

message MessageRequest {
    uint64 msg_id = 1;
    string from = 2;
    string to = 3;
    uint64 time = 4;
    uint32 msg_type = 5;
    string content = 6;
    string url = 8;
    string property = 9;
    string from_nick = 10;
    string json = 11;
}

message MessageResponse {
    bool result = 1;
    uint32 code = 2;
    string info = 3;
    uint32 expose = 4;
}

message MessageNotification {
    uint64 no_id = 1;
    string json = 2;
    string timestamp = 3;
}
```

## 2.IM的登录流程

单体 IM 系统首先需要登录，登录的流程包括：

- 客户端发送登录数据包
- 服务端进行用户信息验证
- 服务端创建会话
- 服务端返回登录结果的信息给客户端，包括成功标志、Session ID 等。

从细分的角度看，整个登陆/响应的流程大概包含 9 个环节：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302150112236.png" alt="image-20230215011220209" style="zoom:50%;" />

- 客户端收集用户 ID 和密码，需要使用`LoginConsoleCommand`控制台命令类
- 客户端发送 Protobuf 数据包到客户端通道，需要通过`LoginSender`发送器组装 Protobuf 数据包
- 客户端通道将 Protobuf 数据包发送到对端
- 服务器子通道收到 Protobuf 数据包
- 服务端`UserLoginHandler`入站处理器收到登陆消息，交给业务处理器`LoginMsgProcesser`处理异步的业务逻辑
- 服务端`LoginMsgProcesser`处理完异步的业务逻辑，将结果写入用户绑定的子通道
- 服务器子通道将登录响应 Protobuf 数据发送到客户端
- 客户端收到 Protobuf 登录响应数据包
- 客户端`LoginResponseHandler`业务处理器处理登录响应，例如设置登录的状态、保存会话的 Session ID 等。

### 2.1 客户端涉及的主要模块

客户端涉及的主要模块如下：

- ClientCommand 模块：控制台命令收集器
- ProtobufBuilder 模块：构造 Protobuf 数据包
- Sender 模块：数据包发送器
- Handler 模块：服务器响应处理器

上面这些模块都有一个或者多个专门的类来完成对应的工作：

- CommandController 类：属于 ClientCommand 模块，负责收集用户在控制台输入的命令类型，根据相应的类型调节相应的命令处理器，然后收集相应的信息；例如对于登陆命令，则调用 LoginConsoleCommand

- LoginConsoleCommand 类：属于 ClientCommand 模块，负责收集用户在控制台输入的用户 ID 和密码
- LoginMsgBuilder 类：属于 ProtobufBuilder 模块，负责将 User 类组装成 Protobuf 登陆请求数据包
- LoginSender 类：属于 Sender 模块，负责将组装好的 Protobuf 登陆数据包发送到服务端
- LoginResponseHandler 类：属于 Handler 模块，负责处理服务端的登录响应

### 2.2 服务端涉及的主要模块

服务端涉及的主要模块如下：

- Handler 模块：处理客户端请求
- Processer 模块：以异步方式完成请求的业务逻辑处理
- Session 模块：管理用户与通道的绑定关系

类似的，上面的这些模块都有一个或多个专门的类来完成对应的工作：

- UserLoginRequestHandler 类：属于 Handler 模块，负责处理收到的 Protobuf 登录请求包，然后使用 LoginProcesser 类以异步方式进行用户校验
- LoginProcesser 类：属于 Processer 模块，完成服务端的用户校验，再将校验的结果组装成一个登录响应的 Protobuf 数据包写回客户端
- ServerSession 类：属于 Session 模块，如果校验成功，设置相应的会话状态，将会话加入服务端的 SessionMap 映射中

## 3.案例：客户端的登录处理

最开始先给用户展示一个命令菜单，通过 `ClientCommandMenu`菜单展示类打印 4 个选项：

- “1” 对应登录 -- LoginConsoleCommand
- “2” 对应聊天 -- ChatConsoleCommand
- “3” 对应退出 -- LogoutConsoleCommand
- “4” 对应查看全部命令 -- ClientCommandMenu

将这 4 个命令类组合在 CommandClient 客户端类中。

### 3.1 LoginConsoleCommand

负责从控制台收集客户端输入的用户 ID 和密码。

```java
@Data
public class LoginConsoleCommand implements BaseCommand {
    public static final String KEY = "1";
    private String userName;
    private String password;
    
    @Override
    public void exec(Scannel scanner) {
        System.out.println("请输入用户信息（id:password）:");
        String[] info = null;
        while (true) {
            String input = scanner.next();
            info = input.split(":");
            if (info.length != 2)
                System.out.println("请按照（id:password）格式输入: ");
            else
                break;
        }
        username = info[0];
        password = info[1];
    }
}
```

成功获取到用户名和密码后，客户端将其组装成 User POJO 对象，然后通过客户端登录消息发送器 loginSender 向服务端发送登录请求。

```java
public class CommandController {
    
    private boolean connectFlag = false;
	...;
    
    public void commandThreadRunning() throws InterruptedException {
    	Thread.currentThread().setName("命令线程");
        while (true) {
            while (!connectFlag) {
                startConnectServer();
                // 阻塞等待连接创建
                waitCommandThread();
            }
            while (null != session && session.isconnected()) {
                Scanner scanner = new Scanner(System.in);
                clientCommandMemu.exec(scanner);
                String key = clientCommandMenu.getCommandInput();
                BaseCommand command = commandMap.get(key);
            }
            if (null == command) {
                System.out.println("无法识别【" + command + "】指令，请重新输入!");
                continue;
            }
            switch (key) {
                case LoginConsoleCommand.KEY:
                    commmand.exec(scanner);
                    startLogin((LoginConsoleCommand) command);
                    break;
                ...;
            }
        }
    }
    
    // 发送登录请求
    private void startLogin(LoginConsoleCommand command) {
        if (!isConectFlag()) {
            System.out.println("连接异常，请重新连接");
            return;
        }
        User user = new User();
        user.setUid(command.getUserName());
        user.setToken(command.getPassword());
        user.setDevId("1111");
        this.user = user;
        session.setUser(user);
        loginSender.setUser(user);
        loginSender.setSession(session);
        loginSender.sendLoginMsg();
    }
}
```

### 3.2 LoginSender

先生成 Protobuf 登录数据包，然后调用基类 BaseSender 的发送数据方法。

```java
public class LoginSender extends BaseSender {
    public void sendLoginMsg() {
        if (!isConnected()) {
            log.info("还没有建立连接!");
            return;
        }
        log.info("构造登录消息");
        ProtoMsg.Message message = LoginMsgConverter.build(getUser(), getSession());
        log.info("发送登录消息");
        super.sendMsg(message);
    }
}
```

```java
@Data
public abstract class BaseSender {
    private User user;
    private ClientSession session;

    public boolean isConnected() {
        if (null == session) {
            log.info("session is null");
            return false;
        }
        return session.isConnected();
    }

    public boolean isLogin() {
        if (null == session) {
            log.info("session is null");
            return false;
        }

        return session.isLogin();
    }

    // 发送消息
    public void sendMsg(ProtoMsg.Message message) {
        if (null == getSession() || !isConnected()) {
            log.info("连接还没成功");
            return;
        }

        Channel channel = getSession().getChannel();
        ChannelFuture f = channel.writeAndFlush(message);
        f.addListener(new GenericFutureListener<Future<? super Void>>() {
            @Override
            public void operationComplete(Future<? super Void> future)
                    throws Exception {
                if (future.isSuccess()) {
                    sendSucced(message);
                } else {
                    sendfailed(message);
                }
            }
        });
    }
    
    // 子类可以重写回调逻辑
    protected void sendSucced(ProtoMsg.Message message) {
        log.info("发送成功");

    }

    // 子类可以重写回调逻辑
    protected void sendfailed(ProtoMsg.Message message) {
        log.info("发送失败");
    }
}
```

在调用完`writeAndFlush()`后，真正的出站操作肯定还没有执行完成，可能还需要在 EventLoop 的任务队列中排队等待。可以通过给返回值`ChannelFuture`添加一个`GenericFutureListener`监听器的方式来判断`writeAndFlush()`是否已经执行完毕。当监听器的`operationComplete()`方法被回调时，表示`writeAndFlush()`方法执行完毕。

> <b id="扩展1">扩展</b>
>
> 在Netty 中，无论是入站处理还是出站处理都有两大特点：
>
> 1. 同一通道的同一个 Handler 处理器的所有出/入站处理都是串行执行，不同的处理器之间不需要进行线程同步，大大提升 IO 性能。如果在通道加入处理器时为处理器配置了专用的线程组，则可以保证属于同组的所有出/入站处理都是串行的。
>
>    Netty 的线程（Executor）维护了一个任务队列，对所有的处理任务进行排队。当某个出/入站开启时，Netty 会对当前的执行线程进行判断，如果当前线程不是 Handler 的执行线程，则处理暂时不执行，Netty 会为当前处理建立一个新的异步可执行任务，加入 Handler 的执行线程任务队列。
>
>    在初始化通道的 Handler 时，可以为处理器单独设置一个线程：
>
>    ```java
>    EventExecutorGroup threadGroup = new DefaultEventExecutorGroup(32);
>    final OutHandlerDemo handlerA = new OutHandlerDemo();
>    ChannleInitializer i = new ChannelInitializer<EmbeddedChannel>(){
>        protected void initChannel(EmbeddedChannel ch) {
>            ch.pipeline().addLast(threadGroup, handler);
>        }
>    };
>    ```
>
>    如果为处理器设置单独的线程组（EventExecutorGroup）A，则该处理器会被绑定到该组（A）的一个特定线程 Executor B 上，并且 Netty 会保证后续该通道有其他处理器也使用线程组 A 时，这些处理器会绑定到同一个特定线程 Executor B 上。
>
>    如果通道上所有处理器都没有设置线程组，则所有的出/入站处理都在通道的反应器线程上串行执行。
>
>    Netty Executor 线程的任务队列是一个 MPSC 队列（多生产者单消费者）。只有 EventLoop 线程自己是唯一的消费者，它将遍历任务队列，逐个执行任务；同时存在多个生产者，它们的出/入站操作都会作为异步任务加入任务队列。
>
> 2. 在 Netty 中，只有当流水线上所有的出/入站处理器处理完成，整个出/入站操作才真正完成。

### 3.3 ClientSession

ClientSession 包含两个重要信息：User 和 Channel，同时将 ClientSession 绑定到 Channel 上，从而实现 Channel 与 User 的一一对应。

ClientSession 还保存着当前的状态：isConnected 和 isLogin。

```java
@Data
public class ClientSession {

    public static final AttributeKey<ClientSession> SESSION_KEY =   AttributeKey.valueOf("SESSION_KEY");

    /**
     * 用户实现客户端会话管理的核心
     */
    private Channel channel;
    private User user;

    /**
     * 保存登录后的服务端 sessionid
     */
    private String sessionId;

    private boolean isConnected = false;
    private boolean isLogin = false;


    // 绑定通道
    // 连接成功之后
    public ClientSession(Channel channel) {
      // 正向的绑定
      this.channel = channel;
      this.sessionId = UUID.randomUUID().toString();
      // 反向的绑定
      channel.attr(ClientSession.SESSION_KEY).set(this);
    }

    // 登录成功之后,设置 sessionId
    public static void loginSuccess( ChannelHandlerContext ctx, ProtoMsg.Message pkg) {
        Channel channel = ctx.channel();
        ClientSession session = channel.attr(ClientSession.SESSION_KEY).get();
        session.setSessionId(pkg.getSessionId());
        session.setLogin(true);
        log.info("登录成功");
    }

    // 获取 channel
    public static ClientSession getSession(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        ClientSession session = channel.attr(ClientSession.SESSION_KEY).get();
        return session;
    }

    public String getRemoteAddress() {
        return channel.remoteAddress().toString();
    }

    // 写 protobuf 数据帧
    public ChannelFuture witeAndFlush(Object pkg) {
        ChannelFuture f = channel.writeAndFlush(pkg);
        return f;
    }

    public void writeAndClose(Object pkg) {
        ChannelFuture future = channel.writeAndFlush(pkg);
        future.addListener(ChannelFutureListener.CLOSE);
    }

    // 关闭通道
    public void close() {
        isConnected = false;

        ChannelFuture future = channel.close();
        future.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (future.isSuccess()) {
                    log.error("连接顺利断开");
                }
            }
        });
    }

}
```

创建客户端会话是在 Netty 客户端发起连接请求后，增加一个连接建立完成的回调任务：

```java
@Data
public class CommandController {
    GenericFutureListener<ChannelFuture> connectedListener = (ChannelFuture f) ->
    {
        final EventLoop eventLoop = f.channel().eventLoop();
        if (!f.isSuccess()) {
            log.info("连接失败!在10s之后准备尝试重连!");
            eventLoop.schedule(() -> chatNettyClient.doConnect(), 10, TimeUnit.SECONDS);
            connectFlag = false;
        } else {
            connectFlag = true;
            log.info("服务器连接成功!");
            channel = f.channel();
            // 创建会话
            session = new ClientSession(channel);
            session.setConnected(true);
            // 添加一个通道结束的回调任务，用于关闭会话
            channel.closeFuture().addListener(closeListener);
            // 唤醒用户线程
            notifyCommandThread();
        }
    };
    
    GenericFutureListener<ChannelFuture> closeListener = (ChannelFuture f) ->
    {
        log.info(new Date() + ": 连接已经断开……");
        channel = f.channel();
        // 创建会话
        ClientSession session = channel.attr(ClientSession.SESSION_KEY).get();
        session.close();
        // 唤醒用户线程
        notifyCommandThread();
    };
    
    public synchronized void notifyCommandThread() {
        // 唤醒命令收集程
        this.notify();
    }
}
```

### 3.4 LoginResponseHandler

用于对消息类型进行判断：

- 如果消息类型是请求响应消息并且登录成功，则取出绑定的会话，并设置登录成功的状态，然后进行其他客户端业务处理
- 如果不是请求响应消息，则调用父类默认的`channelRead()`入站处理方法，将数据包交给流水线的下一站 Handler 处理

```java
@ChannelHandler.Sharable
public class LoginResponseHandler extends ChannelInboundHandlerAdapter {

    /**
     * 业务逻辑处理
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        // 判断消息实例
        if (null == msg || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }

        // 判断类型
        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        ProtoMsg.HeadType headType = ((ProtoMsg.Message) msg).getType();
        if (!headType.equals(ProtoMsg.HeadType.LOGIN_RESPONSE)) {
            super.channelRead(ctx, msg);
            return;
        }

        // 判断返回是否成功
        ProtoMsg.LoginResponse info = pkg.getLoginResponse();

        ProtoInstant.ResultCodeEnum result =
                ProtoInstant.ResultCodeEnum.values()[info.getCode()];

        if (!result.equals(ProtoInstant.ResultCodeEnum.SUCCESS)) {
            // 登录失败
            log.info(result.getDesc());
        } else {
            // 登录成功
            ClientSession.loginSuccess(ctx, pkg);
            ChannelPipeline p = ctx.pipeline();
            // 移除登录响应处理器
            p.remove(this);
            // 在编码器后面，动态插入心跳处理器
            p.addAfter("encoder", "heartbeat", new heartBeatClientHandler());
            // 再添加一个消息处理器
            p.addAfter("encoder", "chat", new chatMsgHandler());
            heartBeatClientHandler.channelActive(ctx);
        }
    }
}
```

在登录成功后，将该处理器实例从流水线上删除，同时开启心跳处理。

### 3.5 客户端流水线的装配

在客户端流水线上首先需要装配一个 ProtobufDecoder 解码器和一个 ProtobufEncoder 编码器，然后需要装配登录响应处理器 LoginResponseHandler。最后在流水线最后装配一个异常处理器 ExceptionHandler，它是一个入站处理器，用来实现 Netty 异常的处理以及在连接异常中断后进行重连。

```java
public class ChatNettyClient {
    
    private Bootstrap bootstrap;
    private EventLoopGroup group = new NioEventLoopGroup(1);
    
    public void doConnect() {
    	try {
            bootstrap = new Bootstrap();
            bootstrap.group(group);
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
            bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
            bootstrap.remoteAddress(host, port);

            // 设置通道初始化
            bootstrap.handler(
                new ChannelInitializer<SocketChannel>() {
                    public void initChannel(SocketChannel ch) {
                        // 可以使用 CombinedChannelDuplexHandler 组合编解码器
                        ch.pipeline().addLast("decoder", new SimpleProtobufDecoder());
                        ch.pipeline().addLast("encoder", new SimpleProtobufEncoder());
                        // 加入心跳处理器
                        ch.pipeline().addLast(new loginResponseHandler());
                        ch.pipeline().addLast(new exceptionHandler());
                    }
                }
            );
            log.info("客户端开始连接");
            ChannelFuture f = bootstrap.connect();//异步发起连接
            f.addListener(l -> {
                if (l.isSuccess())
                    log.info("客户端连接成功！");
            });
        } catch (Exception e) {
            log.info("客户端连接失败!" + e.getMessage());
        } 
    }
}
```

## 4.案例：服务端的登录响应

服务端的登录处理流程：

1. ProtobufDecoder 将 ByteBuf 解码成 Protobuf 数据包
2. UserLoginRequestHandler 处理 Protobuf 后，启动 LoginProcesser 处理器以异步方式进行登录验证处理
3. LoginProcesser 通过数据库或远程接口完成登录验证，生成相应的登录响应报文，发送给客户端

### 4.1 流水线的装配

首先装配 Protobuf 的编解码器，然后装配 LoginRequestHandler 登录业务处理器，最后添加一个 serverExceptionHandler 异常处理器。

```java
public class ChatServer {
	public void run() {
        //连接监听线程组
        bg = new NioEventLoopGroup(1);
        //传输处理线程组
        wg = new NioEventLoopGroup();

        try {
            //1 设置 reactor 线程
            b.group(bg, wg);
            //2 设置 nio 类型的 channel
            b.channel(NioServerSocketChannel.class);
            //3 设置监听端口
            b.localAddress(new InetSocketAddress(port));
            //4 设置通道选项
            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
            b.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);

            //5 装配流水线
            b.childHandler(new ChannelInitializer<SocketChannel>() {
                //有连接到达时会创建一个 channel
                protected void initChannel(SocketChannel ch) throws Exception {
                    // 管理 pipeline 中的 Handler
                    ch.pipeline().addLast(new SimpleProtobufDecoder());
                    ch.pipeline().addLast(new SimpleProtobufEncoder());
                    // 在流水线中添加 handler 来处理登录，登录后删除
                    // 添加一个名称，用来定位流水线中的位置
                    ch.pipeline().addLast("login", new loginRequestHandler());
                    ch.pipeline().addLast(new serverExceptionHandler());
                }
            });
            // 6 开始绑定 server
            // 通过调用 sync 同步方法阻塞直到绑定成功
            ChannelFuture channelFuture = b.bind().sync();
            log.info("服务启动, 端口 " + channelFuture.channel().localAddress());
            // 7 监听通道关闭事件
            ChannelFuture closeFuture = channelFuture.channel().closeFuture();
            closeFuture.sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 8 优雅关闭 EventLoopGroup，释放掉所有资源包括创建的线程
            wg.shutdownGracefully();
            bg.shutdownGracefully();
        }
    }    
}
```

### 4.2 LoginRequestHandler

用来判断消息类型，如果是登录消息，则创建一个异步线程执行登录的逻辑。

```java
@ChannelHandler.Sharable
public class LoginRequestHandler extends ChannelInboundHandlerAdapter {
	public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        // 如果消息不是 Message 类型则传递给下一站
        if (null == msg  || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }
        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        
        // 取得请求类型
        ProtoMsg.HeadType headType = pkg.getType();
        if (!headType.equals(loginProcesser.type())) {
            super.channelRead(ctx, msg);
            return;
        }

        // 建立一个会话
        ServerSession session = new ServerSession(ctx.channel());
        // 建立异步任务，处理登录的逻辑
        CallbackTaskScheduler.add(new CallbackTask<Boolean>() {
            // 执行 loginProcesser 处理器
            @Override
            public Boolean execute() throws Exception {
                boolean r = loginProcesser.action(session, pkg);
                return r;
            }

            // 异步任务返回
            @Override
            public void onBack(Boolean r) {
                if (r) {
                    // 在登录处理器后面添加处理器
                    ctx.pipeline().addAfter("login", "chat", new chatRedirectHandler());
                    ctx.pipeline().addAfter("login", "heartBeat", new HeartBeatServerHandler());
                    // 移除登录处理器
                    ctx.pipeline().remove("login");
                    log.info("登录成功:" + session.getUser());
                } else {
                    ServerSession.closeSession(ctx);
                    log.info("登录失败:" + session.getUser());
                }
            }
            
            // 异步任务异常
            @Override
            public void onException(Throwable t) {
                ServerSession.closeSession(ctx);
                log.info("登录失败:" + session.getUser());
            }
        });
    }    
}
```

### 4.3 LoginProcesser

用来验证用户的登录信息，如果验证成功，还要将通道与服务端双向绑定，并将服务端会话加入到在线用户列表中。

```java
public class LoginProcesser implements ServerProcesser {
    
    private loginResponceConverter = new loginResponceConverter();

    @Override
    public ProtoMsg.HeadType type() {
        return ProtoMsg.HeadType.LOGIN_REQUEST;
    }

    @Override
    public boolean action(ServerSession session, ProtoMsg.Message proto) {
        // 取出 token 验证
        ProtoMsg.LoginRequest info = proto.getLoginRequest();
        long seqNo = proto.getSequence();
        User user = User.fromMsg(info);

        // 检查用户
        boolean isValidUser = checkUser(user);
        if (!isValidUser) {
            ProtoInstant.ResultCodeEnum resultcode = ProtoInstant.ResultCodeEnum.NO_TOKEN;
            // 构造登录失败的报文
            ProtoMsg.Message response = loginResponceConverter.build(resultcode, seqNo, "-1");
            // 发送登录失败的报文
            session.writeAndFlush(response);
            return false;
        }

        session.setUser(user);
        // 将 session 绑定到 channel（同客户端），并将会话加入会话 map
        session.reverseBind();

        // 登录成功
        ProtoInstant.ResultCodeEnum resultcode = ProtoInstant.ResultCodeEnum.SUCCESS;
        // 构造登录成功的报文
        ProtoMsg.Message response = loginResponceConverter.build(resultcode, seqNo, session.getSessionId());
        // 发送登录成功的报文
        session.writeAndFlush(response);
        return true;
    }

    private boolean checkUser(User user) {
        if (SessionMap.inst().hasLogin(user))
            return false;
        //校验用户,比较耗时的操作,需要 100 ms 以上的时间
        //方法1：调用远程用户 restfull 校验服务
        //方法2：调用数据库接口校验
        return true;
    }
}
```

### 4.4 隔离EventLoop和业务线程

Reactor 线程和业务线程相互隔离在服务端非常重要，例如普通的登录入站处理器基本步骤是：

- 判断消息是否需要处理
- 取得消息判断类型
- 执行业务处理（耗时）
- 将结果写入通道

其中第三步的业务处理非常耗时，而 Netty 内部的 IO 读写操作通常都是毫秒级的，此时如果成千上万的通道复用一个 EventLoop 反应器线程，就会因为耗时的业务处理而阻塞其他子通道。

解决方法就是隔离 EventLoop 线程和业务操作线程，可以开辟一个独立的线程池，负责一个独立的异步任务处理。我们可以使用 Netty 的 EventLoopGroup 线程池，或者自己创建 Java 线程池。

1. **创建 Netty 的 EventLoopGroup 线程池**（见<a href="#扩展1">扩展</a>）

   此时，在同一通道上的所有出入站处理都会绑定在线程池的同一线程上，保障同一通道上的处理是串行执行的，不需要进行同步控制。

   ```java
   EventExecutorGroup threadGroup = new DefaultEventExecutorGroup(32);
   final OutHandlerDemo handlerA = new OutHandlerDemo();
   ChannleInitializer i = new ChannelInitializer<EmbeddedChannel>(){
       protected void initChannel(EmbeddedChannel ch) {
           // 给 handler 绑定一个 threadGroup
           ch.pipeline().addLast(threadGroup, handler);
       }
   };
   ```

2. **创建一个 Java 线程池**

   ```java
   public class FutureTaskSchedule extends Thread {
       private static final ExecutorService POOL = Executors.newFixedThreadPool(10);
       
       public static void add(Runnable executeTask) {
           POOL.submit(executeTask);
       }
   }
   ```

## 5.详解服务器会话Session

session 用来管理通道和用户，同时 session 和 channel 之间是 1 对 1 的关系：既可以通过 session 拿到 channel 将数据包写出到 channel，也可以从 channel 中获取绑定的 session。

### 5.1 通道的容器属性

Netty 中的 Channel 和 HandlerContext 处理器上下文实例有类似于 Map 的容器功能，可以用来存储键值对，Netty 定义了一个类似于 Map 的接口 ——`AttributeMap`，它有且只有一个方法`attr()`，这个方法接受一个`AttributeKey`类型的键，返回一个`Attribute`类型的值。

```java
public interface AttributeMap {
    <T> Attribute<T> attr(AttributeKey<T> key);
}
```

其特点如下：

- `AttributeKey`是一个键的包装类，确保键的唯一性
- `Attribute`是一个值的包装类，可以通过`get`和`set`操作值

`AttributeMap`的实现要求是线程安全的，Netty 提供了默认的实现，可通过 Channel 的`attr()`方法来获取和设置。

```java
// 定义 key
public static final AttributeKey<ServerSession> SESSION_KEY = AttributeKey.valueOf("SESSION_KEY");
// 绑定到通道
channel.attr(SESSION_KEY).set(session);
```

```java
// 获取
Attribute<ServerSession> attrubte = ctx.channel().attr(SESSION_KEY);
ServerSession session = attribute.get();
```

### 5.2 服务端会话

登录成功后，服务端会为每一个新连接通道创建一个`ServerSession`用于保持用户和服务端的会话信息。每个`ServerSession`拥有一个唯一标识`SessionId`。

```java
@Data
public class ServerSession {

    public static final AttributeKey<String> KEY_USER_ID =      AttributeKey.valueOf("key_user_id");

    public static final AttributeKey<ServerSession> SESSION_KEY =    AttributeKey.valueOf("SESSION_KEY");


    /**
     * 用户实现服务端会话管理的核心
     */
    // 通道
    private Channel channel;
    // 用户
    private User user;

    // session 唯一标示
    private final String sessionId;

    // 登录状态
    private boolean isLogin = false;

     public ServerSession(Channel channel) {
        // 完成正向绑定
        this.channel = channel;
        this.sessionId = buildNewSessionId();
    }

    // 反向导航
    public static ServerSession getSession(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        return channel.attr(ServerSession.SESSION_KEY).get();
    }

    // 关闭连接
    // 每个 ctx 对应一个 channel，对应一个 user
    public static void closeSession(ChannelHandlerContext ctx) {
        ServerSession session =
                ctx.channel().attr(ServerSession.SESSION_KEY).get();

        if (null != session && session.isValid()) {
            session.close();
            SessionMap.inst().removeSession(session.getSessionId());
        }
    }

    // 反向绑定，最终和 channel 通道实现双向绑定
    // 顺便加入到会话集合中
    public ServerSession reverseBind() {
        log.info(" ServerSession 绑定会话 " + channel.remoteAddress());
        channel.attr(ServerSession.SESSION_KEY).set(this);
        SessionMap.inst().addSession(this);
        isLogin = true;
        return this;
    }

    public ServerSession unbind() {
        isLogin = false;
        SessionMap.inst().removeSession(getSessionId());
        this.close();
        return this;
    }

    public String getSessionId() {
        return sessionId;
    }

    private static String buildNewSessionId() {
        String uuid = UUID.randomUUID().toString();
        return uuid.replaceAll("-", "");
    }



    public boolean isValid() {
        return getUser() != null ? true : false;
    }

    // 写 Protobuf 数据帧
    public synchronized void writeAndFlush(Object pkg) {
        // 当系统水位过高时，系统应不继续发送消息，防止发送队列积压
        // 写 Protobuf 数据帧

        if (channel.isWritable())
        {
            channel.writeAndFlush(pkg);
        } else {
            log.debug("通道很忙，消息被暂存了");
            // 写入消息暂存的分布式存储，如果 mongo
            // 等 channel 空闲之后，再写出去
        }

    }

    // 关闭连接
    public synchronized void close() {
        ChannelFuture future = channel.close();
        future.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    log.error("CHANNEL_CLOSED error ");
                }
            }
        });
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
        user.setSessionId(sessionId);
    }

}
```

### 5.3 会话管理器

这里使用一个会话容器`SessionMap`负责管理服务端所有的`ServerSession`，内部使用线程安全的`ConcurrentHashMap`保持`sessionId`到`ServerSession`的映射。

```java
@Data
public final class SessionMap {
    private SessionMap() {
    }

    private static SessionMap singleInstance = new SessionMap();

    // 会话集合
    private ConcurrentHashMap<String, ServerSession> map =
            new ConcurrentHashMap<String, ServerSession>();

    public static SessionMap inst() {
        return singleInstance;
    }

    /**
     * 增加 session 对象
     */
    public void addSession(ServerSession s) {
        map.put(s.getSessionId(), s);
        log.info("用户登录:id= " + s.getUser().getUid()
                + "   在线总数: " + map.size());

    }

    /**
     * 获取 session 对象
     */
    public ServerSession getSession(String sessionId) {
        if (map.containsKey(sessionId)) {
            return map.get(sessionId);
        } else {
            return null;
        }
    }

    /**
     * 根据用户 id，获取 session 对象
     */
    public List<ServerSession> getSessionsBy(String userId) {

        List<ServerSession> list = map.values()
                .stream()
                .filter(s -> s.getUser().getUid().equals(userId))
                .collect(Collectors.toList());
        return list;
    }

    /**
     * 删除 session
     */
    public void removeSession(String sessionId) {
        if (!map.containsKey(sessionId)) {
            return;
        }
        ServerSession s = map.get(sessionId);
        map.remove(sessionId);
        Logger.tcfo("用户下线:id= " + s.getUser().getUid()
                + "   在线总数: " + map.size());
    }


    public boolean hasLogin(User user) {
        Iterator<Map.Entry<String, ServerSession>> it =
                map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, ServerSession> next = it.next();
            User u = next.getValue().getUser();
            if (u.getUid().equals(user.getUid())
                    && u.getPlatform().equals(user.getPlatform())) {
                return true;
            }
        }

        return false;
    }
}
```

## 6.案例：点对点单聊

单聊的消息处理流程如下：

- 用户 A 登录成功后，按照单聊的消息格式发送消息

- 服务端收到消息后，根据目标 userId 进行消息转发发送到用户 B 的客户端

  （用户 B 可能登陆了多个会话，所以这里通过 userId 进行转发而不是 sessionId）

- 客户端用户 B 收到消息后在控制台显示

### 6.1 客户端收集聊天内容

聊天消息收集类`ChatConsoleCommand`负责从控制台收集用户输入的聊天信息，代码如下：

```java
@Data
public class ChatConsoleCommand implements BaseCommand {

    private String toUserId;
    private String message;
    public static final String KEY = "2";

    @Override
    public void exec(Scanner scanner) {
        System.out.print("请输入聊天的消息(id:message)：");
        String[] info = null;
        while (true) {
            String input = scanner.next();
            info = input.split(":");
            if (info.length != 2) {
                System.out.println("请输入聊天的消息(id:message):");
            }else {
                break;
            }
        }
        toUserId = info[0];
        message =  info[1];
    }

    @Override
    public String getKey() {
        return KEY;
    }

    @Override
    public String getTip() {
        return "聊天";
    }

}
```

### 6.2 客户端发送数据

`CommandController`调用自己的`startOneChat()`方法进而调用`ChatSender`将聊天信息发出：

```java
public void commandThreadRunning()
        throws InterruptedException {
    Thread.currentThread().setName("命令线程");

    while (true) {
        //建立连接
        while (connectFlag == false) {
           //开始连接
            startConnectServer();
            waitCommandThread();

        }
        //处理命令
        while (null != session ) {

            Scanner scanner = new Scanner(System.in);
            clientCommandMenu.exec(scanner);
            String key = clientCommandMenu.getCommandInput();
            BaseCommand command = commandMap.get(key);

            if (null == command) {
                System.err.println("无法识别[" + command + "]指令，请重新输入!");
                continue;
            }


            switch (key) {
                case ChatConsoleCommand.KEY:
                    command.exec(scanner);
                    startOneChat((ChatConsoleCommand) command);
                    break;
				...;
            }
        }
    }
    
    private void startOneChat(ChatConsoleCommand c) {
        //登录
        if (!isLogin()) {
            log.info("还没有登录，请先登录");
            return;
        }
        chatSender.setSession(session);
        chatSender.setUser(user);
        chatSender.sendChatMsg(c.getToUserId(), c.getMessage());
    }
}
```

### 6.3 ChatRedirectHandler

创建消息转发处理器

```java
@ChannelHandler.Sharable
public class ChatRedirectHandler extends ChannelInboundHandlerAdapter {

    @Autowired
    ChatRedirectProcesser chatRedirectProcesser;

    /**
     * 收到消息
     */
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        // 判断消息实例
        if (null == msg || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }

        // 判断消息类型
        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        ProtoMsg.HeadType headType = ((ProtoMsg.Message) msg).getType();
        if (!headType.equals(chatRedirectProcesser.type())) {
            super.channelRead(ctx, msg);
            return;
        }

        // 反向绑定
        ServerSession session = ctx.channel().attr(ServerSession.SESSION_KEY).get();

        // 判断是否登录
        if (null == session || !session.isLogin()) {
            log.error("用户尚未登录，不能发送消息");
            return;
        }
            // 异步处理 IM 消息转发的逻辑
        FutureTaskScheduler.add(() ->
        {
            chatRedirectProcesser.action(session, pkg);
        });
    }
    
}
```

### 6.4 ChatRedirectProcesser

用来将消息发送到目标用户

```java
public class ChatRedirectProcesser implements ServerProcesser {
    
    @Override
    public ProtoMsg.HeadType type() {
        return ProtoMsg.HeadType.MESSAGE_REQUEST;
    }

    @Override
    public boolean action(ServerSession fromSession, ProtoMsg.Message proto) {
        // 聊天处理
        ProtoMsg.MessageRequest msg = proto.getMessageRequest();
        Logger.tcfo("chatMsg | from="
                + msg.getFrom()
                + " , to=" + msg.getTo()
                + " , content=" + msg.getContent());
        // 获取接收方的 chatID
        String to = msg.getTo();
        // 获取用户已登录的所有会话
        List<ServerSession> toSessions = SessionMap.inst().getSessionsBy(to);
        if (toSessions == null) {
            // 接收方离线
            Logger.tcfo("[" + to + "] 不在线，发送失败!");
        } else {
            toSessions.forEach((session) -> {
                // 将 IM 消息发送到接收方
                session.writeAndFlush(proto);
            });
        }
        return true;
    }

}
```

### 6.5 ChatMsgHandler

客户端的聊天信息处理器

```java
@ChannelHandler.Sharable
public class ChatMsgHandler extends ChannelInboundHandlerAdapter {

    /**
     * 业务逻辑处理
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 判断消息实例
        if (null == msg || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }

        // 判断类型
        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        ProtoMsg.HeadType headType = pkg.getType();
        if (!headType.equals(ProtoMsg.HeadType.MESSAGE_REQUEST)) {
            super.channelRead(ctx, msg);
            return;
        }

        ProtoMsg.MessageRequest req = pkg.getMessageRequest();
        String content = req.getContent();
        String uid = req.getFrom();

        System.out.println(" 收到消息 from uid:" + uid + " -> " + content);
    }

}
```

## 7.详解心跳检测

### 7.1 网络连接的假死现象

**连接假死**：如果底层的 TCP 连接（socket 连接）已经断开，但是服务端并没有正常关闭套接字，即服务端认为这条 TCP 连接仍然是存在的，则该连接处于假死状态。具体表现为：

- 在服务端会有一些处于`TCP_ESTABLISHED`状态的“正常”连接
- 在客户端 TCP 连接已经断开
- 虽然客户端可以进行断线重连，但是上一次的连接状态依然被服务端认为是有效的，资源得不到释放，包括套接字上下文以及接受/发送缓冲区

由于每个连接都会耗费 CPU 和内存资源，因此大量假死的连接会逐渐耗光服务器的资源，使得服务器 IO 处理效率越来越低。

连接假死通常是由以下多个原因造成的：

- 应用程序出现线程堵塞，无法进行数据读写
- 网络相关设备出现故障
- 网络丢包

解决假死的有效手段是客户端定时进行心跳检测、服务端定时进行空闲检测。

### 7.2 服务端的空闲检测

空闲检测就是每隔一段时间检测子通道是否有数据读写，如果有则子通道是正常的，如果没有则判定为假死，关闭子通道释放资源。

服务端可以使用 Netty 自带的`IdleStateHandler`空闲状态处理器实现空闲检测功能，代码如下：

```java
public class HeartBeatServerHandler extends IdleStateHandler {

    private static final int READ_IDLE_GAP = 150;

    public HeartBeatServerHandler() {
        super(
            // 入站空闲时常，如果一段时间内没有数据入站，则判定连接假死
            READ_IDLE_GAP,
            // 出站空闲时常，如果一段时间内没有数据出站，则判定连接假死
            0,
            // 出/入站检测时常，如果一段时间内没有出站或入站，则判定连接假死
            0,
            // 时间单位
            TimeUnit.SECONDS
        );

    }

    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        // 判断消息实例
        if (null == msg || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }

        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        // 判断消息类型
        ProtoMsg.HeadType headType = pkg.getType();
        if (headType.equals(ProtoMsg.HeadType.HEART_BEAT)) {
            // 异步处理，将心跳包直接回复给客户端
            FutureTaskScheduler.add(() -> {
                if (ctx.channel().isActive()) {
                    ctx.writeAndFlush(msg);
                }
            });
        }
		// 最后一定要调用基类的方法，否则 IdleStateHandler 的入站空闲检测会无效！
        super.channelRead(ctx, msg);
    }

    @Override
    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {
        log.info(READ_IDLE_GAP + "秒内未读到数据，关闭连接");
        ServerSession.closeSession(ctx);
    }
}
```

### 7.3 客户端的心跳发送

客户端需要定期发送心跳数据包到服务端，这里定义一个 Handler 定期发送心跳数据包：

```java
@ChannelHandler.Sharable
public class HeartBeatClientHandler extends ChannelInboundHandlerAdapter {
    // 心跳的时间间隔，单位为 s
    private static final int HEARTBEAT_INTERVAL = 50;

    //在 Handler 被加入到 Pipeline 时，开始发送心跳
    @Override
    public void channelActive(ChannelHandlerContext ctx)
            throws Exception {
        ClientSession session = ClientSession.getSession(ctx);
        User user = session.getUser();
        HeartBeatMsgConverter builder = new HeartBeatMsgConverter(user, session);
        ProtoMsg.Message message = builder.build();
        // 发送心跳
        heartBeat(ctx, message);
    }

    // 使用定时器，发送心跳报文
    public void heartBeat(ChannelHandlerContext ctx, ProtoMsg.Message heartbeatMsg) {
        // 调用 NIO 线程的 schedule() 定时调度方法
        ctx.executor().schedule(() -> {
            if (ctx.channel().isActive()) {
                log.info(" 发送 HEART_BEAT 消息 to server");
                ctx.writeAndFlush(heartbeatMsg);
                //递归调用，发送下一次的心跳
                heartBeat(ctx, heartbeatMsg);
            }
        }, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);
    }

    /**
     * 接受到服务器的心跳回写
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 判断消息实例
        if (null == msg || !(msg instanceof ProtoMsg.Message)) {
            super.channelRead(ctx, msg);
            return;
        }

        // 判断类型
        ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
        ProtoMsg.HeadType headType = pkg.getType();
        if (headType.equals(ProtoMsg.HeadType.HEART_BEAT)) {
            log.info(" 收到回写的 HEART_BEAT  消息 from server");
            return;
        } else {
            super.channelRead(ctx, msg);
        }
    }
    
}
```

发送心跳数据的时候，调用了`ctx.ececutor()`获取当前通道绑定的反应器 NIO 线程，然后通过 NIO 线程的`schedule()`方法完成定时调度功能。心跳处理器是在登录成功后，由`LoginResponseHandler`向通道中加入。

客户端的心跳发送间隔要比服务端的空闲检测时间间隔短，可以定义为 1/3，可以有效防止公网偶发的秒级抖动。

这里还可以让`HeartBeatClientHandler`继承`IdleStateHandler`类，使其在完成心跳处理的同时还能和服务器的空闲检测处理器一样在客户端进行空闲检测。当服务端假死的情况下，可以由客户端发起重连。
