# 第07章_单体IM系统的开发实战

## 1.自定义Protobuf编解码器

使用 Netty 内置的 Protobuf 编解码器虽然可以解决简单的 Protobuf 协议的传输问题，但是对于复杂的 Head-Content 协议（例如数据包头部存在魔数、版本号字段等）的解析，就需要自定义 Protobuf 编码器和解码器。

数据包中的**魔数**可以理解为通信的口令，如果口令不对，就不是安全的数据包，不符合自定义协议规范。通过魔数检验，服务端能够在第一时间识别出不符合规范的数据包。

### 1.1 自定义Protobuf编码器

继承`MessageToByteEncoder`，实现`encode()`方法，大致过程如下：

- 写入待发送的 Protobuf POJO 实例的二进制字节长度
- 写入其他的字段，如魔数、版本号
- 写入 Protobuf POJO 实例的二进制字节码内容

代码如下：

```java
public class ProtobufEncoder extends MessageToByteEncoder<Msg> {
    @Override
    protected void encode(ChannelHandlerContext ctx, Msg msg, ByteBuf out) throws Exception {
        // 写入魔数
        out.writeShort(ImSystemConstant.MAGIC_CODE);
        // 写入版本
        out.writeShort(ImSystemConstant.VERSION);

        byte[] byteArray = msg.toByteArray();
        int length = byteArray.length;
        // 写入内容长度
        out.writeInt(length);
        // 写入内容
        out.writeBytes(byteArray);
    }
}
```

### 1.2 自定义Protobuf解码器

继承`ByteToMessageDecoder`，实现`decode()`方法，大致过程如下：

- 读取长度，如果长度为数不够就终止读取
- 读取魔数、版本号等其他字段
- 按照净长度读取内容，如果内容的字节数不够，则恢复到之前的起始位置，然后终止读取

代码如下：

```java
public class ProtobufDecoder extends ByteToMessageDecoder {

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        Optional<Msg> objectOpt = decode0(ctx, in);
        if (objectOpt.isPresent())
            out.add(objectOpt.get());
    }

    private Optional<Msg> decode0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        // 判断 header 长度，2（short）+ 2（short）+ 4（int）
        if (in.readableBytes() < 8)
            return Optional.empty();
        // 记录下当前的读指针，用于异常恢复
        in.markReaderIndex();

        // 读取魔数
        short magicCode = in.readShort();
        if (magicCode != ImSystemConstant.MAGIC_CODE)
            throw new Exception("魔数不匹配: " + ctx.channel().remoteAddress());

        // 读取版本
        short version = in.readShort();
        if (version != ImSystemConstant.VERSION)
            throw new Exception("版本不匹配: " + ctx.channel().remoteAddress());

        // 读取内容长度
        int length = in.readInt();
        if (length < 0)
            ctx.close();

        // 如果可读长度小于 header 的长度，则重制读指针，等待下次读取
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return Optional.empty();
        }

        byte[] array = new byte[length];
        in.readBytes(array, 0, length);

        Msg msg = Msg.parseFrom(array);
        return Optional.of(msg);
    }

}
```

### 1.3 Protobuf消息格式的设计

IM 系统设计的消息格式大体可以分为三种类型：请求消息、应答消息、命令消息。每个往来的消息报文基本上会包含一个序列号和一个类型定义，序列号用来唯一区分一个消息，类型用来决定消息的处理方式。

消息格式大致有以下几个参考的原则：

**1.消息类型使用enum定义**

可以定义一个 HeadType 枚举类型，包含系统用到的所有消息类型。

**2.使用一个Protobuf消息结构定义一类消息**

**3.给应答消息加上成功标记和应答序号**

成功标记是一个用于描述应答是否成功的标记，建议使用 bool 类型；应答序号用于当一个请求有多个响应时，则发送端可以为每个响应消息包含一个应答的序号，最后一个响应消息包含一个结束标记。接收端在处理时，根据应答序号和结束标记可以合并所有的响应消息。

**4.编解码从顶层消息开始**

建议定义一个外层的消息，把所有的消息类型全部封装在一起。在通信时可以从外层消息开始编码或解码。

```protobuf
syntax = "proto3";
package com.youyi.zhao.bean.msg;

enum HeadType {
    LOGIN_REQUEST = 0;         // 登录请求
    LOGIN_RESPONSE = 1;        // 登录响应
    LOGOUT_REQUEST = 2;        // 登出请求
    LOGOUT_RESPONSE = 3;       // 登出响应
    HEART_BEAT = 4;            // 心跳请求
    MESSAGE_REQUEST = 5;       // 聊天消息请求
    MESSAGE_RESPONSE = 6;      // 聊天消息响应
    MESSAGE_NOTIFICATION = 7;  // 服务器通知
}

message Message {
    HeadType       type = 1;                  // 通用字段: 消息类型
    uint64         sequence = 2;              // 通用字段：消息序列号
    string         session_id = 3;            // 通用字段：会话 id
    LoginRequest   loginRequest = 4;          // 登录请求
    LoginResponse  loginResponse = 5;         // 登录响应
    MessageRequest  messageRequest = 6;       // IM 消息请求
    MessageResponse  messageResponse = 7;     // IM 消息响应
    MessageNotification  notification = 8;    // 系统通知
    MessageHeartBeat     heartBeat = 9;       // 心跳
}

// LoginRequest 对应的 HeadType 为 LOGIN_REQUEST
// 消息名称去掉下划线，更加符合 Java 的类名规范
message LoginRequest {
    string uid = 1;           // 用户唯一 id
    string deviceId = 2;      // 设备 ID
    string token = 3;         // 用户 token
    uint32 platform = 4;      // 客户端平台 windows、mac、android、ios、web
    string app_version = 5;   // APP 版本号
}

message LoginResponse {
    bool result = 1;    // true 表示发送成功，false 表示发送失败
    uint32 code = 2;    // 错误码
    string info = 3;    // 错误描述
    uint32 expose = 4;  // 错误描述是否提示给用户:1-提示;0-不提示
}

message MessageHeartBeat {
    uint32 seq = 1;
    string uid = 2;
    string json = 3;
}

message MessageRequest {
    uint64 msg_id = 1;
    string from = 2;
    string to = 3;
    uint64 time = 4;
    uint32 msg_type = 5;
    string content = 6;
    string url = 8;
    string property = 9;
    string from_nick = 10;
    string json = 11;
}

message MessageResponse {
    bool result = 1;
    uint32 code = 2;
    string info = 3;
    uint32 expose = 4;
}

message MessageNotification {
    uint64 no_id = 1;
    string json = 2;
    string timestamp = 3;
}
```

## 2.IM的登录流程

单体 IM 系统首先需要登录，登录的流程包括：

- 客户端发送登录数据包
- 服务端进行用户信息验证
- 服务端创建会话
- 服务端返回登录结果的信息给客户端，包括成功标志、Session ID 等。

从细分的角度看，整个登陆/响应的流程大概包含 9 个环节：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302150112236.png" alt="image-20230215011220209" style="zoom:50%;" />

- 客户端收集用户 ID 和密码，需要使用`LoginConsoleCommand`控制台命令类
- 客户端发送 Protobuf 数据包到客户端通道，需要通过`LoginSender`发送器组装 Protobuf 数据包
- 客户端通道将 Protobuf 数据包发送到对端
- 服务器子通道收到 Protobuf 数据包
- 服务端`UserLoginHandler`入站处理器收到登陆消息，交给业务处理器`LoginMsgProcesser`处理异步的业务逻辑
- 服务端`LoginMsgProcesser`处理完异步的业务逻辑，将结果写入用户绑定的子通道
- 服务器子通道将登录响应 Protobuf 数据发送到客户端
- 客户端收到 Protobuf 登录响应数据包
- 客户端`LoginResponseHandler`业务处理器处理登录响应，例如设置登录的状态、保存会话的 Session ID 等。

### 2.1 客户端涉及的主要模块



### 2.2 服务端涉及的主要模块

## 3.案例：客户端的登录处理

## 4.案例：服务端的登录响应

## 5.详解Session服务器回话

## 6.案例：点对点单聊

## 7.详解心跳检测
