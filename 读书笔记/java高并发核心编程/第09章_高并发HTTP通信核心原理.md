# 第09章_高并发HTTP通信核心原理

HTTP 是应用层协议，是建立在传输层 TCP 基础之上。在通信过程中，TCP 每一次连接的建立与拆除都会经历 3 次握手和 4 次挥手，性能和效率较低。HTTP 一个显著的特点是无状态的，并且最初的设计初衷是用于短连接场景，请求时建立连接、请求完释放连接。这就导致每一次原始 HTTP 协议的传输都需要进行连接的建立和拆除，导致性能较差。

在单个客户端和服务器通信部频繁的场景下，短连接的性能还是很高的。但是随着微服务技术的发展，分布式应用内部会存在大量、高频率的内部 RPC 调用或者 HTTP 通信，如果依然频繁地进行传输层 TCP 连接的建立与拆除，就会拖慢整体的性能，此时就需要用到 **HTTP 连接复用技术**。

在 Java 分布式应用的架构和实现中，涉及 HTTP 连接复用的高并发场景大致有以下几种：

1. **反向代理 Nginx 到 Java Web 应用服务之间的 HTTP 高并发通信**

   传统的 Nginx + Tomcat 架构的 Web 应用一般使用 Tomcat 作为 Web 服务器，在并发访问量上升之后会引入 Nginx 作为接入层反向代理服务器，利用其负载均衡的能力，将请求代理分发到多个上游 Web 服务器。

   一个简单的传统 Nginx + Tomcat 架构如下图所示

   <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252309328.png" alt="image-20230225230948315" style="zoom: 33%;" />

   该架构可以通过 Web 服务器的横向扩展甚至反向代理的分层扩展提高系统并发的能力。

   这种架构中在 Nginx 和 Tomcat 之间进行反向代理请求转发时，对性能和速度的要求是很高的，此时需要 HTTP 下层的 TCP 连接通道具备可复用的能力，以提升响应效率和高并发能力。

2. **微服务网关和微服务 Provider 实例之间的 HTTP 高并发通信**

   一个经典的分布式微服务应用架构如下图所示

   <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252312921.png" alt="image-20230225231209907" style="zoom:50%;" />

   在使用 Nginx + Spring Cloud 微服务架构的应用中，外部接入网关 Nginx 和 内部网关 Zuul（或 Spring Cloud Gateway）之间，以及内部网关与微服务 Provider 实例之间，都存在着 HTTP 请求的反向代理（或者请求转发）的关系，所以要求这些 HTTP 连接传输层的通道具备可复用的能力，以提升效应效率和高并发能力。

3. **分布式微服务 Provider 实例与实例之间 RPC 远程调用的 HTTP 高并发通信**

   <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252317360.png" alt="image-20230225231703343" style="zoom:50%;" />

   在微服务架构中，微服务 Provider 实例之间的 RPC 也是通过 HTTP 完成的，因此要求连接通道具备可复用的能力，以提升效应效率和高并发能力。

4. **Java 通过 HTTP 客户端访问 REST 接口服务的 HTTP 高并发通信**

   在这种场景下，本地 HTTP 客户端和远程 REST 接口服务之间需要进行频繁的 HTTP 通信，要求连接通道具备可复用的能力，以提升效应效率和高并发能力。

除此之外，只要是在进行 HTTP 通信的两端之间通信和交互的频率高，就都需要具备连接复用的能力，都属于需要复用 HTTP 连接的场景。

## 1.详解传输层TCP

TCP/IP 包含了一系列协议，也叫做 TCP/IP 协议族（TCP/IP Protocol Suite，或 TCP/IP Protocols），简称 TCP/IP。TCP/IP 协议族提供了点对点的连接机制，并且将传输数据帧的封装、寻址、传输、路由以及接受方式都予以标准化。

### 1.1 TCP/IP的分层模型

首先介绍一下七层 ISO 模型。国际标准化组织 ISO 为了使网络应用更为普及，推出了 OSI 参考模型，即开放式系统互联（Open System Interconnect）模型，一般称为 **OSI 参考模型**。OSI 参考模型是 ISO 组织在 1985 年发布的网络互联模型，含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了。

OSI 模型定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 模型各层的通信协议大致如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252328349.png" alt="image-20230225232824335" style="zoom:50%;" />

TCP/IP 协议是互联网最基本的协议，在一定程度上参考了七层 ISO 模型，在 TCP/IP 协议中七层被简化为四个层次。TCP/IP 协议与七层 ISO 模型的对应关系大致如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252332896.png" alt="image-20230225233203880" style="zoom:50%;" />

#### 1.TCP/IP协议的应用层

应用层包括所有和应用程序协同工作并利用基础网络交换应用程序的业务数据的协议。应用层协议包括 HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登录）、DNS（域名解析）以及许多其他协议。

#### 2.TCP/IP协议的传输层

传输层的协议解决了端到端可靠性等问题，能确保数据可靠地到达目的地，甚至能保证数据按照正确的顺序到达目的地。传输层的主要功能大致如下：

- 为端到端连接提供传输服务
- 提供流量控制、差量控制、服务质量（Qos，Quality of Service）等管理服务

传输层中主要有两个性质不同的协议：TCP（传输控制协议）和 UDP（用户数据报协议）。

TCP 是一个面向连接的、可靠的传输协议，提供一种可靠的字节流，能保证数据完整、无损并且按序到达。TCP 尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外 TCP 还会尽量将数据按照规定的顺序发送。

UDP 是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按序到达。

总体来说，TCP 传输效率低，但可靠性强；UDP 传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（例如 QQ 聊天）。

#### 3.TCP/IP协议的网络层

网络层的作用是在复杂的网络环境中为要发送的数据包找到一个合适的路径进行传输。简单来说，就是将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址。并且，网络层负责寻找合适的路径到达对方计算机，并把数据帧发送给对方，网络层还可以实现拥塞控制、网际互联等功能。

#### 4.TCP/IP协议的链路层

链路层也称作数据链路层或网络接口层，用来连接处理网络的硬件部分。该层既包括操作系统硬件的设备驱动、NIC（网卡）、光纤等物理可见部分，也包括连接器等一切传输媒介。在这一层中，数据的传输单位为比特。

### 1.2 HTTP报文传输原理

利用 TCP/IP 进行网络通信时，数据包会按照分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。

以一个 HTTP 请求的传输为例，请求从 HTTP 客户端和 HTTP 服务端应用的传输过程大致如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252351736.png" alt="image-20230225235129721" style="zoom:50%;" />

在发送数据的时候需要对数据进行封装，在数据封装时，数据经过每个层都会打上该层特定标识，添加上头部，在接收端每通过一层就删除该层的头部，TCP/IP 协议的数据分装过程大致如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302252352724.png" alt="image-20230225235258707" style="zoom:50%;" />

在传输层封装时，添加的报文首部要存入一个应用程序的标识符，无论是 TCP 还是 UDP 都用一个 16 位的**端口号**来表示不同的应用程序，并且都会将原端口和目的端口存入报文首部中。

在网络层封装时，IP 首部会标识处理数据的**协议类型**，或者说标识出网络层数据帧所携带的上层数据类型（即可以是传输层的协议也可以是网络层的协议，这个过程的目的是为了让网络层能够正确地将数据帧传递到上层协议进行处理），如 TCP、UDP、ICMP、IP、IGMP 等。具体来说，会在 IP 首部存入一个长度为 8 位的数值，称为协议域：1 表示 ICMP 协议、2 表示 IGMP 协议、6 表示 TCP 协议、17 表示 UDP 协议等。IP 首部还会标识发送方地址（源 IP）和接收方地址（目标 IP）。

在链路层封装时，网络接口分别要发送和接收 IP、ARP 和 RARP 等多种不同协议的报文，因此也必须在以太网的帧首部加入某种形式的标识，以指明所处理的协议类型。为此，以太网报文帧的首部也有一个 16 位的类型字段，标识出以太网数据帧所携带的上层数据类型，如 IPv4、ARP、IPV6、PPPoE 等。

总体来说，TCP/IP 分层管理、数据封装和分用的好处是：分层之后若需要改变相关设计，只需替换变动的层，各个层只需要考虑分派给自己的传输任务即可。

TCP/IP 除了与 OSI 在分层模块上的区别外，更重的要区别是：OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发那种程序”。

实际上，在传输过程中，数据报文会在不同的物理网络之间传递。以一个 HTTP 请求的传输为例：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302260012615.png" alt="image-20230226001222601" style="zoom:50%;" />

在不同物理网络之间的传输过程中，网络层会通过路由器对不同网络之间的数据包进行存储、分组转发处理。路由器是一种特殊的用于网络互联的硬件盒，作用是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和 FDDI（光纤分布式数据接口）等。

物理网络之间通过路由器进行互联，可能会存在很多个路由器，但是 TCP 协议栈屏蔽了物理层的复杂性，对于应用层来说无需特别处理。

### 1.3 TCP的报文格式

在 TCP/IP 协议栈中，IP 层只关心如何使数据能够跨越本地网络边界的问题，而不关心数据如何传输。TCP/IP 协议栈配合起来解决数据如何通过许多个点对点通路顺利传输到目的地。一个点对点通路被称为一“跳”（hop），通过 TCP/IP 协议栈，网络成员能够在许多“跳”的基础上建立相互的数据通路。

传输层 TCP 提供了一种面向连接的、可靠的字节流服务，其数据帧格式大致如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262008273.png" alt="image-20230226200809257" style="zoom:50%;" />

- **源端口号**

  源端口号表示报文的发送端口，占 16 位。源端口号和源 IP 地址组合起来可以标识报文的发送地址。

- **目的端口号**

  目的端口号表示报文的接受端口，占 16 位。目的端口号和目的 IP 地址相结合，可以标识报文的接受地址。

  TCP 是在 IP 基础上传输的，TCP 报文中的“源端口号 + 源 IP”与“目的端口号 + 目的 IP”组合起来唯一确定一条 TCP 连接。

- **序号**

  TCP 传输过程中，在发送端发出的字节流中，传输报文中的数据部分的每一个字节都有它的编号。序号（SN）占 32 位，发起方发送数据时，都需要标记序号。

  序号的语义与 SYN 控制标志的值有关。根据控制标志中的 SYN 来表达不同的序号含义：

  - 当 SYN = 1 时，当前为连接建立阶段，序号为初始序号 ISN（Initial Sequence Number），通过算法来随机生成序号
  - 当 SYN = 0 时，在数据传输正式开始时，第一个报文的序号为 ISN + 1，后面的报文序号为前一个报文的 SN 值 + TCP 报文的净荷字节数（不包括 TCP 头）。如果发送端发送的一个 TCP 帧的净荷为 12B，序号为 5，则发送端接着发送下一个数据包时，序号的值应该设置为 5 + 12 = 17

  在数据传输过程中，TCP 通过序号（SN）对上层提供有序的数据流。发送端可以用序号来跟踪发送的数据量；接收端可以用序号识别出重复接收到的 TCP 包，从而丢弃重复包；对于乱序的数据包，接收端也可以依靠序号对其进行排序。

- **确认序号**

  确认序号表示了报文接收端期望接受的字节序列。如果设置了 ACK 控制位，确认序号的值表示下一个准备接收的包的序列码。

  如果发送端发送 3 个净荷为 1000B，起始 SN 序号为 1 的数据包给服务端，服务端每收到一个包之后，需要回复一个 ACK 响应确认数据包给客户端。ACK 响应数据包的 ACK Number 值为“每个客户端包的 SN + 包净荷”。除了表示服务端已经确认收到的字节数，还表示期望接受到的下一个客户端发送包的 SN 序号。

  <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262026125.png" alt="image-20230226202607107" style="zoom:50%;" />

  在TCP协议中，ACK（Acknowledgment）控制位是 TCP 首部中的一个控制位，用于表示确认标志。ACK 控制位用于指示 TCP 报文段中是否携带确认号字段（ACK 字段）。

  - 如果 ACK = 1，说明确认号字段（ACK 字段）是有效的，并且接收方已经成功接收并处理了之前发送方的数据包，因此在确认响应中应该包含确认号字段，以指示下一个期望接收的数据包序列号

  - 如果 ACK = 0，则发送时将不会发送确认响应，即使它已经成功接收并处理了之前的数据包，这种情况通常发生在接收方发送数据包时不需要确认响应的情况下（例如，TCP 连接建立阶段中的 SYN 包）

- **头部长度**

  该字段占用 4 位，用来表示 TCP 报文首部的长度。其值所表示的并不是字节数，而是头部所含有的 32 位的个数（或者倍数），或者 4 字节的倍数，所以 TCP 头部最多可以有 60 字节（4 * (2^4^-1)）。没有任何选项字段的 TCP 头部长度为 20 字节，此时头部长度为 5。

- **保留字段**

  头部长度后面预留的字段长度为 6 位，作为保留字段暂时没有用。

- **控制标志**

  控制标志共 6 位，具体的标志位为 URG、ACK、PSH、RST、SYN、FIN，如下图所示：

  <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262035346.png" alt="image-20230226203546330" style="zoom:50%;" />

- **窗口**

  长度共 16 位，2 个字节，用来进行流量控制。流量控制的单位是字节，这个值是本端期望一次接收的字节数。它的大小会随着数据传输的进行而动态调整，它可以根据网络拥塞的情况来进行自适应调整，以保证数据传输的效率和可靠性。

  > **注意**
  >
  > 在 TCP 数据传输过程中，发送端会将数据分成若干个 TCP 段，每个 TCP 段的大小不会超过 MSS 值，然后发送到接收端。接收端会根据滑动窗口的大小来确认接收到的 TCP 段，并向发送端发送确认信息。通过滑动窗口和 MSS 选项的协同作用，TCP 协议可以控制数据传输的速度和可靠性，以适应不同的网络环境和应用需求。

- **校验和**

  长度共 16 位，2 个字节。对整个 TCP 报文段，即 TCP 头部和 TCP 数据进行校验和计算，接收端用于对收到的数据包进行验证。

- **紧急指针**

  长度共 16 位，2 个字节。是一个偏移量，和 SN 序号值相加表示紧急数据最后一个字节的序号。

以上 10 项是 TCP 报文首部必须的字段，也称固有字段，长度为 20 字节。接下来是 TCP 报文的可选项和填充部分。

- **可选项和填充部分**

  可选项和填充部分的长度为 4n 字节，是根据需要而增加的选项。如果不足 4n 字节，则要加填充位，是的选项长度为 4 字节的整数倍，具体做法是在这个字段中加入额外的零，以确保 TCP 头是 4 字节的整数。

  常见的选项字段是 **MSS**（Maximum Segment Size，最大数据包长度），每个连接方通常都在通信的第一个报文段（SYN 标志为 1 的那个段）中指明这个选项字段，表示当前连接方所能接受的最大报文段的长度。MSS 只能出现在 SYN 报文段中，若一方不接收来自另一方的 MSS 值，则 MSS 就定为 536 字节。一般 MSS 值越大越好，以提高网络的利用率。在 TCP 建立连接时，双方会交换各自的MSS值，并选择较小的值作为双方共同使用的 MSS 值。

  如果一方没有数据要发送，就不会使用可选项和填充部分，比如在处理超时的过程中，会发送不带任何数据的报文段。

总体来说，TCP 的可靠性主要通过以下几点保障：

- **应用数据分割成 TCP 认为最合适发送的数据块**

  这部分是通过 MSS（最大数据包长度）选项来控制的，通常被称为一种协商机制。

- **重传机制**

  设置定时器，等待确认包，如果定时超时还没有收到确认包，则报文重传。

- **对首部和数据进行校验**

- **接收端对收到的数据进行排序，然后交给应用层**

- **接收端丢弃重复的数据**

- **提供流量控制**

  主要通过滑动窗口来实现。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

  接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

### 1.4 TCP的三次握手

通常建立连接的双方由一端监听来自请求方的 TCP（Socket）连接，当服务端监听开始时，必须准备好接受外来的连接，在 Java 中该操作通过创建一个`ServerSocket`服务监听套接字实例来完成。此操作会调用底层操作系统 C 代码中的三个函数`socket()`、`bind()`、`listen()`来完成。开始监听之后，服务端就做好接收外来连接的准备，如果监听到建立新连接的请求，就会开启一个传输套接字，称为**被动打开**（Passive Open）。

服务端代码示例如下：

```java
public class SocketServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(8080);
            // 循环监听等待客户端
            while (true) {
                // 监听到客户端连接，传输套接字被动开启
                Socket socket = serverSocket.accept();
                // 开启线程进行连接的 IO 处理
                ServerThread thread = new ServerThread(socket);
                thread.start();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

客户端发起连接建立时，Java 代码通过创建 Socket 示例调用底层的`connect()`方法，主动打开（Active Open）Socket 连接。套接字监听方在收到请求之后，和发起方之间就会建立一条连接通道（由双方 IP 和双方端口唯一确定）。

客户端代码示例如下：

```java
public class socketClient {
    public static void main(String[] args) throws InterruptedException {
        try {
            Socket socket = new Socket("localhost", 8080);
            // 写入给监听方的输出流
            OutputStream os = socket.getOutputStream();
            // 读取监听方的输入流
            InputStream is = socket.getInputStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

TCP 连接建立时，双方需要经过三次握手，具体过程如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262147415.png" alt="image-20230226214720394" style="zoom:50%;" />

- **第一次握手**

  Client 进入`SYN_SENT`状态，发送一个 SYN 帧来主动打开传输通道，该帧的 SYN 标志位被设置为 1，同时会带上 Client 分配好的 SN 序列号，该 SN 是根据时间产生的一个随机值，通常情况下每间隔 4ms（毫秒）会加 1.除此之外，SYN 帧还会带一个 MSS（最大报文段长度）。

- **第二次握手**

  Server 在收到 SYN 帧后，会进入`SYN_RCVD`状态，同时返回 SYN + ACK 帧给 Client，通知 Client “Server 已经收到 SYN 消息，现在需要进行确认”。Server 发出的 SYN + ACK 帧的 ACK 标志位被设置为 1，确认序号 AN 值被设置为 Client 的 SN + 1；SYN + ACK 帧的 SYN 标志位被设置为 1，SN 值为 Server 生成的 SN 序号。SYN + ACK 帧的 MSS 表示的是 Server 的最大数据块长度。

- **第三次握手**

  Client 在收到 Server 的第二次握手 SYN + ACK 确认帧之后，首先将自己的状态从`SYN_SENT`变成`ESTABLISHED`，表示自己方向的连接通道已经建立成功，Client 可以发送数据给 Server 了。然后，Client 发 ACK 帧给 Server，该 ACK 帧的 ACK 标志位被设置为 1，确认序号 AN 值被设置为 Server 的 SN + 1。还有一种情况，Client 可能会将 ACK 帧的第一帧要发送的数据**合并到一起**发送给 Server。

  > **说明**
  >
  > TCP 协议中的 ACK 帧用于确认接收到的数据，它通常不包含任何数据。然而，在一些情况下，TCP 连接的接收端可能会将 ACK 帧和要发送的数据合并到一起发送给发送端，这种操作被称为 TCP 延迟确认。
  >
  > 当 TCP 接收端接收到一个数据段时，它会向发送端发送一个 ACK 帧以确认接收到的数据。然而，如果接收端在一段时间内没有收到其他数据段，它可能会延迟发送 ACK 帧，将 ACK 帧和自己要发送的数据一起发送给发送端。这种操作可以减少 ACK 帧的数量，从而减少网络传输的负载。
  >
  > 需要注意的是，TCP 延迟确认可能会对实时性要求高的应用程序产生一定的影响。因为延迟确认会导致接收端延迟发送 ACK 帧，从而使得发送端无法立即知道数据是否被成功接收。如果在此期间出现了数据包丢失或损坏等问题，那么发送端可能需要等待一段时间才能检测到问题并进行重传，从而导致通信延迟和效率的降低。并且，如果接收端延迟发送 ACK 帧的时间过长，可能会导致发送端重传的数据过多，从而导致网络传输的负载增加和效率降低。
  >
  > 因此，在实现 TCP 协议时，需要根据具体应用场景和网络环境的要求，选择是否启用 TCP 延迟确认机制。

  Server 在收到 Client 的 ACK 帧之后会从会从`SYN_RCVD`状态进入`ESTABLISHED`状态，至此 Server 方向的通道连接建立成功，TCP 的全双工连接建立完成。
  
  > **说明**
  >
  > - **全双工连接**
  >
  >   在网络通信中，TCP协议就是一种全双工连接的协议。在TCP连接中，通信双方可以同时发送和接收数据，可以进行双向通信。
  >
  > - **半双工连接**
  >
  >   在半双工连接中，通信双方可以进行双向通信，但不能同时发送和接收数据。通信双方必须在通信过程中进行切换，只能有一方发送数据，另一方接收数据，不能同时进行。例如对讲机就是一种典型的半双工连接。
  >
  > - **单工连接**
  >
  >   在单工连接中，通信只能在一个方向上进行，不能进行双向通信。其中一个通信方向被称为发送方，另一个被称为接收方。在单工连接中，只有发送方可以发送数据，接收方只能接收数据。例如广播电台就是一种典型的单工连接。
  >
  > - **异步连接**
  >
  >   在异步连接中，通信双方可以在任意时间点发送和接收数据，不需要按照固定的时序进行。通信双方之间的数据传输是异步的，不需要在通信过程中进行同步。异步连接通常用于异步通知、事件驱动等场景。

Client 和 Server 完成了三次握手后，双方就进入数据传输阶段。数据传输完成后连接将断开，连接的断开过程需要经历四次挥手。

### 1.5 TCP的四次挥手

在 TCP 连接开始断开的过程中，连接的每个端都能独立、主动地发起。具体过程如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262206022.png" alt="image-20230226220612008" style="zoom:50%;" />

- 第一次挥手

  主动断开方（可以是客户端也可以是服务端），向对方发送一个 FIN 结束请求报文，此报文的 FIN 位被设置为 1，并且正确设置 SN 和 AN。发送完成后，主动断开方进入`FIN_WAIT_1`状态，表示主动断开方没有业务数据要发送给对方，准备关闭 Socket 连接了。

- 第二次挥手

  正常情况下，在收到了主动断开方发送的 FIN 断开请求报文后，被动断开方会发送一个 ACK 响应报文，报文的 AN 值为断开请求报文的 SN + 1，该 ACK 确认报文的含义是“我同意你的连接断开请求”。之后，被动断开方就进入了`CLOSE-WAIT`（关闭等待）状态，TCP 服务会通知高层的应用进程，对方向本地方向的连接已经关闭，没有数据要发送了，若本地还要发送数据给对方，对方依然会接收。被动断开方的`CLOSE-WAIT`会持续一段时间直到数据全部发送完毕。

  主动断开方在收到 ACK 报文后，由`FIN_WAIT_1`转换成`FIN_WAIT_2`状态。

- 第三次挥手

  在发送完成 ACK 报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成或者`CLOSE-WAIT`截止后，被动断开方会向主动断开方发送一个 FIN + ACK 结束响应报文，表示被动断开方的数据都发送完了，然后被动断开方进入`LAST_ACK`状态。

- 第四次挥手

  主动断开方收到 FIN + ACK 断开响应报文后，还需要进行最后的确认，向被动断开方发送一个 ACK 确认报文，然后自己就进入`TIME_WAIT`状态，等待超时后最终关闭连接。处于`TIME_WAIT`状态的主动断开方在等待完成 2MSL 的时间后，如果期间没有收到其他报文，则证明对己方已正常关闭，主动断开方的连接最终关闭。

  被动断开方在收到主动断开方的最后 ACK 报文后最终关闭连接，什么也不需要做。

  > **说明**
  >
  > 处于`TIME_WAIT`状态的主动断开方在等待 2MSL 时间后才真正关闭连接通道。2MSL 指 2 倍的 MSL。MSL（Maximum Segment Lifetime）指的是一个 TCP 报文片段在网络中的最大存活时间，当一个 TCP 数据包被发送出去后，如果在 MSL 的时间内没有被确认接收，那么发送方就认为这个数据包已经丢失，并会尝试重新发送。
  >
  > 2MSL 就是一次消息来回（发送和回复）所需的最大时间。如果直到 2MSL 主动断开方都没有再一次收到对方的报文（如 FIN 报文），则可以推断 ACK 已经被对方成功接收。此时，主动断开方将最终结束自己的 TCP 连接。所以，TCP 的`TIME_WAIT`状态也称为 2MSL 等待状态。
  >
  > 有关 MSL 的具体时间长度，在 RFC1122 协议中推荐为 2 分钟，在 SICS（瑞典计算机科学院）开发的一个小型开源的 TCP/IP 协议栈——LwIP 开源协议栈中默认为 1 分钟，在源自 Berkeley 的 TCP 协议栈实现中默认为 30 秒。总体来说，2 MSL 等待状态的时间长度一般维持在 1~4 分钟。

通过三次握手建立连接和四次挥手拆除连接，一次 TCP 的连接建立与拆除至少进行 7 次通信，成本是很高的。

### 1.6 常见问题

**（1）为什么关闭连接时需要四次挥手，而建立连接只要三次握手？**

关闭连接时，被动断开方在收到对方的 FIN 结束请求报文时很可能没有发送完业务数据，并不能立即关闭连接，被动方只能先回复一个 ACK 响应报文，告诉主动断开方：“你发的 FIN 报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正结束，在结束之前，我会发给你 FIN + ACK 报文的，你先等着”。所以，被动断开方的确认报文需要拆成两步，共需要 4 次挥手。

在建立连接时，Server 的应答可以稍微简单一些。当 Server 收到 Client 的 SYN 连接请求报文后，会发送一个 ACK + SYN 报文。其中 ACK 报文表示对请求报文的应答，SYN 报文表示服务端的连接也已经同步开启了，而 ACK 报文和 SYN 报文之间不会有其他报文需要发送，因此可以只发送一次。只需要 3 次握手即可。

**（2）为什么建立连接是三次握手，两次可以吗？**

三次握手完成两个重要功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已经准备好；二是双方完成初始 SN 序列号的协商，双方的 SN 序列号在握手过程中被发送和确认。

如果把三次握手改成两次握手可能发生**死锁**。例如如下的二次握手：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262228131.png" alt="image-20230226222814111" style="zoom:50%;" />

Client 给 Server 发送一个 SYN 请求帧，Server 收到后发送确认应答 SYN + ACK 帧。按照两次握手的协定，Server 认为连接已经成功的建立，可以开始发送数据帧。

在这个过程中，如果确认应答 SYN + ACK 帧在传输中被丢失，Client 没有收到，则 Client 将不知道 Server 是否已经准备好，也不知道 Server 的 SN 序列号，会认为连接还未建立成功，将**忽略 Server 发来的任何数据分组**，一直等待 Server 的 SYN + ACK 确认应答帧。

而 Server 在发出数据帧后，一直没有收到对应的 ACK 确认后就会超时重发，这样就形成了死锁。

**（3）为什么主动断开方在`TIME-WAIT`状态必须等待 2MSL？**

- 为了确保两端都能最终关闭

  假设网络是不可靠的，被动断开方发送 FIN + ACK 报文后，其主动方的 ACK 报文响应有可能丢失，这时的被动断开方处于`LAST-ACK`状态，由于收不到 ACK 确认被动方一直不能正常进入`CLOSED`状态。在这种场景下，被动断开方会超时重发 FIN + ACK 断开响应报文，如果主动断开方在 2MSL 时间内收到这个重传的 FIN + ACK 报文，就会重传一次 ACK 报文，然后再一次启动 2MSL 计时等待，这样就能确保被动断开方能收到 ACK 报文，从而能确保被动方顺利进入`CLOSED`状态。

  反过来说，如果主动断开方在发送完 ACK 响应报文后不进入`TIME_WAIT`状态去等待 2MSL 时间而是立即释放连接，则将无法收到被动方重发的 FIN + ACK 报文，所以就不会再发送 ACK 确认报文，此时处于`LAST_ACK`状态的被动方将无法正常关闭。

- 防止“旧连接已失效的数据报文”出现在新连接中

  主动断开方在发送完最后一个 ACK 报文后再经过 2MSL 才能最终关闭和释放端口。这就意味着相同端口的新 TCP 连接需要在 2MSL 时间之后才能正常建立。2MSL 这段时间内，旧连接所产生的所有数据报文都已经从网络中消失了，从而确保下一个新的连接中不会出现这种旧连接请求报文。

**（4）如果建立了连接但是 Client 端突然出现故障怎么办**

TCP 有一个**保活（keep alive）计时器**，每收到一次 Client 的数据帧后，Server 的保活计时器都会复位。计时器的超时时间通常设置为 2 小时，若 2 小时还没有收到 Client 的任何数据帧，Server 就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没有反应，Server 就认为 Client 出现了故障，接着关闭连接。可以自行调整 TCP 连接的保活参数。

## 2.TCP连接状态的原理与实验

### 2.1 TCP/IP连接的11种状态

可以用**有限状态机**来描述 TCP 建立连接、传输数据和断开连接的过程。有限状态机包含有限个状态，在某一时刻，连接必然处于某一特定状态，当在一个状态下发生特定事件时，连接会进入一个新的状态。

TCP 连接的 11 种状态如下：

1. `LISTEN`

   表示服务端的某个 ServerSocket 监听连接处于监听状态，可以接受客户端的连接。

2. `SYN_SENT`

   当客户端 Socket 连接的底层开始执行`connect()`方法发起连接请求时，本地连接会进入`SYN_SENT`状态，并发送 SYN 报文，并等待服务端发送三次握手中的 SYN + ACK 报文。`SYN_SENT`状态表示客户端连接已发送 SYN 报文。

3. `SYN_RCVD`

   表示服务端 ServerSocket 接收到了来自客户端连接的 SYN 报文。正常情况下，这个状态是 ServerSocket 连接在建立 TCP 连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用`netstat`指令很难看到这种状态，除非故意写一个检测程序，将三次 TCP 握手过程中最后一个 ACK 报文不予发送。当 TCP 连接处于此状态时，再收到客户端的 ACK 报文就会进入`ESTABLISHED`状态。

4. `ESTABLISHED`

   表示 TCP 连接成功建立。

5. `FIN_WAIT_1`

   当连接处于`ESTABLISHED`状态时，想主动关闭连接时，主动断开会调用底层的`close()`方法，要求主动关闭连接，此时主动断开方进入`FIN_WAIT_1`状态。当对方回应 ACK 报文后，主动方进入`FIN_WAIT_2`状态。在实际情况中，无论对方处于何种情况，都应该马上回应 ACK 报文，所以`FIN_WAIT_1`状态一般比较难见到。

6. `FIN_WAIT_2`

   主动断开方处于`FIN_WAIT_1`状态后，如果收到对方的 ACK 报文，主动方会进入`FIN_WAIT_2`状态，此状态下的双向通道处于半连接（半开）状态，即被动断开方还可以传递数据过来，但主动断开方不可再发送数据出去。此状态是没有超时的（不像`TIME_WAIT`），这种状态下如果对方不发送 FIN + ACK 关闭响应，那么`FIN_WAIT_2`状态将一直保持，该连接会一直被占用，资源不会被释放，当这种半连接堆积越来越多时最终导致操作系统崩溃（可利用心跳机制和设置最大连接时间）。

7. `TIME_WAIT`

   该状态表示主动断开方已收到了对方的 FIN + ACK 关闭响应，并发送出 ACK 报文。`TIME_WAIT`状态下的主动方 TCP 连接会等待 2MSL 的时间，然后回到`CLOSED`状态。如果`FIN_WAIT_1`状态下同时收到了对方带 FIN + ACK 关闭响应报文，就可以直接进入`TIME_WAIT`状态而无须经过`FIN_WAIT_2`状态，此时四次挥手就变成了三次挥手。

8. `CLOSING`

   只有当双方几乎在同时发出`close()`双向连接时，才会出现双方同时发送 FIN 报文的情况，这时就会出现`CLOSING`状态，表示双方都正在关闭 SOCKET 连接。这种状态在实际情况中很少见，属于比较罕见的例外状态。正常情况下，当一方发送 FIN 报文后，理论上应该先收到对方的 ACK 报文在收到对方的 FIN + ACK 关闭响应报文，或同时收到。`CLOSING`状态表示一方发送 FIN 报文后并没有收到对方的 ACK 报文，却收到了对方的 FIN 报文。

9. `CLOSE_WAIT`

   表示正在等待关闭。在主动断开方调用`close()`方法关闭一个连接后，主动方会发送 FIN 报文给被动方，被动方在收到之后会回应一个 ACK 报文给主动方，回复完成后，被动方的 TCP 连接进入`CLOSE_WAIT`状态。接下来，被动方需要检查是否还有数据要发送给主动方，如果没有则被动方也可以关闭连接，此时给主动方发送 FIN + ACK 报文，即关闭自己到对方这个方向的连接。

10. `LAST_ACK`

    当被动断开方发送完 FIN + ACK 确认断开后，就处于`LAST_ACK`状态，等待主动断开方的最后一个 ACK 报文。当收到对方的 ACK 报文后，被动关闭方也就可以进入`CLOSED`状态了。

11. `CLOSED`

    关闭状态或者初始状态，表示 TCP 连接是可用的。

### 2.2 netstat查看连接状态

`netstat`是一款命令行工具，用于列出系统中所有 TCP/IP 的连接情况，包括 TCP、UDP 和 UNIX 套接字，而且该工具也能列出处于监听状态的服务端监听套接字，可以用于查看路由表、实际的网络连接甚至每一个网络接口设备的状态信息。

例如，可以使用`netstat -ant`查看当前 Linux 系统中所有的 TCP/IP 网络的连接信息。

```bash
youyi@zhaoyouyideMacBook-Air ~ % netstat -ant
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)    
tcp6       0      0  fe80::747:4233:1.1025  fe80::de17:eb7c:.1038  ESTABLISHED
tcp6       0      0  *.49279                *.*                    LISTEN        
tcp4       0      0  192.168.11.10.55593    172.217.175.110.443    TIME_WAIT 
```

- `Proto`

  表示套集资所使用的协议，比如 TCP、UDP、UDPL、RAW 等。

- `Recv-Q`、`Send-Q`

  分别表示网络接收队列、发送队列中的字节数，其中的字母 Q 是 Queue 的缩写。具体来说，`Recv-Q`表示内核空间的套接字连接接收缓冲区中，还没有被应用程序取走（没有复制到用户控件缓冲区）的字节数，单位字节。`Send-Q`表示套接字连接的发送队列中，对方没有收到的数据或者说没有被对方确认（Ack）的数据，单位字节。

- `State`

  展示条接字连接的状态，对于 TCP 连接将展示 11 种状态中的某种。

`netstat`命令的选项如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302262328614.png" alt="image-20230226232856598" style="zoom:50%;" />

一般情况下，可以使用`netstat -antp`指令查看 TCP 的连接信息，包含进程的 PID 和名称。在实际的连接状态查看过程中，会通过`while`循环查看服务端特定监听端口的所有 TCP 连接：

```bash
while [ 1 -eq 1 ] ; do netstat -antp | grep 18899 ; sleep 2; echo --; done
```

## 3.HTTP长连接原理

HTTP 属于 TCP/IP 模型中的应用层协议，HTTP 长连接和 HTTP 短连接指的是传输层的 TCP 连接是否被多次使用。

### 3.1 HTTP长连接与短连接

### 3.2 不同HTTP版本中的长连接

## 4.服务端HTTP长连接技术

## 5.客户端HTTP长连接结束与实验