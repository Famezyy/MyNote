# 第04章_垃圾收集器

如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java 虚拟机规范》中堆垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。

## 1.经典垃圾收集器

本节主要讨论在 JDK 7 Update 4 之后到 JDK 11 正式发布之前，OracleJDK 中的 HotSpot 虚拟机所包含的全部可用的垃圾收集器。各款经典收集器之间的关系如下图所示，图中展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线就说明它们可以搭配使用。标注 JDK9 则是说该组合在 JDK9 中被取消支持。

<img src="img/第04章_垃圾收集器/image-20231017000200257.png" alt="image-20231017000200257" style="zoom:25%;" />

### 1.1 Serial收集器

Serial 收集器是最基础、历史最悠久的收集器，曾经（JDK 1.3.1 之前）是 HotSpot 虚拟机新生代收集器的唯一选择。这个收集器是一个**单线程**工作的收集器，这并不仅仅是说它只会使用一个处理器或一条收集线程完成垃圾收集工作，更重要的是强调在它进行垃圾收集时必须**暂停其他所有工作线程**（STW）直到收集结束。下图展示了 Serial/Serial Old 收集器的运行过程。

<img src="img/第04章_垃圾收集器/image-20231017001936737.png" alt="image-20231017001936737" style="zoom: 33%;" />

迄今为止，它依然是 **HotSpot 虚拟机运行在客户端模式下的默认新生代收集器**，对于内存资源受限的环境，它是所有收集器中额外内存消耗最少的；对于单核处理器或者处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。在桌面应用场景以及部分微服务应用中，分配给虚拟机管理的内存一般不会特别大，收集几十兆甚至一两百兆的新生代的停顿时间完全可以控制在十几、几十毫秒，最多一百毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说完全可以接受。

### 1.2 ParNew收集器

ParNew 收集器实质上是 **Serial 收集器的多线程并行版本**，除了同时使用多条线程进行垃圾收集外，其余的行为包括 Serial 收集器可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与 Serial 收集器完全一致，在实现上这两种收集器也共用了相当多的代码。ParNew 收集器的工作过程如下图所示。

<img src="img/第04章_垃圾收集器/image-20231017003134421.png" alt="image-20231017003134421" style="zoom:33%;" />

ParNew 收集器除了支持多线程并行收集之外，其他与 Serial 收集器相比没有太多创新，但它却是不少运行在服务端模式下的 HotSpot 虚拟机，尤其是 JDK 7 之前的遗留系统中首选的新生代收集器，其中一个很重要的原因是：**除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作**。



## 2.低延迟垃圾收集器

## 3.选择合适的垃圾收集器

## 4.实战：内存分配与回收策略