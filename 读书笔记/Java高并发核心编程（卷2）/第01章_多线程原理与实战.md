# 第01章_多线程原理与实战

## 1.进程和线程

计算机处理任务的调度单位就是进程和线程。

### 1.1 进程的基本原理

**进程是程序的一次启动执行**，程序就是存放在硬盘中的可执行文件，主要包括代码指令和数据。**一个进程是操作系统将程序装入内存，给程序分配必要的系统资源，并开始运行程序的指令**。同一个程序则可以多次启动，对应多个线程。

在计算机中，CPU 是核心的硬件资源，承担了所有的计算任务；内存资源承担了运行时数据的保存任务；外存资源（硬盘等）承担了数据外部永久存储的任务。其中，计算任务的调度、资源的分配由操作系统来统领。应用程序以进程的形式运行于操作系统之上，享受操作系统提供的服务。

一般来说，一个进程由**程序段**、**数据段**和**进程控制块**三部分组成，大致结构如下：

<img src="img/%E7%AC%AC01%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/image.png" alt="进程的大致结构" style="zoom: 25%;" />

程序段也一般被称为代码段。代码段是进程的程序指令在内存中的位置，包含需要执行的指令集合；数据段是进程的操作数据在内存中的位置，包含需要操作的数据集合；程序控制块包含进程的描述信息和控制信息，是进程存在的唯一标志。

程序控制块（Program Control Block，PCB）主要由四大部分组成：

1. 进程的描述信息
   
   主要包括：进程 ID 和进程名称，进程 ID 是唯一的，代表进程的身份；进程状态，比如运行、就绪、阻塞；进程优先级，是进程调度的重要依据。

2. 进程的调度信息
   
   主要包括：程序起始地址，程序的第一行指令的内存地址；通信信息，进程间通信时的消息队列。

3. 进程的资源信息
   
   主要包括：内存信息，内存占用情况和内存管理所用的数据结构；I/O 设备信息，所用的 I/O 设备编号及相应的数据结构；文件句柄，所打开文件的信息。

4. 进程上下文
   
   主要包括执行时各种 CPU 寄存器的值、当前程序计数器的值以及各种栈的值等，即进程的环境。在操作系统切换进程时，当前进程被迫让出 CPU，当前进程的上下文就保存在 PCB 结构中，供下次恢复运行时使用。

现代操作系统中，进程是并发执行的，任何进程都可以同其他进程一起执行。在进程内部，代码段和数据段有自己的独立地址空间，不同进程的地址空间是相互独立的。

Java 编写的程序都运行在 Java JVM 虚拟机中，每当使用 Java 命令启动一个 Java 应用程序时，就会启动一个 JVM 进程。在这个 JVM 进程内部，所有 Java 程序代码都是以线程来运行的。JVM 找到程序的入口点`main()`方法，然后运行`main()`方法，这样就产生了一个线程，这个线程被称为**主线程**。当`main()`方法结束后主线程运行完成，JVM 进程也随即退出。

### 1.2 线程的基本原理

早期的操作系统中只有进程而没有线程。进程是程序执行和系统进行并发调用的最小单位。随着 CPU 性能的提升，为了充分利用 CPU，同时弥补进程调度过于笨重产生的问题，进程内部演进出了并发调度的诉求，于是就发明了线程。**线程是指"进程代码段"的一次顺序执行流程**。线程是 CPU 调度的最小单位。一个进程可以有一个或多个线程，各个线程之间共享进程的内存空间、系统资源，进程仍然是操作系统资源分配的最小单位。

Java 程序的进程执行过程就是标准的多线程的执行过程。每当使用 Java 命令执行一个 class 类时，实际上就是启动了一个 JVM 进程。理论上，在该进程的内部至少会启动两个线程，一个是 main 线程，另一个是 GC 线程。但是实际上执行一个 Java 程序后启动的线程远远不止 2 个。

一个标准的线程主要由三部分组成，即**线程描述信息**、**程序计数器**和**栈内存**，如下图所示。

<img src="img/%E7%AC%AC01%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/image-1.png" alt="Alt text" style="zoom:25%;" />

在线程的结构中，线程描述信息即线程的基本信息，主要包括：

1. 线程 ID（线程标识符），是线程的唯一标识，同一个进程内不同线程的 ID 不会重叠。
2. 线程名称，如果没有指定则系统自动分配一个。
3. 线程优先级，优先级越高获得 CPU 的执行机会越大。
4. 线程状态，为新建、就绪、运行、阻塞、结束等状态中的一种

而程序计数器负责记录线程下一条指令的代码段内存地址。栈内存则是代码段中局部变量的存储空间，各个线程间独立。在 JDK 8 中，每个线程创建时默认分配 1MB 大小的栈内存。

在 Java 中，执行程序流程的重要单位是"方法"，而栈内存的分配单位是"栈帧"，**方法的每一次执行都需要为其分配一个栈帧，栈帧主要保存该方法中的局部变量、方法的返回地址以及其他方法的相关信息**。当线程的执行流程进入方法时，JVM 就会为方法分配一个对应的栈帧压入栈内存；当线程的执行流程跳出方法时，JVM 就从栈内存弹出该方法的栈帧，此时方法帧的局部变量的内存空间就会被回收。

### 1.3 进程与线程的区别

（1）线程是"进程代码段"的一次顺序执行流程。一个进程由一个或多个线程组成，一个进程至少有一个线程。

（2）线程是 CPU 调度的最小单位，进程是操作系统分配资源的最小单位。线程的划分尺度小于进程，使得多线程程序的并发性高。

（3）线程是出于高并发的调度诉求从进程内部演进而来的。线程的出现既充分发挥了 CPU 的计算性能，又弥补了进程调度过于笨重的问题。

（4）进程之间是相互独立的，但进程内部的各个线程之间并不完全独立。各个线程之间共享进程的方法区内存、堆内存、系统资源（文件句柄、系统信号等）。

（5）切换速度不同，线程上下文切换比进程上下文切换要快得多。所有有时候线程也称为轻量级进程。

## 2.创建线程的4种方法

Java 进程中每一个线程都对应着一个`Thread`实例。线程的描述信息在`Thread`的实例属性中保存，供 JVM 进行线程管理和调度时使用。虽然一个进程有多个线程，但是在一个 CPU 内核上，同一时刻只能有一个线程是正在执行的，该线程也被称作**当前线程**。

### 2.1 Thead类

`Thread`类位于 java.lang 包中，其结构大致如下图所示。

<img src="img/第01章_多线程原理与实战/thread.png" style="zoom: 50%;" />

下面介绍`Thread`类中比较重要的属性和方法：

1. 线程 ID
   
   属性：`private long tid`，用于保存线程的 ID，在进程内唯一。外部通过调用`getId()`方法访问线程 ID。

2. 线程名称
   
   属性：`private String name`，该属性保存一个 Thread 线程实例的名字。可以在创建线程时指定一个名称`Thread(String threadName)`，通过`getName()`和`setName()`来操作，不指定则由 JVM 默认分配一个。

3. 线程优先级
   
   属性：`private int priority`，保存一个`Thread`线程实例的优先级。可通过`getPriority()`和`setPriority()`来操作。Java 线程的最大优先级值为 10，最小值为 1，默认值是 5.这三个优先级值为三个常量值，在`Thread`类中使用类常量定义：

   ```java
   public static final int MIN_PRIORITY = 1;
   public static final int NORM_PRIORITY = 5;
   public static final int MAX_PRIORITY = 10;
   ```

4. 是否为守护线程
   
   守护线程是在进程运行时提供某种后台服务的线程，比如 GC 线程。属性：`private boolean daemon = false`，该属性保存`Thread`线程实例的守护状态，默认为 false，表示是普通的用户线程而不是守护线程。可通过`setDaemon(boolean on)`方法改变线程实例的类型。

5. 线程的状态
   
   属性：`private int threadStatus`，该属性以整数的形式保存线程的状态。执行方法`getState()`可返回当前线程的执行状态，为新建、就绪、运行、阻塞、结束等状态的一种。

   `Thread`的内部静态枚举类`State`用于定义 Java 线程的所有状态，具体如下：

   ```java
   public static enum State {
      NEW, // 新建
      RUNNABLE, // 就绪，运行
      BLOCKED, // 阻塞
      WAITING, // 等待
      TIMED_WAITING, // 计时等待
      TERMINATED; // 结束
   }
   ```

   在 Java 线程的状态中，就绪状态和运行状态在内部使用同一种状态 RUNNABLE 表示。就绪状态表示线程具备运行条件，正等待获取 CPU 时间片；运行状态表示线程已经获取了 CPU 时间片，CPU 正在执行线程代码逻辑。

6. 线程的启动和运行
   
   - `public void start()`：用来启动一个线程，当调用`start()`方法后，JVM 才会开启一个新的线程来执行用户定义的线程代码逻辑，在这个过程中会为相应的线程分配需要的资源。
   - `public void run()`：作为线程代码逻辑的入口方法。`run()`方法不是由用户线程来调用的，当调用`start()`方法启动一个线程后，只要线程获得了 CPU 执行时间，便进入`run()`方法体去执行具体的用户线程代码。

7. 取得当前线程
   
   `public static Thread currentThread()`：用来获取当前线程的`Thread`实例对象。

### 2.2 创建空线程

我们可以通过继承`Thread`类创建一个线程实例。首先演示创建一个空线程：

```java
Thread thread = new Thread();
System.out.println(thread.getName()); // Thread-0
System.out.println(thread.getId()); // 8
System.out.println(thread.getState()); // NEW
System.out.println(thread.getPriority()); // 5
thread.start(); // 启动线程但没有执行任何操作
```
调用`start()`后就会执行`Thread`的`run()`方法，源码为：

```java
public void run() {
   if (this.target != null) {
      this.target.run();
   }
}
```

这里的**target**属性是`Thread`类的一个实例属性，默认为空。

### 2.3 方法一：继承Thread类

创建新线程需要以下两个步骤：

1. 继承`Thread`类，创建新的线程类
2. 重写`run()`方法，将需要并发执行的业务代码写在`run()`方法中

下面是个创建线程的示例：

```java
public class Test {

    static final int MAX_TURN = 5;

    static class DemoThread extends Thread {
        public void run() {
            for (int i = 1; i < MAX_TURN; i++) {
                System.out.println(Thread.currentThread().getName() + "，轮次：" + i);
            }
            System.out.println(Thread.currentThread().getName() + "运行结束。");
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread thread = null;
        for (int i = 0; i < 2; i ++) {
            thread = new DemoThread();
            thread.start();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束。");
    }
}
```

### 2.4 方法二：实现Runnable接口

在`Thread`类的`run()`方法中如果`target`不为空就执行`target`属性的`run()`方法，`target`是`Thread`类的一个属性并且类型是`Runnable`。在创建`Thread`类的时候可以通过构造器为`target`赋值：

1. `public Thread(Runnable target)`
2. `public Thread(Runnable target, String name)`

使用这两个构造器传入`target`执行目标实例就可以直接通过`Thread`的`run()`方法以默认方式实现线程并发。使用这种方法不用继承`Thread`。

`Runnable`接口位于 java.lang 包中，是一个函数式接口：

```java
@FunctionalInterface
public interface Runnable {
   void run();
}
```

实际创建线程时需要以下几个步骤：

1. 定义一个新类实现`Runnable`接口
2. 实现`Runnable`接口的`run()`抽象方法，将线程代码逻辑放在该实现方法中
3. 通过`Thread`类创建线程对象，将`Runnable`实例作为参数传递给`Thread`类的构造器，由构造器将该`Runnable`实例赋值给`target`
4. 调用`Thread`实例的`start()`方法启动线程
5. 线程启动后，线程的`run()`方法将被 JVM 执行，该`run()`方法调用`target`属性的`run()`方法，最终执行用户定义的业务代码逻辑

下面是一个多线程演示实例：

```java
```



## 3.线程的核心原理

## 4.线程的基本操作

## 5.线程池原理与实战

## 6.确定线程池的线程数

## 7.ThreadLocal原理与实战



