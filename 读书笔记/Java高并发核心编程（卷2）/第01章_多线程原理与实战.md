# 第01章_多线程原理与实战

## 1.进程和线程

计算机处理任务的调度单位就是进程和线程。

### 1.1 进程的基本原理

**进程是程序的一次启动执行**，程序就是存放在硬盘中的可执行文件，主要包括代码指令和数据。**一个进程是操作系统将程序装入内存，给程序分配必要的系统资源，并开始运行程序的指令**。同一个程序则可以多次启动，对应多个线程。

在计算机中，CPU 是核心的硬件资源，承担了所有的计算任务；内存资源承担了运行时数据的保存任务；外存资源（硬盘等）承担了数据外部永久存储的任务。其中，计算任务的调度、资源的分配由操作系统来统领。应用程序以进程的形式运行于操作系统之上，享受操作系统提供的服务。

一般来说，一个进程由**程序段**、**数据段**和**进程控制块**三部分组成，大致结构如下：

<img src="img/%E7%AC%AC01%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/image.png" alt="进程的大致结构" style="zoom: 25%;" />

程序段也一般被称为代码段。代码段是进程的程序指令在内存中的位置，包含需要执行的指令集合；数据段是进程的操作数据在内存中的位置，包含需要操作的数据集合；程序控制块包含进程的描述信息和控制信息，是进程存在的唯一标志。

程序控制块（Program Control Block，PCB）主要由四大部分组成：

1. 进程的描述信息
   
   主要包括：进程 ID 和进程名称，进程 ID 是唯一的，代表进程的身份；进程状态，比如运行、就绪、阻塞；进程优先级，是进程调度的重要依据。

2. 进程的调度信息
   
   主要包括：程序起始地址，程序的第一行指令的内存地址；通信信息，进程间通信时的消息队列。

3. 进程的资源信息
   
   主要包括：内存信息，内存占用情况和内存管理所用的数据结构；I/O 设备信息，所用的 I/O 设备编号及相应的数据结构；文件句柄，所打开文件的信息。

4. 进程上下文
   
   主要包括执行时各种 CPU 寄存器的值、当前程序计数器的值以及各种栈的值等，即进程的环境。在操作系统切换进程时，当前进程被迫让出 CPU，当前进程的上下文就保存在 PCB 结构中，供下次恢复运行时使用。

现代操作系统中，进程是并发执行的，任何进程都可以同其他进程一起执行。在进程内部，代码段和数据段有自己的独立地址空间，不同进程的地址空间是相互独立的。

Java 编写的程序都运行在 Java JVM 虚拟机中，每当使用 Java 命令启动一个 Java 应用程序时，就会启动一个 JVM 进程。在这个 JVM 进程内部，所有 Java 程序代码都是以线程来运行的。JVM 找到程序的入口点 `main()` 方法，然后运行 `main()` 方法，这样就产生了一个线程，这个线程被称为**主线程**。当 `main()` 方法结束后主线程运行完成，JVM 进程也随即退出。

### 1.2 线程的基本原理

早期的操作系统中只有进程而没有线程。进程是程序执行和系统进行并发调用的最小单位。随着 CPU 性能的提升，为了充分利用 CPU，同时弥补进程调度过于笨重产生的问题，进程内部演进出了并发调度的诉求，于是就发明了线程。**线程是指"进程代码段"的一次顺序执行流程**。线程是 CPU 调度的最小单位。一个进程可以有一个或多个线程，各个线程之间共享进程的内存空间、系统资源，进程仍然是操作系统资源分配的最小单位。

Java 程序的进程执行过程就是标准的多线程的执行过程。每当使用 Java 命令执行一个 class 类时，实际上就是启动了一个 JVM 进程。理论上，在该进程的内部至少会启动两个线程，一个是 main 线程，另一个是 GC 线程。但是实际上执行一个 Java 程序后启动的线程远远不止 2 个。

一个标准的线程主要由三部分组成，即**线程描述信息**、**程序计数器**和**栈内存**，如下图所示。

<img src="img/%E7%AC%AC01%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/image-1.png" alt="Alt text" style="zoom:25%;" />

在线程的结构中，线程描述信息即线程的基本信息，主要包括：

1. 线程 ID（线程标识符），是线程的唯一标识，同一个进程内不同线程的 ID 不会重叠。
2. 线程名称，如果没有指定则系统自动分配一个。
3. 线程优先级，优先级越高获得 CPU 的执行机会越大。
4. 线程状态，为新建、就绪、运行、阻塞、结束等状态中的一种

而程序计数器负责记录线程下一条指令的代码段内存地址。栈内存则是代码段中局部变量的存储空间，各个线程间独立。在 JDK 8 中，每个线程创建时默认分配 1MB 大小的栈内存。

在 Java 中，执行程序流程的重要单位是"方法"，而栈内存的分配单位是"栈帧"，**方法的每一次执行都需要为其分配一个栈帧，栈帧主要保存该方法中的局部变量、方法的返回地址以及其他方法的相关信息**。当线程的执行流程进入方法时，JVM 就会为方法分配一个对应的栈帧压入栈内存；当线程的执行流程跳出方法时，JVM 就从栈内存弹出该方法的栈帧，此时方法帧的局部变量的内存空间就会被回收。

### 1.3 进程与线程的区别

（1）线程是"进程代码段"的一次顺序执行流程。一个进程由一个或多个线程组成，一个进程至少有一个线程。

（2）线程是 CPU 调度的最小单位，进程是操作系统分配资源的最小单位。线程的划分尺度小于进程，使得多线程程序的并发性高。

（3）线程是出于高并发的调度诉求从进程内部演进而来的。线程的出现既充分发挥了 CPU 的计算性能，又弥补了进程调度过于笨重的问题。

（4）进程之间是相互独立的，但进程内部的各个线程之间并不完全独立。各个线程之间共享进程的方法区内存、堆内存、系统资源（文件句柄、系统信号等）。

（5）切换速度不同，线程上下文切换比进程上下文切换要快得多。所有有时候线程也称为轻量级进程。

## 2.创建线程的4种方法

Java 进程中每一个线程都对应着一个 `Thread` 实例。线程的描述信息在 `Thread` 的实例属性中保存，供 JVM 进行线程管理和调度时使用。虽然一个进程有多个线程，但是在一个 CPU 内核上，同一时刻只能有一个线程是正在执行的，该线程也被称作**当前线程**。

### 2.1 Thead类

`Thread` 类位于 java.lang 包中，其结构大致如下图所示。

<img src="img/第01章_多线程原理与实战/thread.png" style="zoom: 50%;" />

下面介绍 `Thread` 类中比较重要的属性和方法：

1. 线程 ID
   
   属性：`private long tid`，用于保存线程的 ID，在进程内唯一。外部通过调用`getId()`方法访问线程 ID。

2. 线程名称
   
   属性：`private String name`，该属性保存一个 Thread 线程实例的名字。可以在创建线程时指定一个名称 `Thread(String threadName)`，通过 `getName()` 和 `setName()` 来操作，不指定则由 JVM 默认分配一个。

3. 线程优先级
   
   属性：`private int priority`，保存一个 `Thread` 线程实例的优先级。可通过 `getPriority()` 和 `setPriority()` 来操作。Java 线程的最大优先级值为 10，最小值为 1，默认值是 5.这三个优先级值为三个常量值，在 `Thread` 类中使用类常量定义：

   ```java
   public static final int MIN_PRIORITY = 1;
   public static final int NORM_PRIORITY = 5;
   public static final int MAX_PRIORITY = 10;
   ```

4. 是否为守护线程
   
   守护线程是在进程运行时提供某种后台服务的线程，比如 GC 线程。属性：`private boolean daemon = false`，该属性保存 `Thread` 线程实例的守护状态，默认为 false，表示是普通的用户线程而不是守护线程。可通过 `setDaemon(boolean on)` 方法改变线程实例的类型。

5. 线程的状态
   
   属性：`private int threadStatus`，该属性以整数的形式保存线程的状态。执行方法 `getState()` 可返回当前线程的执行状态，为新建、就绪、运行、阻塞、结束等状态的一种。

   `Thread` 的内部静态枚举类 `State` 用于定义 Java 线程的所有状态，具体如下：

   ```java
   public static enum State {
      NEW, // 新建
      RUNNABLE, // 就绪，运行
      BLOCKED, // 阻塞
      WAITING, // 等待
      TIMED_WAITING, // 计时等待
      TERMINATED; // 结束
   }
   ```

   在 Java 线程的状态中，就绪状态和运行状态在内部使用同一种状态 RUNNABLE 表示。就绪状态表示线程具备运行条件，正等待获取 CPU 时间片；运行状态表示线程已经获取了 CPU 时间片，CPU 正在执行线程代码逻辑。

6. 线程的启动和运行
   
   - `public void start()`：用来启动一个线程，当调用 `start()` 方法后，JVM 才会开启一个新的线程来执行用户定义的线程代码逻辑，在这个过程中会为相应的线程分配需要的资源。
   - `public void run()`：作为线程代码逻辑的入口方法。`run()` 方法不是由用户线程来调用的，当调用 `start()` 方法启动一个线程后，只要线程获得了 CPU 执行时间，便进入 `run()` 方法体去执行具体的用户线程代码。

7. 取得当前线程
   
   `public static Thread currentThread()`：用来获取当前线程的 `Thread` 实例对象。

### 2.2 创建空线程

我们可以通过继承 `Thread` 类创建一个线程实例。首先演示创建一个空线程：

```java
Thread thread = new Thread();
System.out.println(thread.getName()); // Thread-0
System.out.println(thread.getId()); // 8
System.out.println(thread.getState()); // NEW
System.out.println(thread.getPriority()); // 5
thread.start(); // 启动线程但没有执行任何操作
```
调用 `start()` 后就会执行 `Thread` 的 `run()` 方法，源码为：

```java
public void run() {
   if (this.target != null) {
      this.target.run();
   }
}
```

这里的 **target** 属性是 `Thread` 类的一个实例属性，默认为空。

### 2.3 方法一：继承Thread类

创建新线程需要以下两个步骤：

1. 继承 `Thread` 类，创建新的线程类
2. 重写 `run()` 方法，将需要并发执行的业务代码写在 `run()` 方法中

下面是个创建线程的示例：

```java
public class CreateDemo1 {

    static final int MAX_TURN = 5;

    static class DemoThread extends Thread {
        public void run() {
            for (int i = 1; i < MAX_TURN; i++) {
                System.out.println(getName() + "，轮次：" + i);
            }
            System.out.println(getName() + "运行结束。");
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread = null;
        for (int i = 0; i < 2; i ++) {
            thread = new DemoThread();
            thread.start();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束。");
    }
}
```

### 2.4 方法二：实现Runnable接口

在 `Thread` 类的 `run()` 方法中如果 `target` 不为空就执行 `target` 属性的 `run()` 方法，`target` 是 `Thread` 类的一个属性并且类型是 `Runnable`。在创建 `Thread` 类的时候可以通过构造器为 `target` 赋值：

1. `public Thread(Runnable target)`
2. `public Thread(Runnable target, String name)`

使用这两个构造器传入 `target` 执行目标实例就可以直接通过 `Thread` 的 `run()` 方法以默认方式实现线程并发。使用这种方法不用继承 `Thread`。

`Runnable `接口位于 java.lang 包中，是一个函数式接口：

```java
@FunctionalInterface

public interface Runnable {
   void run();
}
```

实际创建线程时需要以下几个步骤：

1. 定义一个新类实现 `Runnable` 接口

2. 实现 `Runnable` 接口的 `run()` 抽象方法，将线程代码逻辑放在该实现方法中

3. 通过 `Thread` 类创建线程对象，将 `Runnable` 实例作为参数传递给`Thread` 类的构造器，由构造器将该 `Runnable` 实例赋值给 `target`

   可以调用的构造器方法有三个：

   - `public Thread(Runnable target)`
   - `public Thread(Runnable target, String name)`
   - `public Thread(ThreadGroup group, Runnable target)`

4. 调用 `Thread` 实例的 `start()` 方法启动线程

5. 线程启动后，线程的 `run()` 方法将被 JVM 执行，该 `run()` 方法调用 `target` 属性的 `run()` 方法，最终执行用户定义的业务代码逻辑

下面是一个多线程演示实例：

```java
public class CreateDemo2 {

    public static final int MAX_TURN = 5;
    static int threadNo = 1;

    static class RunTarget implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < threadNo; i++) {
                // 因为不是继承的 Thread，这里无法直接调用 getName() 方法
                System.out.println(Thread.currentThread().getName() + "，轮次：" + i);
            }
            System.out.println(Thread.currentThread().getName() + "运行结束。");
        }
    }

    public static void main(String[] args) {
        Thread thread = null;
        for (int i = 0; i < 2; i++) {
            Runnable target = new RunTarget();
            thread = new Thread(target, "RunnableThread" + threadNo++);
            thread.start();
        }
    }
}
```

#### 1.创建Runnable线程目标类的两种方式

使用 `Runnable` 创建线程目标类除了直接实现 `Runnable` 接口外，还有两种创建方式：

1. **通过匿名类创建**

   ```java
   // 修改上节的代码
   thread = new Thread(new Runnable(){
       @Override
       public void run() {
           for (int i = 0; i < threadNo; i++) {
           	System.out.println(Thread.currentThread().getName() + "，轮次：" + i);
       }
       	System.out.println(Thread.currentThread().getName() + "运行结束。");
       }
   }, "RunnableThread" + threadNo++);
   thread.start();
   ```

2. **使用 `Lambda` 表达式创建**

   由于 `Runnable` 是一个函数式接口（有且仅有一个抽象方法），在接口实现时可以使用 `Lambda` 表达式提供匿名实现：

   ```java
   thread = new Thread(() -> {
       for (int i = 0; i < threadNo; i++) {
           System.out.println(Thread.currentThread().getName() + "，轮次：" + i);
       }
       System.out.println(Thread.currentThread().getName() + "运行结束。");
   }, "RunnableThread" + threadNo++);
   ```

#### 2.优点

**（1）避免 Java 单继承带来的局限性**

**（2）逻辑和数据更好分离**

通过实现 `Runnable` 接口的方式创建线程目标类更加适合多个线程去共享计算和处理同一个资源的场景，例如下面的例子。

```java
public class SalesDemo {

    // 商品数量
    public static final int MAX_AMOUNT = 5;

    // 商店商品类，一个商品一个销售线程
    static class StoreGoods extends Thread {

        StoreGoods(String name) {
            super(name);
        }

        private int goodsAmount = MAX_AMOUNT;

        @Override
        public void run() {
            for (int i = 0; i < MAX_AMOUNT; i++) {
                if (this.goodsAmount > 0) {
                    System.out.println(getName() + "卖出一件，还剩：" + --goodsAmount);
                    // omit try-catch
                    Thread.sleep(10);
                }
            }
            System.out.println(getName() + "运行结束.");
        }
    }

    // 商场商品类，可以多人销售一个商品
    static class MallGoods implements Runnable {

        // 使用原子类保证线程安全
        private AtomicInteger goodsAmount = new AtomicInteger(MAX_AMOUNT);

        @Override
        public void run() {
            for (int i = 0; i < MAX_AMOUNT; i++) {
                if (this.goodsAmount.get() > 0) {
                    System.out.println(Thread.currentThread().getName() + "卖出一件，还剩：" + goodsAmount.decrementAndGet());
                    // omit try-catch
                    Thread.sleep(10);
                }
            }
            System.out.println(Thread.currentThread().getName() + "运行结束.");
        }
    }

    public static void main(String args[]) throws InterruptedException {
        System.out.println("===商店销售的版本===");
        for (int i = 1; i <= 2; i++) {
            Thread thread = new StoreGoods("店员-" + i);
            thread.start();
        }
        Thread.sleep(1000);
        System.out.println("===商场销售的版本===");
        MallGoods mallGoods = new MallGoods();
        for (int i = 1; i <= 2; i++) {
            Thread thread = new Thread(mallGoods, "商场销售员-" + i);
            thread.start();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束.");
    }
}
```

结果：

```bash
===商店销售的版本===
店员-2卖出一件，还剩：4
店员-1卖出一件，还剩：4
店员-2卖出一件，还剩：3
店员-1卖出一件，还剩：3
店员-2卖出一件，还剩：2
店员-1卖出一件，还剩：2
店员-1卖出一件，还剩：1
店员-2卖出一件，还剩：1
店员-2卖出一件，还剩：0
店员-1卖出一件，还剩：0
店员-2运行结束.
店员-1运行结束.
===商场销售的版本===
商场销售员-1卖出一件，还剩：4
商场销售员-2卖出一件，还剩：3
main运行结束.
商场销售员-2卖出一件，还剩：2
商场销售员-1卖出一件，还剩：1
商场销售员-1卖出一件，还剩：0
商场销售员-2运行结束.
商场销售员-1运行结束.
```

上面的例子中，`StoreGoods` 继承了 `Thread` 类，创建的每个 `StoreGoods` 类都维护有一个单独的商品数量，互相之间没有联系；而 `MallGoods` 类只创建了一次，创建线程时将其传入，相当于所有线程都共享了一个商品数量，即共享了一个 `Runnable` 实例。

通过对比可以看出：

1. 继承 `Thread` 类实现多线程可以更好地分离各个线程
2. 实现 `Runnable` 接口实现多线程能更好地做到多个线程并发地完成同一个任务，但需要注意对于共享资源使用**原子类型数据**保证线程安全

总之，在大多数情况下更推荐实现 `Runnable` 接口创建执行任务。

### 2.5 方法三：使用Callable和FutureTask

前面介绍的 `Thread` 类和 `Runnable` 接口方式无法获取异步执行的任务，因为 `run()` 没有返回值。因此 Java 在 1.5 版本后提供了一种新的多线程创建方法：通过 `Callable` 接口和 `FutureTask `类相结合创建线程。

#### 1.Callable接口

`Callable` 接口位于 java.util.concurrent 包下：

```java
package java.util.concurrent;

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

`Callable` 接口是一个函数式接口，它的抽象方法 `call()` 有返回值，其类型是 `Callable` 接口的范型参数类型。`call()` 抽象方法还有一个 `Exception` 的异常声明，允许方法的实现版本中直接抛出异常。相比起来，`Runnable` 的 `run()` 方法**没有返回值**也**没有受检异常的异常声明**。

由于 `Callable` 与 `Runnable` 没有任何继承关系，因此不能直接传入 `Thread`，这时就要使用到 `RunnableFuture` 接口这个中间搭桥接口。

#### 2.RunnableFuture接口

位于 java.util.concurrent 包下，它继承了 `Runnable` 接口，保证了可以作为 `Thread` 线程实例的 target 传入，并通过继承 `Future` 接口保证了可以获取异步执行结果。

```java
package java.util.concurrent;
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

#### 3.Future接口

`Future` 是一个对异步任务进行交互、操作的接口，其至少提供了三大功能：

1. 能够取消异步执行中的任务
2. 判断异步任务是否执行完成
3. 获取异步任务完成后的执行结果

源码如下：

```java
package java.util.concurrent;

public interface Funture<V> {
    // 取消异步执行
    boolean cancel(boolean mayInterruptRunning);
    boolean isCancelled();
    // 判断异步任务是否执行完成
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    // 设置时限，获取异步任务完成后的执行结果
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    ...
}
```

- `V get()`：调用线程阻塞直到异步任务执行完成并异步返回结果给调用线程
- `V get(long timeout, TimeUnit unit) `：带时限的阻塞获取异步任务执行的结果，如果阻塞时间超过设定的时间则抛出异常
- `boolean isDone()`：获取异步任务的执行状态，如果执行结束则返回 true
- `boolean isCancelled()`：获取异步任务的取消状态，如果任务完成前被取消就返回 true
- `boolean cancel(boolean mayInterruptRunning)`：取消异步任务的执行

需要注意的是 `Future` 仅仅是一个接口，无法通过它直接完成对异步任务的操作，对此 JDK 提供了一个默认的实现类——`FutureTask`。

#### 4.FutureTask类

`FutureTask` 是 `RunnableFuture` 接口的实现类，相当于**实现了 `Runnable` 和 `Future` 接口**，因此它既可以作为一个 `Runnable` 类型的 target 执行目标被 `Thread` 执行，也可以作为 `Future` 异步任务来获取 `Callable` 的计算结果。

同时 `FutureTask` **内部有一个 `Callable` 类型的 `callable` 实例属性**：

```java
private Callable<V> callable;
```

`callable` 实例属性用来保存并发执行的 `Callable<V>` 类型的任务，并且 `callable` 实例属性需要在 `FatureTask` 实例构造时进行初始化。`FutureTask` 类实现了 `Runnable` 接口，在其 `run()` 方法的实现版本中会执行 `callable` 成员的 `call()` 方法。

此外 `FutureTask` 内部还有一个非常重要的 `Object` 类型的实例属性——`outcome`，用来保存 `callable` 成员的 `call()` 方法的异步执行结果。在 `FutureTask` 类的 `run()` 方法完成 `callable` 成员的 `call()` 方法执行后，其结果将被保存在 `outcome` 实例属性中，供 `FutureTask` 类的 `get()` 方法获取。

```java
private Object outcome;
```

#### 5.创建线程的具体步骤

1. 创建一个 `Callable` 接口的实现类并实现其 `call()` 方法
2. 使用 `Callable` 实现类的实例构造一个 `FutureTask` 实例
3. 使用 `FutureTask` 实例作为 `Thread` 构造器的 target 入参构造新的 `Thread` 线程实例
4. 调用 `Thread` 实例的 `start()` 方法启动新的线程执行 `run()` 方法，内部执行过程为：启动 `Thread` 实例的 `run()` 方法并发执行后，会执行 `FutureTask` 实例的 `run()` 方法，最终会并发执行 `Callable` 实现类的 `call()` 方法

5. 调用 `FutureTask` 对象的 `get()` 方法阻塞性地获取并发线程的执行结果

代码示例如下：

```java
public class CreateDemo3 {
    public static final int MAX_TURN = 5;
    public static final int COMPUTE_TIMES = 100000000;

    // 创建 Callable 接口的实现类
    static class ReturnableTask implements Callable<Long> {
        @Override
        public Long call() throws Exception {
            long startTime = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() + "线程开始运行.");
            Thread.sleep(1000);

            for (int i = 0; i < COMPUTE_TIMES; i++) {
            	int j = i * 10000;
            }

            long used = System.currentTimeMillis() - startTime;
            System.out.println(Thread.currentThread().getName() + "线程运行结束.");
            return used;
        }
    }

    public static void main(String args[]) throws InterruptedException {
        ReturnableTask task = new ReturnableTask();
        FutureTask<Long> futureTask = new FutureTask<Long>(task);
        Thread thread = new Thread(futureTask, "returnableThread");
        thread.start();
        Thread.sleep(500);
        
        System.out.println(Thread.currentThread().getName() + "干点啥...");
        for (int i = 0; i < COMPUTE_TIMES / 2; i++) {
            int j = i * 10000;
        }

        System.out.println(Thread.currentThread().getName() + "获取并发任务的执行结果.");
        try {
            System.out.println(thread.getName() + "线程占用时间：" + futureTask.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束.");
    }
}
```

结果如下：

```bash
returnableThread线程开始运行.
main干点啥...
main获取并发任务的执行结果.
returnableThread线程运行结束.
returnableThread线程占用时间：1012
main运行结束.
```

执行流程大致如下：

<img src="img/第01章_多线程原理与实战/image-20231128230601369.png" alt="image-20231128230601369" style="zoom: 33%;" />

调用 `futureTask.get()` 获取异步执行结果时有两种情况：

1. `futureTask` 结果 `outcome` 不为空，`callable.call()` 执行完成

   此时会直接返回结果。

2. `futureTask` 结果 `outcome` 为空，`callable.call()` 还没有执行完

   此时调用线程 main 会被阻塞住，一直到 `callable.call()` 执行完成。但执行完后结果会被保存到 `outcome` 中，`futureTask` 会唤醒 main 线程去提取执行结果。

### 2.6 方法四：使用线程池

前面的实例中创建的 `Thread` 实例在执行完成后都销毁了，它们是不可复用的。但是由于创建线程的资源消耗很高，实际开发中不能频繁进行线程实例的创建与销毁，而是需要对已经创建好的线程实例进行复用，这就涉及线程池的技术。Java 中提供了一个静态工厂 `Executors` 来创建不同的线程池。

#### 1.创建线程池

通过 `Executors` 工厂类创建一个线程池的示例如下：

```java
private static ExecutorService pool = Executors.newFixedThreadPool(3);
```

工厂类方法 `newFixedThreadPool(int threads)` 用于创建包含固定数目的线程池。

`ExecutorService` 是 Java 提供的一个线程池接口，每次在异步执行 target 目标任务的时候，可以通过 `ExecutorService` 线程池实例提交或者执行。`ExecutorService` 实例负责对池中的线程进行管理和调度，并且可以有效控制最大并发线程数，提高系统资源的使用率，同时提供定时执行、定频执行、单线程、并发数控制等功能。

向 `ExecutorService` 线程池提交异步执行 target 目标任务的常用方法有：

```java
// 执行一个 Runnable 类型的 target 执行目标实例，无返回值
void execute(Runnable command);
// 执行一个 Thread 实例，无返回值
void execute(Thread thread);
// 提交一个 Callable 类型的 target 执行目标实例，返回一个 Future 异步任务实例
<T> Future<T> submit(Callable<T> task);
// 提交一个 Runnable 类型的 target 执行目标实例，返回一个 Future 异步任务实例
Future<?> submit(Runnable task);
```

#### 2.execute()和submit()区别

1. **接收的参数不同**

   `submit()` 可以接收两种参数：无返回值的 `Runnable` 类型（此时调用 `get()` 只会返回 null）和有返回值的 `Callable` 类型；`execute()` 仅仅接收无返回值的 target 执行目标实例，或者无返回值的 Thread 实例。

2. **`submit()` 有返回值，`execute()` 无返回值**

   `submit()` 方法在提交异步 target 执行目标后会返回 `Future` 异步任务实例，以便对 target 的异步执行过程进行控制，比如取消执行、获取结果等；`exeute()` 没有任何返回值，target 执行目标实例在执行后无法对其异步执行过程进行控制，只能任其执行到结束。

## 3.线程的核心原理

现代操作系统提供了强大的线程管理能力，Java 无需再进行独立的线程管理和调度，而是将线程调度工作**委托给了操作系统的调度进程**去完成。在某些操作系统（例如 Solaris）上，JVM 甚至将每个 Java 线程一对一的对应到操作系统的本地线程，彻底将线程调度委托给操作系统。

### 3.1 线程调度与时间片

由于 CPU 的计算频率非常高，每秒计算数十亿次，因此可以将 CPU 的时间**从毫秒的维度进行分段**，每一小段叫做一个 CPU 时间片。对于不同的操作系统、不同的 CPU、线程的 CPU 时间片长度都不同。假定操作系统线程的时间片长度为 20 毫秒，在一个 2GHz（表示每秒钟可以执行 2 × 10^9 次时钟周期）的 CPU 上，一个时间片可以计算的次数是 20 亿 / 1000 * 20 = 4000 万次，即一个时间片内的计算量是非常巨大的。

目前操作系统中主流的线程调度方式是**基于 CPU 时间片**，即线程只有得到 CPU 时间片才能执行指令，处于执行状态，没有得到时间片的线程处于就绪状态，等待系统分配下一个 CPU 时间片。由于时间片非常短，**在各个线程之间快速地切换**，因此表现出来的特征是很多个线程在“同时执行”或”并发执行“。

线程的调度模型目前主要分为两种：**分时调度模型**和**抢占式调度模型**。

1. 分时调度模型：系统平均分配 CPU 时间片，所有线程轮流占用 CPU

2. 抢占式调度模型：系统按照线程优先级分配 CPU 时间片，优先级高的线程优先分配；如果优先级相同，则随机选择一个

由于目前大部分操作系统都是**抢占式调度模型**，与之相对的，Java 的线程调度也基本上是使用抢占式调度模型，因此 Java 的线程具有优先级。

### 3.2 线程优先级

在 `Thread` 类中有一个实例属性和两个实例方法用于进行线程优先级相关操作：

```java
private int priority;                        // 优先级，1～10
public final int getPriority();              // 获取线程优先级
public final void setPriority(int priority); // 设置线程优先级
```

`Thread`类中定义的三个优先级常量如下：

```java
public static final int MIN_PRIORITY = 1;
public static final int MIN_PRIORITY = 5;  // 默认
public static final int MIN_PRIORITY = 10;
```

Java 中使用抢占式调度模型进行线程调度，`priority` 值越高，线程获得 CPU 时间片的机会越多，但**并不是绝对的**，执行机会的获取具有随机性，某段时间内 `thread=10` 的线程不一定比 `thread=9` 的线程获得的时间分片多。

### 3.3 线程生命周期

Java 中线程的生命周期分为 6 种状态，Thread 类中有一个实例属性和一个实例方法专门用于保存和获取线程的状态：

```java
private int threadStatus;             // 整数的形式保存线程状态
public Thread.State getState();       // 返回当前线程的执行状态
```

`Thread.State` 是一个内部枚举类，定义了 6 个枚举常量，分别代表线程的 6 种状态：

```java
public static enum State {
    NEW,                  // 新建
    RUNNABLE,             // 可执行状态：包含操作系统的就绪、运行两种状态
    BLOCKED,              // 阻塞
    WAITING,              // 等待
    TIMED_WAITING,        // 限时等待
    TERMINATED;           // 终止
}
```

其中以下 4 种状态比较常见：

#### 1.NEW

Java 源码对 NEW 状态的说明是：创建成功但是没有调用 `start()` 方法启动的 `Thread` 线程实例都处于 NEW 状态。但是并不是 `start()` 方法一经调用状态就从 NEW 到 RUNNABLE，此时并不意味着线程立即获取 CPU 时间片并且立即执行，中间需要一系列操作系统的内部操作。

#### 2.RUNNABLE

Java 中的线程管理是通过 JNI 本地调用的方式委托**操作系统的线程管理 API** 完成的。当 Java 线程的 `Thread` 实例的 `start()` 方法被调用后，操作系统中的对应线程进入的并不是运行状态而是就绪状态，而 Java 线程并没有这个就绪状态，而是将**运行状态**和**就绪状态**合并为 RUNNABLE 状态，这是 Java 线程状态和操作系统中线程状态不同的地方。

JVM 的线程状态与其幕后的操作系统线程状态之间的转换关系简化后如图：

<img src="img/第01章_多线程原理与实战/image-20231210011921822.png" alt="image-20231210011921822" style="zoom:50%;" />

处于就绪状态的线程需要等待系统的调度，一旦被系统选中获得 CPU 时间片，线程就开始占用 CPU 并执行代码，此时线程的操作系统状态进入了运行状态。当 CPU 时间片用完后又回到就绪状态，等待下一次调度。这种反复调度会一直持续到线程的代码逻辑执行完成或异常终止，此时线程的操作系统状态进入终止状态，即线程的 TERMINATED 状态。

**（１）就绪状态**

当前线程进入就绪状态的条件大致包括以下几种：

- 调用线程的 `start` 方法
- 当前线程的执行时间片用完
- 线程睡眠操作 `sleep` 结束
- 对其他线程合入操作 `join` 结束
- 等待用户输入结束
- 线程争抢到对象锁 `Object Monitor`
- 当前线程调用了 `yield` 方法让出 CPU 执行权限

**（2）执行状态**

线程调度程序从就绪状态的线程中选择一个线程，被选中的线程状态将变成执行状态。

#### 3.BLOCKED

处于 BLOCKED 状态的线程不会占用 CPU 资源，以下情况会让线程进入阻塞状态：

- **线程等待获取锁**

  等待获取一个锁，而该锁被其他线程持有时，该线程进入阻塞状态。当其他线程释放了锁，并且线程调度器允许该线程持有该锁时，该线程退出阻塞状态。

- **IO 阻塞**

  线程发起了一个阻塞式 IO 操作后，如果不具备 IO 操作的条件，线程就会进入阻塞状态。例如线程等待用户输入内容后继续执行。

#### 4.WAITING

处于 WAITING 状态的线程不会被分配 CPU 时间片，需要被其他线程显式地唤醒才会进入就绪状态。以下三种方法会让线程进入无限等待状态：

- `Object.jwat()`，对应的唤醒方式为：`Object.notify()/Object.notifyAll()`
- `Thread.join()`，对应的唤醒方式为：被合入的线程执行完毕
- `LockSupport.partk()`，对应的唤醒方式为：`LockSupport.unpark(Threaed)`

#### 5.TIMED_WAITING

处于 TIMED_WAITING 状态的线程不会被分配 CPU 时间片，如果指定时间内没有被唤醒，则限时等待的线程会被系统自动唤醒，进入就绪状态。线程处于限时等待状态的操作大致有以下几种：

- `Thread.sleep(int n)`：使当前线程进入限时等待状态，等待时间为 n 毫秒
- `Object.wait(long timeout)`：带时限的抢占对象的 monitor 锁
- `Thread.join(long millis)`：带时限的线程合并
- `LockSupport.partNanos(long nanos)`：让线程等待，以纳秒为单位
- `LockSupport.partUntil(long deadline)`：让线程等待直到指定的纳秒时间，可以用`System.nanoTime()`获取当前时间

> **提示**
>
> 进入 BLOCKED 状态、WAITING 状态、TIMED_WAITING 状态的线程都会让出 CPU 使用权；等待或阻塞的线程被唤醒后首先进入**就绪状态**，获得时间片后才能执行。

#### 6.TERMINATED

处于 RUNNABLE 状态的线程在 `run()` 方法执行完成后就变成终止状态 TERMINATED。如果在 `run()` 方法执行过程中发生了运行时异常而没有被捕获，`run()` 方法将被异常终止，线程也会进入 TERMINATED 状态。

### 3.4 使用Jstack查看线程状态

Jstack 是 Java 虚拟机自带的一种堆栈跟踪工具，用于生成或导出 JVM 虚拟机运行实例当前时刻的**线程快照**。线程快照是当前 JVM 实例内每一个线程正在执行的方法堆栈的集合，生成或导出线程快照的主要目的是定位线程出现长时间运行、停顿或者阻塞的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。

命令的语法格式如下：

```bash
jstack <pid>  # pid 可通过 jps 命令查看
```

通过 Jstack 输出的线程信息主要包括：JVM 线程、用户线程等。其中 JVM 线程在 JVM 启动时就存在，主要包括如执行垃圾回收、周期性任务调度（用于内存监控、运行状况监控）等多个后台线程；用户线程则是在程序创建了新的线程时才会生成。这里需要注意：

1. 实际运行中建议产生三次 DUMP 信息，如果这三次信息都指向同一个问题，才能确定问题的典型性
2. 不同的 Java 虚拟机线程 DUMP 的信息格式是不一样的，即是同一个 JVM 的不同版本也会有差别

Jstack 指令所输出的信息中包含以下重要信息：

1. `tid`：线程实例在 JVM 进程中的 id
2. `nid`：线程实例在操作系统中对应的底层线程的线程 id
3. `prio`：线程实例在 JVM 进程中的优先级
4. `os_prio`：线程实例在操作系统中对应的底层线程的优先级
5. 线程状态：如 runnable、waiting on condition 等

一个示例如下：

```bash
$ jstack 43137
2023-12-10 02:01:59
Full thread dump OpenJDK 64-Bit Server VM (25.362-b08 mixed mode):
...
"Thread-0" #10 prio=5 os_prio=31 tid=0x0000000147919000 nid=0x5803 waiting on condition [0x0000000171bd2000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at CreateDemo3.lambda$0(CreateDemo3.java:32)
	at CreateDemo3$$Lambda$1/1418481495.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:750)
...
```

## 4.线程的基本操作

### 4.1 名称

在 `Thread` 类中可以通过构造器 `Threaed(...)` 初始化设置线程名称，也可以通过 `setName(...)` 实例方法设置线程名称，通过 `getName()` 取得线程名称。

关于线程名称有以下几个要点：

1. 线程名称一般在启动线程前设置，但也允许为运行中的线程设置名称
2. 允许两个 `Thread` 对象有相同的名称，但应该避免
3. 如果没有指定，则系统会自动分配一个名称

### 4.2 sleep

`sleep` 作用是让正在执行的线程休眠，让 CPU 执行其他的任务，从线程状态来说就是从执行状态变成限时阻塞状态。它有两个重载版本：

```java
// 让目前正在执行的线程休眠 millis 毫秒
public static void sleep(long millis) throws InterruptException;
// 让目前正在执行的线程休眠 millis 毫秒，nanos 纳秒
public static void sleep(long millis, int nanos) throws InterruptException;
```

当线程睡眠时间满后，线程会首先进入就绪状态，等待分配 CPU 时间片。

### 4.3 interrupt

Java 提供了 `stop()` 方法用于终止正在运行的线程，但是该方法已被设置为过时，因为中断线程时，该线程可能持有某把锁，强行中断会导致锁不能释放的问题；或者线程在操作数据库，强行中断可能导致数据不一致的问题。

这里介绍的 `interrupt()` 方法本质并不是用来中断一个线程的，而是将线程中断状态位设置为 true。当调用线程的 `interrupt()` 方法时有两个作用：

1. 如果线程被 `Object.wait()`、`Thread.join()`、`Thread.sleep()` 三种方法之一阻塞，调用 `interrupt()` 会立刻退出阻塞，并抛出 `interruptedException` 异常
2. 如果线程处于运行中，线程不会受到任何影响，仅仅是线程的中断标记被设置为 true，此时线程可以在适当位置自旋，通过调用 `isInterrupted()` 来查看自己是否被中断，并选择退出

> **注意**
>
> 如果在线程启动后先调用 `interrupt()` 方法再调用阻塞方法依然会直接抛出异常，如果捕获了该异常后又调用了阻塞方法，则此时不回抛出异常，除非再次调用 `interrupt()` 方法。即 `interrupt()` 方法只会影响一次阻塞方法。

### 4.4 join

当线程 A 需要等待线程 B 的执行完成时就需要用到线程合并，被动方线程 B 可以叫做被合并线程。`join()` 方法无法获得线程 B 的执行结果。

#### 1.join的三个版本

`join()` 方法是 Thread 类的一个实例方法，有三个重载版本：

```java
// 1.此方法会把当前线程变为 TIMED_WAITING，直到被合并线程执行结束
public final void join() throws InterruptedException;
// 2.此方法会把当前线程变为 TIMED_WAITING，直到被合并线程执行结束，或等待被合并线程执行 millis 的时间
public final synchronized void join(long millis) throws InterruptedException;
// 3.此方法会把当前线程变为 TIMED_WAITING，直到被合并线程执行结束，或等待被合并线程执行 millis + nanos 的时间
public final synchronized void join(long millis, int nanos) throws InterruptedException;
```

调用时需要在主动合并线程中调用被合并线程的 `join()` 方法；带时限的方法与 `sleep()` 方法相同，等待结束后首先会进入就绪状态，等待 CPU 分片；如果在等待时被中断，就会抛出 `InterrupedException`。

```java
class ThreadA extends Thread {
    void run() {
        Thread threadB = new Thread();
        try {
        	threadB.join(10000);  // 线程 A 进入等待，直到线程 B 执行完成或等待超时
        } catch (InterrupedException e) {
            e.printStackTrace();
        }
    }
}
```

#### 2.join的WAITING状态

线程的 WAITING 状态表示线程正在等待被唤醒。处于 WAITING 状态的线程不会被分配 CPU 时间片。执行以下两个操作，当前线程将处于 WAITING 状态：

- 执行没有时限参数的 `thread.join()` 方法：若线程 A 调用 `B.join()`，则线程 A 在线程 B 执行期间处于 WAITING 状态直到线程 B 执行结束
- 执行没有时限参数的 `object.wait()` 方法：一个拥有 object 对象锁的线程，进入相应的代码临界区后，调用相应的 object 的 `wait()` 方法等待其 “对象锁” 上的信号，若没有信号则处于 WAITING 状态

<img src="img/第01章_多线程原理与实战/image-20231223115804403.png" alt="image-20231223115804403" style="zoom:67%;" />

#### 3.join的TIMED_WAITING状态

线程的 TIMED_WAITING 状态表示正在等待唤醒。处于 TIMED_WAITING 状态的线程不会被分配 CPU 时间片，它们要等待被唤醒或者直到等待的时限到期。例如若 A 线程调用 `B.join()` 时加入了时限参数，则在 B 执行期间 A 处于 TIME_WAITING 状态。若 B 在等待时限内没有返回，则 A 结束等待恢复成 RUNNABLE 状态。

### 4.5 yield

线程的 `yield` 的作用是让目前正在执行的线程放弃当前的执行，**让出 CPU 的执行权限**，使得 CPU 去执行其他的线程。处于让步状态的 JVM 层面的线程状态仍然是 RUNNABLE 状态，但是该线程所对应的操作系统层面的线程状态会**从执行状态变成就绪状态**，相当于只是让系统的线程调度器重新调度一下。

`yield()` 方法是 `Thread` 类提供的一个静态方法。线程在 `yield` 时可能会出现刚让出 CPU，马上又获得 CPU 执行权限的情况，此时操作系统往往会在重新进行调度的时候偏向于将执行机会让给**优先级较高**的线程。

`Thread.yield()` 总结起来有以下特点：

- `yield` 仅能使一个线程从运行状态转到就绪状态，而不是阻塞状态
- `yield` 不能保证使当前正在运行的线程迅速转换到就绪状态
- 即使完成了迅速转换，系统通过线程调度机制从所有就绪线程中挑选下一个执行线程时，就绪的线程有可能被选中，有可能不被选中，具体取决于其他因素（如优先级）的影响

### 4.6 daemon

Java 中的线程分为两类：**守护线程**和**用户线程**。守护线程也称为后台线程，专门指在程序进程运行过程中，在后台提供某种通用服务的线程。只要 JVM 实例中尚存在任何一个用户线程没有结束，守护线程就能执行自己的工作；当最后一个用户线程结束后守护线程随同 JVM 一起结束工作。

比如，每次启动一个 JVM 进程，都会在后台运行一系列的 GC 线程，这些 GC 线程就是守护线程，负责幕后的垃圾回收工作。使用 `jstack` 指令 DUMP 某个 JVM 进程时可以看到 GC 线程。

#### 1.守护线程基本操作

```java
// 保存一条 Thread 线程实例的守护状态，默认为 false，表示默认为用户线程
private boolean daemon = false;

// 将线程标记为守护线程或者用户线程
public final void setDaemon(boolean on);

// 获取线程的守护状态
public final boolean isDaemon();
```

#### 2.守护线程注意事项

- 守护线程必须在启动（调用 `start()`）前将其守护状态设置为 true，启动后不能设置，JVM 会抛出 `InterruptedException` 异常
- 守护线程中不要访问系统资源，如文件句柄、数据库连接等，因为存在被 JVM 强行终止的风险，从而导致资源操作无法正常结束
- 守护线程创建的线程也是守护线程；可以在创建后启动前调用 `setDaemon(false)` 将新线程设置为用户线程

## 5.线程池原理与实战

Java 线程创建非常昂贵，需要 JVM 和 OS 配合完成大量工作：

- 必须为线程堆栈分配和初始化大量内存块，其中包含至少 1MB 的栈内存
- 需要进行系统调用，在 OS 中创建和注册本地线程

Java 高并发应用频繁创建和销毁线程的操作非常低效，而且是**不被编程规范所允许**的，因此必须使用线程池。线程池主要解决了以下两个问题：

- **提升性能**

  线程池能够独立负责线程的创建、维护和分配。在执行大量异步任务时，无需自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，提升性能。

- **线程管理**

  每个 Java 线程池会保持一些基本的线程统计信息，如完成的任务数量、空闲时间等，从而对线程进行有效管理，对所接受到的异步任务进行高效调度。

### 5.1 JUC线程池架构

JUC 就是 java.util.concurrent 工具包的简称，该工具包是从 JDK1.5 开始加入 JDK，用于完成高并发、处理多线程的一个工具包。

<img src="img/第01章_多线程原理与实战/image-20231227004810550.png" alt="image-20231227004810550" style="zoom:67%;" />

- **Executor**

  `Executor` 是执行 Java 异步目标任务的"执行者"接口，它只包含一个函数式方法用来执行提交的 `Runnable` 执行目标实例：

  ```java
  void execute(Runnable command)
  ```

- **ExecutorService**

  `ExecutorService` 继承 `Executor`，是 Java 异步目标任务的"执行者服务"接口，对外提供异步任务的接收服务，如 `submit` 系列方法、`invoke` 系列方法等：

  ```java
  // 向线程池提交单个任务
  <T> Future<T> submit(Callable<T> task);
  // 向线程池提交批量异步任务
  <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
  ```

- **AbstractExecutorService**

  `AbstractExecutorService` 是一个抽象类，实现了 `ExecutorService` 接口，存在的作用是为 `ExecutorService` 中的接口提供默认实现。

- **ThreadPoolExecutor**

  继承于 `AbstractExecutorService` 的  JUC 线程池的核心实现类。

- **ScheduledExecutorService**

  继承于 `ExecutorSerice` 的接口，可以完成"延时"和"周期性"任务的调度线程池接口，功能和 `Timer/TimerTask` 类似。

- **ScheduledThreadPoolExecutor**

  继承于 `ThreadPoolExecutor`，同时实现了 `ScheduledExecutorService` 接口中"延时"和"周期性执行"等调度方法。在高并发程序中，`ScheduledThreadPoolExecutor` 的性能要优于 `Timer`。

- **Executors**

  一个静态工厂类，通过静态工厂方法返回 `ExecutorService`、`ScheduledExecutorService` 等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。

### 5.2 创建线程池

Java 通过 `Executors` 工厂类提供了 4 种快捷创建线程池的方法：

| 方法名                             | 功能简介                                                     |
| ---------------------------------- | ------------------------------------------------------------ |
| `newSingleThreadExecutor()`        | 创建只有一个线程的线程池                                     |
| `newFixedThreadPool(int nThreads)` | 创建固定大小的线程池                                         |
| `newCachedThreadPool()`            | 创建一个不限制线程数量的线程池，任何提交的任务都将立即执行，但是空闲线程会得到及时回收 |
| `newScheduledThreadPool()`         | 创建一个可定期或者延时执行任务的线程池                       |

#### 1.newFixedThreadPool

创建一个"固定数量的线程池"，唯一的参数用于设置池中线程的“固定数量”。该线程池特点如下：

- 如果线程池没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量
- 线程池大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，则线程池会补充一个新线程
- 在接受服务异步任务的执行目标实例时，如果池中所有线程均繁忙，则新任务会进入**==无界==**的阻塞队列

适用场景：任务需要长期执行。“固定数量的线程池”能够比较稳定地保证线程数，避免频繁回收线程和创建线程，故适用于处理 CPU 密集型任务，在 CPU 被工作线程长时间占用的情况下，能确保尽可能少地分配线程。

#### 2.newSingleThreadExecutor

创建一个"单线程化线程池"，即只有一个线程的线程池，该线程池具有以下特点：

- 按照提交的次序顺序执行
- 池中的唯一线程的存活时间是无限的
- 当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是**==无界==**的

适用场景：任务按照提交次序逐个执行。

> **提示**
>
> `newFixedThreadPool` 的返回结果可以通过强转变成 `ThreadPoolExecutor`，进而可以通过 `setCorePoolSize()` 方法来修改线程数。而 `newSingleThreadExecutor` 方法则通过提供了一个包装类完全堵住了这个漏洞。

#### 3.newCachedThreadPool

创建一个“可缓存线程池”，所有线程为非核心线程，如果线程池内的某些线程空闲，则可以被灵活回收。该线程池特点如下：

- 在接收新的异步任务时，如果池内所有线程繁忙，则添加一个新线程处理任务
- 线程池大小无限制，依赖于操作系统（或者 JVM）能够创建的最大线程大小
- 会自动回收空闲线程（60 秒不执行任务）

适用场景：需要快速处理突发性强、耗时短的任务场景，如 Nteet 的 NIO 处理、REST API 接口的瞬时削峰。“可缓存线程池”线程数量不固定。

#### 4.newScheduledThreadPool

创建一个“可调度线程池”，即提供一个“延时”和“周期性”任务调度功能的 `ScheduledExecutorService` 类型的线程池。`Executors` 提供了多个创建“可调度线程池”的工厂方法：

```java
// 方法 1: 创建一个仅含有一个线程的可调度线程池
public static ScheduledExecutorService newSingleThreadScheduledExecutor();

// 方法 2: 创建一个含有 N 个线程的可调度线程池
public static ScheduledExecutorService newScheduledThraedPool(int corePoolSize);
```

其中 `newSingleThreadScheduledExecutor` 工厂方法创建的仅含有一个线程的可调度线程池适用于调度串行化任务，即任务逐个执行。

返回的 `ScheduledExecutorService` 接口中有多个重要的接收被调目标任务的方法，其中 `scheduleAtFiedRate` 和 `scheduleWithFixedDelay` 使用的比较多。

```java
public ScheduledFuture<?> scheduleAtFixedRate (
	Runnable command,		// 异步任务 target 目标
    long initialDelay,		// 首次执行延时
    long period,			// 两次开始执行的最小间隔时间，如果被调任务的执行时间大于该值，则会等待前一次调度执行完毕后再执行下一次任务
    TimeUnit unit			// 时间的计时单位，如 Timeunit,SECONDS
);
```

```java
public ScheduledFuture<?> scheduleWithFixedDelay (
	Runnable command,
    long initialDelay,
    long delay,				// 前一次执行结束到下一次执行开始的间隔时间
    TimeUnit unit
);
```

例如对于下面的示例：

```java
ScheduledExecutorService pool = Executors.scheduleAtFixedRate(3);
// 隔 4S 输出一次
pool.scheduleAtFixedRate(() -> {
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {}
    System.out.println(Thread.currentThread().getName());
}, 0, 3, TimeUnit.SECONDS);

pool = Executors.newScheduledThreadPool(3);
// 隔 7S 输出一次
pool.scheduleWithFixedDelay(() -> {
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {}
    System.out.println(Thread.currentThread().getName());
}, 0, 3, TimeUnit.SECONDS);
```

适用场景：周期性地执行任务。

Spring Boot 中的任务调度器底层就是借助了 JUC 的 `ScheduleExecutorService` 实现，参考[定时任务](../../后端/Spring/Spring%20Boot%202/SpringBoot2知识点.md#6.定时任务)。

### 5.3 标准创建方式

实际开发中要避免使用 `Executors` 提供的创建线程池的方法，而应该通过 `ThreadPoolExecutor` 构造工作线程池。`Executors` 提供的快捷工厂方法实际上也是调用了 `ThreadPoolExecutor` 线程池的构造方法完成的。`ThreadPoolExecutor` 构造方法有多个重载版本，其中比较重要的一个如下：

```java
public ThreadPoolExecutor {
    int corePoolSize,					// 核心线程数，即使线程空闲也不会被回收
    int maximumPoolSize,				// 线程数的最大上限
    long keepAliveTime, Timeunit unit,	// 线程最大空闲时间，超过则被回收
    BlockingQueue<Runnable> workQueue,	// 任务的排队队列
    ThreadFactory threadFactory,		// 线程工厂
    RejectedExecutionHandler handler	// 拒绝策略
}
```

#### 1.核心和最大线程数量

`corePoolSize` 用于设置核心线程数量，`maximumPoolSize` 用于设置最大线程数量，大致规则如下：

（1）线程池接收到新任务时，如果当前工作线程数少于 `corePoolSize`，即使其他工作线程处于空闲状态，也会创建一个新线程来处理请求，直到线程数达到 `corePoolSize`。

（2）如果工作线程数大于 `corePoolSize` 小于 `maximumPoolSize`，当且仅当**任务排队队列满**时才会创建新线程。设置 `corePoolSize` 和 `maximumPoolSize` 相同，可以创建一个固定大小的线程池。

（3）当 `maximumPoolSize` 被设置为无界值（如 `Integer.MAX_VALUE`）时，线程池可以接收任意数量的并发任务

（4）`corePoolSize` 和 `maximumPoolSize` 不仅能在线程池构造时设置，也可以调用 `setCorePoolSize()` 和 `setMaximumPoolSize()` **动态更改**

#### 2.排队队列

`BlockingQueue`（阻塞队列）用于暂存接收到的异步任务，如果线程池的核心线程繁忙，则接收到的目标任务会放在阻塞队列中。

#### 3.空闲线程存活时间

`keepAliveTime` 用于设置池内线程最大空闲时长，如果超过这个时间，默认情况下空闲、非核心线程会被回收。

如果在线程池使用过程中提交任务的频率变高，也可以调用方法 `setKeepAliveTime(long, TimeUnit)` 动态调整线程存活时间。如果需要防止空闲线程被终止，可以将空闲时间设置为无限大：

```java
setKeepAliveTime(Long,MAX_VALUE, TimeUnit.NANOSECONDS);
```

默认情况下，空闲超时策略仅适用于存在超过 `corePoolSize` 线程的情况。但若调用了 `allowCoreThreadTimeOut(true)` 方法，则 `keepAliveTime` 参数设置的 Idle 超时策略也将被应用于核心线程。

#### 4.线程工厂

`ThreadFactory` 是 Java 线程工厂接口：

```java
public interface ThreadFactory {
    Thread newThread(Runnable target);
}
```

使用 `Executors` 创建新的线程池时，可以传自定义的 `ThreadFactory` 实现类。如果不指定的话则默认使用 `Executors.defaultThreadFacotry` 实例，创建的线程全部位于同一个 ThreadGroup（线程组）中，具有相同的 `NORM_PRIORITY`（优先级 5），而且都是非守护进程状态。

> **说明**
>
> `Executos` 为线程池工厂类；`ThreadFactory` 为线程工厂类。

一个简单的线程工厂例子：

```java
public class SimpleThreadFactory implements ThreadFactory {
    static AtomicInteger threadNo = new AtomicInteger(1);
    @Override
    public Thread newThread(Runnable target) {
        String threadName = "simpleThread-" + threadNo.get();
        threadNo.incrementAndGet();
        // 设置线程名称
        Thread thread = new Thread(target, threadName);
        // 设置为守护线程
        thread.setDaemon(true);
        return thread;
    }
}
```

#### 5.任务阻塞队列

`BlockingQueue` 是 JUC 包的一个超级接口，与普通队列相比有一个重要的特点：阻塞队列为空时会**阻塞**当前元素获取操作；当队列中有元素后，被阻塞的线程会自动被唤醒。

常用的实现类如下：

- `ArrayBlockingQueue`

  一个数组实现的**有界**阻塞队列，队列中的元素按 FIFO 排序。`ArrayBlockingQueue` 在创建时必须设置大小。

- `LinkedBlockingQueue`

  一个基于链表实现的阻塞队列，按 FIFO 排序，可以设置容量（有界），不设置容量则默认使用 `Integer.MAX_VALUE` 作为容量（无界）。`Executors.newSingleThreadExecutor` 和 `Executors.newFixedThreadPool` 使用了这个队列，并且都没有设置容量。该队列的吞吐量高于 `ArrayBlockingQueue`。

- `PriorityBlockingQueue`

  具有优先级的无界队列。

- `DelayQueue`

  一个无界阻塞延迟队列，底层基于 `PriorityBlockingQueue` 实现，队列中每个元素都有过期时间，当从队列获取元素时，只有已经过期的元素才会出队，队列头部的元素是过期最快的元素。`Executors.newScheduledThreadPool` 创建的线程池使用了此队列。

- `SynchronousQueue`

  一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程的调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于 `LinkedBlockingQueue`。`newCachedThreadPool` 使用了此队列。

#### 6.拒绝策略

在线程池的任务缓存队列为有界队列时，如果队列已满，再提交的任务会被线程池拒绝。总体来说任务被拒绝有两种情况：

- 线程池已关闭
- 工作队列已满且 `maximumPoolSize` 已满

无论以上哪种情况被拒绝，线程池都会调用 `RejectedExceptionHandler` 实例的 `rejectedException` 方法。`RejectedExceptionHandler` 是拒绝策略的接口，JUC 为该接口提供了以下几种实现：

**（1）AbortPolicy**（默认）

拒绝策略。使用该策略时，如果队列已满，则新任务会被拒绝，并抛出 `RejectedExecutionException` 异常。该异常是**非受检异常**（运行时异常），很容易忘记捕获。

**（2）DiscardPolicy**

抛弃策略。如果线程池队列已满，则新任务会被直接丢掉，不会抛出任何异常。

**（3）DiscardOldestPolicy**

抛弃最老任务策略。如果队列满了，则抛弃最早进入队列的任务，再尝试将新任务加入队列。每次都是移除队列头元素。

**（4）CallerRunsPolicy**

调用者执行策略。新任务添加到线程池时如果添加失败，则提交任务线程会自己去执行该任务，不会使用线程池中的线程去执行。

**（5）自定义策略**

如果以上拒绝策略都不符合需求，则可自定义一个拒绝策略，实现 `RejectedExecutionHandler` 接口的 `rejectedExecution` 方法：

```java
public static class CustomIgnorePolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        log.info(r + "rejected; " + "- getTaskCount: " + e.getTaskCount());
    }
}

ThreadPoolExecutor pool = new ThreadPoolExecutor (
	2,
    4,
    10, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2);
    new SimpleThreadFactory();
    new CustomIgnorePolicy();
);
```

### 5.4 提交任务

向线程池提交任务有两种方式：

- 调用 `execute()` 方法

  ```java
  // Executor 接口的方法
  void execute(Runnable command);
  ```

- 调用 `submit()` 方法

  ```java
  // ExecutorService 接口的方法
  <T> Future<T> submit(Callable<T> task);
  <T> Future<T> submit(Runnable task, T result);
  Future<?> submit(Runnable task);
  ```

区别如下：

- **二者接收的参数不同**

  `execute()` 只能接收 `Runnable` 类型的参数，而 `submit()` 可以接收 `Callable`、`Runnable` 两种类型的参数。

- **`submit()` 有返回值，`execute()` 没有**

  `execute()` 方法会返回一个 `Future` 异步执行实例，处理结果被包装到 `Future` 实例中，可以通过 `Future.get()` 方法获得异步执行的结果。

- **`submit()` 可以进行 `Exception` 处理**

在 `ThreadPoolExecutor` 类的实现中，内部核心的任务提交方法是 `execute()`，`submit()` 方法最终调用的还是 `execute()`。

### 5.5 任务调度流程

线程池的任务调度流程大致如下：

（1）如果当前工作线程数量小于核心线程数量，执行器总是优先创建一个任务线程，而不是从线程队列中获取一个空闲线程。

（2）如果线程池中总的任务数量大于核心线程池数量，新接收的任务将被加入阻塞队列中，一直到阻塞队列已满。**在核心线程池数量已经用完、阻塞队列没有满的情况下，线程池不会为新任务创建一个新线程**。

（3）当完成一个任务时，执行器总是优先从阻塞队列中获取下一个任务并开始执行，一直到阻塞队列为空，其中所有的缓存任务被取光。

（4）在核心线程池数量已经用完、阻塞队列也已经满了的场景下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核心线程），并且立即开始执行新任务。

（5）在核心线程都用完、阻塞队列已满的情况下，一直会创建新线程去执行新任务，直到池内的线程总数超出 `maximumPoolSize`。如果线程池的线程总数超过 `maximumPoolSize`，线程池就会拒绝接收任务，当新任务过来时，会为新任务执行拒绝策略。

<img src="img/第01章_多线程原理与实战/image-20231228031603346.png" alt="image-20231228031603346" style="zoom:67%;" />

> **注意**
>
> 核心和最大线程数量、`BlockingQueue` 队列等参数如果配置得不合理，可能会造成异步任务无法并发执行，造成严重的排队等待现象：在 `corePoolSize` 已满后，还需要**等阻塞队列已满**，才会创建新的线程。

### 5.6 调度器的钩子方法

`ThreadPoolExecutor` 线程池调度器为每个任务执行前后都提供了钩子方法，总共有三个钩子方法（空方法），一般用作被子类重写：

```java
// 任务执行之前
protected void beforeExecute(Thread t, Runnable r) {}

// 任务执行之后
protected void afterExecute(Thread t, Runnable r) {}

// 线程池终止时
protected void terminated() {}
```

- `beforeExecute`：异步任务执行之前的钩子方法

  线程池工作线程在异步执行目标实例前调用此钩子方法，此方法任然由执行任务（如 Runnable 实例）的工作线程调用，可用于重新初始化 `ThreadLocal` 线程本地变量、更新日志记录、开始计时统计、更新上下文变量等。

- `afterExecute`：异步任务执行之后的钩子方法

  线程池工作线程在异步执行目标实例后调用此方法，同样由执行任务的工作线程调用。可用于清除 `ThreadLocal` 线程本地变量、更新日志记录、收集统计信息、更新上下文变量等。

- `terminated`：线程池终止时的钩子方法

  在 `Executor` 终止时调用。

> **注意**
>
> `beforeExecute` 和 `afterExecute` 两个方法在每个任务执行前后被调用，如果钩子方法抛出异常，则内部工作线程可能失败并突然终止。

一个示例如下：

```java 
ThreadLocal<Instant> startTime = new ThreadLocal<>();

@Test
void demo() throws InterruptedException {
    ExecutorService pool = new ThreadPoolExecutor(2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(2)) {
        @Override
        protected void terminated() {
            log.info("调度器终止！");
        }

        @Override
        protected void beforeExecute(Thread t, Runnable target) {
            log.info(target + "前被执行");
            startTime.set(Instant.now());
        }

        @Override
        protected void afterExecute(Runnable target, Throwable t) {
            long time = Duration.between(startTime.get(), Instant.now()).toMillis();
            log.info(target + "后执行，时间(ms): " + time);
            startTime.remove();
        }
    };

    for (int i = 0; i < 5; i++) {
        pool.execute(new SimpleThread());
    }
    Thread.sleep(10000);
    pool.shutdown();
}
```

结果如下：

```bash
23:58:57.294 [pool-1-thread-1] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-1前被执行
23:58:57.294 [pool-1-thread-3] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-5前被执行
23:58:57.294 [pool-1-thread-2] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-2前被执行
23:58:57.800 [pool-1-thread-1] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-1后执行，时间(ms): 505
23:58:57.800 [pool-1-thread-3] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-5后执行，时间(ms): 505
23:58:57.800 [pool-1-thread-2] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-2后执行，时间(ms): 505
23:58:57.800 [pool-1-thread-3] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-3前被执行
23:58:57.801 [pool-1-thread-1] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-4前被执行
23:58:58.313 [pool-1-thread-3] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-3后执行，时间(ms): 512
23:58:58.313 [pool-1-thread-1] INFO com.youyi.zhao.ExecutorServiceDemo - Thread-4后执行，时间(ms): 512
23:59:07.298 [pool-1-thread-3] INFO com.youyi.zhao.ExecutorServiceDemo - 调度器终止！
```

### 5.6 线程池状态

一般情况下线程池启动后建议手动关闭。线程池存在 5 种状态，定义在 `ThreadPoolExecutor` 类中，具体代码如下：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // Integer.SIZE=32
    private static final int COUNT_BITS = Integer.SIZE - 3;

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
}
```

- `RUNNING`：线程池创建之后的初始状态，这种状态下可以执行任务
- `SHUTDOWN`：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行完毕
- `STOP`：该状态下线程池不再接受新任务，也不会处理工作队列中的剩余任务，并且将会中断所有工作线程
- `TIDYING`：该状态下所有任务都已终止或者处理完成，将会执行 `terminated()` 钩子方法
- `TERMINATED`：执行完 `terminated()` 钩子方法之后的状态

线程池的状态转换规则为：

- 线程池创建之后状态为 `RUNNING`
- 执行线程池的 `shutdown()` 实例方法，会使线程池状态从 `RUNNING` 转变为 `SHUTDOWN`
- 执行线程池的 `shutdownNow()` 实例方法，会使线程池状态从 `RUNNING` 转变为 `STOP`
- 当线程池处于 `SHUTDOWN` 状态时，执行其 `shutdownNow()` 方法会将其状态转变为 `STOP`
- 当线程池的所有工作线程停止，工作队列清空后，线程池状态会从 `STOP` 转变为 `TIDYING`
- 执行完 `terminated()` 钩子方法后，线程池状态从 `TIDYING` 转变为 `TERMINATED`

<img src="img/第01章_多线程原理与实战/image-20231229001427505.png" alt="image-20231229001427505" style="zoom:67%;" />

### 5.7 优雅关闭

优雅关闭线程池主要涉及的方法有 3 个：

#### 1.shutdown()

JUC 提供的一个有序关闭线程池的方法，执行后会将线程池状态转变为 `SHUTDOWN`，不再接收新的任务，但是会等待当前工作队列中的剩余任务全部执行完成后才会执行关闭线程池。

源码大致如下：

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    minLock.lock();
    try {
        // 检查权限
        checkshutdownAccess();
        // 设置线程池状态
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptedIdleWorkers();
        // 钩子函数，主要用于清理一些资源
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
```

`shutdown()` 方法首先加锁，其次检查调用者是否用于执行线程池关闭的 Java Security 权限。接着会将线程池状态变为 `SHUTDOWN`，在之后线程池不再接收提交的新任务。此时如果还有新任务提交，则会使用线程池拒绝策略响应，默认的拒绝策略会使用 `ThreadPoolExecutor.AbortPolicy`，接收新任务时会抛出 `RejectedExecutionException` 异常。

#### 2.shutdownNow()

JUC 提供的一个立即关闭线程池的方法，会打断正在执行的工作线程，并且清空当前工作队列中的剩余任务，返回尚未执行的任务。

源码大致如下：

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 检查状态
        checkShutdownAccess();
        // 将线程池状态变为 STOP
        advanceRunState(STOP);
        // 中断所有线程，包括工作线程及空闲线程
        interruptWorkers();
        // 丢弃工作队列中的剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTermiate();
    return task;
}
```

`shutdownNow()` 方法会把线程池状态设置为 `STOP`，然后中断所有线程（包括工作线程和空闲线程），最后清空工作队列，取出工作队列中所有未完成的任务返回给调用者。

> **注意**
>
> 这里的中断线程并不代表线程立即结束，只是通过工作线程的 `interrupt()` 实例方法**设置了中断状态**，需要用户程序配合进行线程的中断。

#### 3.awaitTermination()

阻塞直到线程池关闭。调用线程池的 `shutdown()` 与 `shutdownNow()` 方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。

源码大致如下：

```java
threadPool.shutdown();
try {
    while(!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
        System.out.println("线程池还未执行结束");
    }
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

如果线程池完成关闭，`awaitTermination()` 方法将返回 true，否则当等待时间超过指定时间后将会返回 false，调用时建议设置重试次数。下面的代码参考了 Dubbo 框架中关闭线程池的源码的部分代码：

```java
if (!threadPool.isTerminated()) {
    try {
        // 循环关闭 1000 次，每次等待 10 毫秒
        for (int i = 0; i < 1000; i++) {
            if (threadPool.awaitTermination(10, Timeunit.MILLISECONDS)) {
                break;
            }
            threadPool.shutdownNow();
        } catch (InterruptedException e) {
            System.err.println(e.getMessage());
        } catch (Throwable e) {
            System.err.println(e.getMessage());
        }
    }
}
```

#### 4.优雅关闭线程池

大致分为以下几步：

1. 执行 `shutdown()` 方法，拒绝新任务的提交，并等待所有任务有序地执行完毕
2. 执行 `awaitTermination(long timeout, TimeUnit unit)` 方法，执行超时时间，判断是否已经关闭所有任务，线程池关闭完成
3. 如果 `awaitTermination()` 方法返回 false，或者被中断，就调用 `shutdownNow()`
4. 再次执行 `awaitTermination(long timeout, Timeunit unit)` 方法，判断线程池是否关闭完成，如果超时就进入循环不断尝试关闭线程池

```java
public class ThreadUtil {
    public static void shutdownThreadPoolGracefully(ExecutorService threadPool) {
        // 若已经关闭则返回
        if (!(threadPool instanceof ExecutorService) || threadPool.isTerminated())
            return;
        try {
            // 拒绝接受新任务
            threadPool.shutdown();
        } catch (SecurityException | NullPointerException e) {
            return;
        }
        try {
            // 等待 60 秒，等待线程池中的任务完成执行
            if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                // 调用 shutdownNow() 方法取消正在执行的任务
                threadPool.shutdownNow();
                // 再次等待 60 秒，如果还未结束可以再次尝试或放弃
                if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                    System.err.println("线程池任务未正常结束");
                }
            }
        } catch (InterruptedException ie) {
            // 捕获异常，重新尝试停止
            threadPool.shutdownNow();
        }
        // 任然没有关闭则循环 1000 次，每次等待 10 毫秒
        if (!threadPool.isTerminated()) {
            try {
                for (int i = 0; i < 1000; i++) {
                    if (threadPool.awaitTermination(10, TimeUnit.MILLISECONDS))
                        break;
                    threadPool.shutdownNow();
                }
            } catch (InterruptedException e) {
                System.err.println(e.getMessage());
            } catch (Throwable e) {
                System.err.println(e.getMessage());
            }
        }
    }
}
```

#### 5.注册JVM钩子函数自动关闭

如果使用了线程池，可以在 JVM 中注册一个钩子函数，在 JVM 进程关闭前，由钩子函数自动将线程池优雅地关闭，以确保资源正常释放。

```java
// 懒汉式单例创建线程池，用于执行定时、顺序任务
static class SeqScheduledTargetThreadPoolLazyHolder {

    static final ScheduledThreadPoolExecutor EXECUTOR = new ScheduledThreadPoolExecutor(1);
    static {
        // 注册 JVM 关闭时的钩子函数
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            shutdownThreadPoolGracefully(EXECUTOR);
        }));
    }
}
```

### 5.8 Executors潜在问题

#### 1.newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(
    	nThreads,								// 核心线程数
        nThreads,								// 最大线程数
        0L,										// 线程最大空闲时长
        TimeUnit.MILLISECONDS,					// 时间单位，毫秒
        new LinkedBlockingQueue<Runnable>()		// 任务的排队队列，无界
    );
}
```

使用 `newFixedThreadPool()` 的问题在于排队队列，由于使用的是**无界阻塞队列**，如果任务提交速度大于任务处理速度，就会造成队列中大量的任务等待。如果队列很大，很有可能导致 JVM 出现 OOM 异常。

#### 2.newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService(
    	new ThreadPoolExecutor(
        	1,
            1,
            0L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>()	// 无界队列
        )
    );
}
```

首先通过工厂方法创建了一个数量为 1 的“固定大小的线程池”，然后使用 `FinalizableDelegatedExecutorService` 对该“固定大小的线程池”进行**==包装==**，这一层包装的作用是防止线程池的 `corePoolSize` 被动态地修改。例如下面的代码：

```java
public void testSingleThreadExecutor() {
    ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);
    // 对 fixedExecutorService 进行强制转换
    ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;
    // 修改核心线程数
    threadPoolExecutor.setCorePoolSize(8);

    ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();
    // 强制类型转换会抛出异常：java.lang.ClassCastException
    ((ThreadPoolExecutor) singleExecutorService).setCorePoolSize(8);
}
```

使用 `newSingleThreadExecutor` 的问题同样在于使用的是无界队列，如果任务提交速度大于处理速度，就会造成队列容量急剧增大，最后导致 OOM 异常。

#### 3.newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(
    	0,
        Integer.MAX_VALUE,
        60L,
        TimeUnit.MILLSECONDS,
        new SynchronousQueue<Runnable>()		// 无界队列
    );
}
```

这里创建了一个核心线程数为 0，最大线程数不设限制的线程池，理论上可以有无数个工作线程。“可缓存线程池”使用的是 `SynchronousQueue` 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递。正因为可以无限制创建线程，不会有任务等待，所以才使用 `SynchronousQueue`。



## 6.确定线程池的线程数

## 7.ThreadLocal原理与实战



