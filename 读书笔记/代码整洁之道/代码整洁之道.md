# 代码整洁之道

- 写函数时不要在意一开始的冗长和复杂，写完后通过打磨代码，分解函数，消除重复，拆散类等方式使代码变得整洁
- 在最后修改前，可以先编写出测试代码，每次修改确保测试都能通过



## 1.命名

1. 名字要**名副其实，不要怕长**，例如：

   - `elapsedTimeIndays` - 消逝的时间（天）

   - `daysSinceCreation` - 创建后经过的天数

   - `fileAgeInDays` - 文件创建的天数

   - `accountGroup` or `bunchOfAccounts` - 一组账号

2. **不要使用小写字母`l`、大写字母`I`，大写字母`O`**，容易造成歧义

3. **不要试图加入数字**来区分名称，例如：`a1`、`a2`

4. 数字可声明为**具有实际的意义的常量**，例如：`MAX_CLASSES_PER_STUDENT`，但是对于`hour = min * 60`来说把 60 定义为常量就很滑稽

5. 类名和对象名应当是名词或名词短语，方法名应当是动词或动词短语，例如：`postPayment`、`deletePage`

6. 创建对象时，**尽量使用静态工厂方法**，可将构造器声明为`private`

7. **每个概念只对应一个词**，例如不要同时出现`fetch`、`get`的明明形式

8. 名称应该说明副作用，下面例子中的方法名应该改为`createOrReturnOos`

   ```java
   public ObjectOutputStream getOos() {
     if (m_oos == null)
       m_oos = new ObjectOutputStream(m_socket.getOutputStream())
     return m_oos;
   }
   ```

## 2.函数

1. **短小**

   最好压缩到 3~4 行，`if`、`while`语句的代码块应该是一个函数调用，函数的缩进不该多于 2 层，例如：

   ```java
   // 方法长度最好不要超过以下代码
   public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
       boolean isTestPage = pageData.hasAttribute("test");
       if (isTestPage) {
           WikiPage testPage = pageData.geWikiPage();
           StringBuilder newPageContent = new StringBuilder();
           includeSetupPages(testPage, newPageContent, isSuite);
           newPageContent.append(pageData.getContent());
           includeTeardownPages(newPageContent.toString());
           pageData.setContent(newPageContent.toString());
       }
       return pageData.getHtml();
   }
   ```

   最好修改为：

   ```java
   public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
       if (isTestPage(pageData))
           includeSetupAndTeardownPages(pageData, isSuite);
       return pageData.getHtml();
   }
   ```

2. **只做一件事**

   一个方法不能再被拆分出任何方法，例如：

   ```java
   public void pay() {
     for (Employee e : employees) {
       Money pay = e.calculatePay();
       e.deliverPay(pay);
     }
   }
   ```

   改为三个方法：

   ```java
   public void pay() {
     for (Employee e : employees)
     	payIfNecessary(e);
   }
   
   private void payIfNecessary(Employee e) {
     if (e.isPayday())
       calculateAndDeliverPay(e);
   }
   
   private void calculateAndDeliverPay(Employee e) {
     Money pay = e.calculatePay();
     e.deliverPay(pay);
   }
   ```

3. 对于`switch`语句，尽量**只用于创建多态对象**，例如：

   ```java
   public Money calculatePay(Employee e) throws InvalidEmployeeType {
       switch (e.type) {
           case COMMISSIONED:
               return calculateCommisionedPay(e);
           case HOURLY:
               return calculateHourlyPay(e);
           case SALARIED:
               return calculateSalariedPay(e);
           default:
               throw new InvalidEmployeeType(e.type);
       }
   }
   ```

   上面的方法违反了单一职责原则（判断配型 + 计算工资）和开放封闭原则（每增加一种类型就要修改依次），同时相应的还可能会有其他类似的方法，例如`isPayday()`、`deliverPay()`等都需要用到`switch`。

   解决方法为将`switch`埋到抽象工厂中：

   ```java
   public abstract class Employee {
       public abstract boolean isPayday();
       public abstract Money calculatePay();
       public abstract void deliverPay(Money pay);
   }
   
   public interface EmployeeFacotry {
       public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
   }
   
   public class EmployeeFactoryImpl implements EmployeeFactory {
       public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
           switch (r.type) {
               case COMMISSIONED:
                   return new CommissionedEmployee(r);
               case HOURLY:
                   return new HourlyEmployee(r);
               case SALARIED:
                   return new SalariedEmployee(r);
               default:
                   throw new InvalidEmployeeType(r.type);
           }
       }
   }
   ```

4. **函数参数不要多于 3 个**

   - 一元参数

     传入单个参数有两种普遍的理由：

     1. 将传入的参数转换为其他东西再输出，例如：

        ```java
        boolean fileExists(String fileName) {}
        ```

     2. 根据传入的参数（看作事件）修改系统状态，且传入的参数要明确**事件**的含义，例如：

        ```java
        void posswordAttemptFailedNtimes(int attempts) {}
        ```

     如果函数要对参数进行转换，转换结果就应该体现为返回值。

     ```java
     StringBuffer transform(StringBuffer in) {}
     ```

     ````java
     void transform(StringBuffer out)
     ````

     上面的代码要优于下面的。

   - 标识参数（布尔类型）

     避免传入标识参数，那样则表示方法至少做了两件事：true 则这样做，false 则那样做。例如：

     ```java
     void render(Boolean isSuite) {}
     ```

     改为两个方法：

     ```java
     void renderForSuite() {}
     void renderForSingleTest() {}
     ```

   - 二元参数

     尽管二元参数问题不大，但有时它比一元难懂，例如：

     ```java
     void writeField(String name) {}
     ```

     ```java
     void writeField(OutputStream outputStream, String name) {}
     ```

     第一个方法更易于理解。

     可以将`writeField`写成`outputStream`的成员方法。还可以分离出类似`FieldWriter`的类，在其构造器中传入`outputStream`，并提供一个`writeField(name)`的方法。

   - 三元参数

     三元参数有时就比较难理解，例如：

     ```java
     void assertEquals(String message, Object expected, Object actual) {}
     ```

     上面的方法很容易就搞乱参数的顺序。

   - 三个以上

     如果函数需要 3 个以上参数，就说明其中一些参数应该封装为类了，例如：

     ```java
     Circle makeCircle(double x, double y, double radius);
     ```

     ```java
     Circle makeCircle(Point center, double radius);
     ```

5. **动词与关键词**

   方法名和参数名应当是一种良好的动词/名词对形式，例如：

   ```java
   void assertEqual(Object expected, Object actual) {}
   ```

   改成：

   ```java
   void assertExpectedEqualsActual(Object expected, Object actual) {}
   ```

6. **分隔指令与询问**

   函数要么做什么，要么回答什么，例如：

   ```java
   if(CheckIfExistsAndSet("username", "youyi")) {}
   ```

   改为：

   ```java
   if(attributeExists("username")) {
       setAttribute("username", "youyi");
   }
   ```

7. **使用异常代替返回错误码**

   返回错误码通常暗示某处有个类或者是枚举，其他许多类都得导入和使用它，当枚举类修改时，所有依赖的类都需要重新编译和部署。使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或部署。

8. **抽离`try/catch`代码块**

   ```java
   public void delete(Page page) {
       try {
           deletePageAndAllReferences(page);
       } catch (Exception e) {
           logError(e);
       }
   }
   private void deletePageAndAllReferences(page page) throws Exception {
       deletePage(page);
       registry.deleteReference(page.name);
       configKeys.deleteKey(page.name.makeKey());
   }
   
   private void logError(Exception e) {
       logger.log(e.getMessage());
   }
   ```

9. **会使用到多态的话就不要使用静态函数**

## 3.注释

- 唯一真正好的注释是想办法不去写的注释。例如：

  ```java
  // Returns an instance of the Responder being tested.
  protected abstract Responder responderInstance();
  ```

  只需要把函数重命名为`responderBeingTested`，注释就是多余的。

- `TODO`注释有时是必要的
- 可以用于提示信息和警告
- 盲目的让开发者给每个函数都写上注释只会让代码变得散乱
- 最终发布时不要留下注释代码

## 4.格式

- 被调用的函数应该放在执行调用的函数下面

- 对方法的执行顺序有要求时可以通过传参的形式进行约束

  ```java
  public void life() {
    born();
    walk();
    run();
  }
  ```

  更好的方法是：

  ```
  public void life() {
  	Infant infant = born();
  	Teenager teenager = walk(infant);
  	run(teenager);
  }

- **避免传递浏览**

  根据迪米特法则，代码中不应出现`a.getB().getC()`的代码，a 不应该了解 C 的信息，应直接让协作者提供所需的功能，简而言之，使用时仅遵照`method.doSometing()`即可。
  
- 如果`if`或`while`的方法体只有一行，可以不使用`{}`

  ```java
  if (true)
      // do something
      return;
  else
      // do something
  ```

- **封装条件**

  `if(shouldBeDeleted(time))`好于`if(time.hasExpired() && !time.isRecurrent())`。

- 避免使用非`!`逻辑

## 5.对象和数据结构

- 不要一股脑全加上`setter`、`getter`，只暴露需要暴露的数据

  迪米特法则：模块不应了解他所操作对象的内部情形，例如：

  ```java
  // 将具体的数据隐藏在抽象之后
  public interface Vehicle {
      // 只暴露剩余百分比，隐藏具体的数据
      public double getPercentFuelRemaining();
  }
  ```

- 合理运用**过程式代码风格**和**面向对象代码风格**

  过程式代码风格

  ```java
  public class Square {
      public Point topLeft;
      public double side;
  }
  
  public class Circle {
      public Point center;
      public double radius;
  }
  
  public class Geometry {
      public final double PI = 3.14159;
      
      public double area(Object share) {
          if (shape instanceof Square) {
              Square s = (Square) share;
              return s.side * s.side;
          }
          else if (share instanceof Circle) {
              Circle c = (Circle) share;
              return PI * c.radius * c.radius;
          }
      }
  }
  ```

  面向对象代码风格

  ```java
  public class Square implements Shape {
      private Point topLeft;
      private double side;
      
      public  double area() {
          return side * side;
      }
  }
  
  public class Circle implements Shape {
      private Point center;
      private double radius;
      public final double PI = 3.14159;
      
      public double area() {
          return PI * radius * radius;
      }
  }
  ```

  可以发现，过程式代码便于在不改动既有数据结构的前提下添加新函数（例如在 Geometry 中添加计算周长的函数）；面向对象代码便于在不改动既有函数的前提下添加新类（例如添加一个三角形的类）。

- 区分**数据结构**（只包含成员变量和相应的`getter`、`setter`方法）和**对象**（包含业务逻辑）

## 6.错误处理

- 使用受检异常，就需要在 catch 语句和抛出异常处之间的每个方法签名中声明该异常；并且破坏了封装性，因为在抛出路径中的每个函数都要去了解下一层级的异常情况

- 堆栈踪迹无法告诉你异常的根本原因，最好创建信息充分的异常消息

- **将第三方 API 打包**

  有时第三方 API 会抛出各种异常：

  ```java
  ACEMPort port = new ACMEPort();
  try {
      port.open();
  } catch (Exception1 e) {
      reportPortError(e);
  } catch (Exception2 e) {
      reportPortError(e);
  } catch (Exception3 e) {
      reportPortError(e);
  } finally {}
  ```

  我们可以打包调用 API，确保它返回通用异常类型：

  ```java
  public class LocalPort {
      private ACEMPort innerPort;
  
      public LocalPort(ACEMPort acemPort) {
          innerPort = acemPort;
      }
  
      public void open() {
          try {
              innerport.open();
          } catch (Exception1 e) {
              throw new PortDeviceFailure(e);
          } catch (Exception2 e) {
              throw new PortDeviceFailure(e);
          } catch (Exception3 e) {
              throw new PortDeviceFailure(e);
          }
      }
  }
  ```

  从而简化调用代码：

  ```java
  LocalPort port = new LocalPort(new ACMEPort());
  try {
      port.open();
  } catch (PortDeviceFailure e) {
      reportError(e);
  } finally {}
  ```

- 不要返回 null，返回一个空对象

- 不要为方法传递 null 值

## 7.边界隔离

- 当第三方 API 还未开发完成时，灵活使用**适配器模式**保证不影响己开发进度

## 8.测试

- 保持整洁，遵循**构造 - 操作 - 检验**的模式，即先构造测试数据，再操作测试数据，最后检验测试结果，每个过程单独封装成一个方法

  > **测试的一种角度**
  >
  > ```java
  > @Test
  > void turnOnLoTempAlarmAtThreadshold() throws Excepiont {
  >     wayTooCold();
  >     assertEquals("HBchL", hw.getState());
  > }
  > ```
  >
  > 上述代码中，`HBchL`表示各项测试结果，大写表示相应的项目是"打开"状态，小写表示"关闭"，依次是{heater, blower, cooler, hi-temp-alarm, lp-temp-alarm}。
  >
  > ```java
  > public String getState() {
  >     String state = "";
  >     state += heater ? "H" : "h";
  >     ...
  >     return state;
  > }
  > ```

- 每个单元测试的断言数量应该最小化，可以放入超过 1 个断言

- 各个测试间相互独立

## 9.类

- 类中声明顺序应该按照：公共静态变量、私有静态变量、私有实体变量、公共函数、公共函数调用的私有函数应该紧随该公共函数
- **职责单一原则**，系统应该由许多短小的类而不是少量巨大的类组成
- 类应该只有少量实体变量
- 当出现了只与类的一小部分有关的私有方法时，意味着存在改进空间，如将该方法相关的部分抽取出单独的类
- **依赖倒转原则**，类应当依赖于抽象而不是具体的实现细节

- 将类的构造与使用分开，可将全部构造过程放到一个方法中

- 如果使用了来自同一程序包的多个类，使用`import package.*`来解耦合，导入语句只是载搜寻名称时把这个包列入查找路径
- 不要继承常量类
- 使用枚举替代`public static final int`

## 10.多线程

- 对于 IO 密集型任务，例如套接字、数据库连接、等待虚拟交换等场景，增加线程数量可以提高处理速度

- 对于 CPU 密集型任务，例如数值计算、正则表达式处理、垃圾回收等场景，增加线程数量不会有明显提升

- 对于 N 步指令和 T 个线程，共有`(N*T)!/(N!**T)`种可能的情况，对于 N=3，T=3，结果就是`9!/6^3=1680`

- 根据 Java 内存模型，32 位（int 类型）的赋值操作是原子的，如果是 long 类型（64 位）的赋值操作则需要两次来完成

- 合理设计线程数

  如果要进行一个页面读取和解析的任务，获取一个页面的 IO 时间平均为 1S，解析一个页面的处理时间是 0.5S，则创建 3 个线程用于获取页面可以达到最佳的吞吐量：

  <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202301272223109.jpg" alt="img334" style="zoom:80%;" />

- 死锁发生的条件

  - **互斥**

    场景：当多个线程需要使用同一个资源，且这些资源无法同时被多个线程占用并有数量限制。

    解决方法：使用允许同时使用的资源，如`AtomicInteger`；增加资源数量。

  - **上锁及等待**

    场景：某个线程获取到资源后在完成工作前不会释放，其他线程无法夺取资源，只能等待释放。

    解决方法：拒绝等待，获取资源前检查资源，如果遇到繁忙资源就释放所有自身持有资源重新来。

    但这种解决方法会造成**线程饥饿**和**活锁**的问题。

    > **线程饥饿**
    >
    > 某个线程一直无法获得所需的资源（可能同时需要某些很少能同时获得的资源），会导致 CPU 利用率较低。
    >
    > **活锁**
    >
    > 几个线程同时想要获得某个资源，但是无法获取到并不断的重复释放自身持有的资源和尝试获取，会导致无效的较高的 CPU 利用率。

  - **循环等待**

    场景：两个线程互相持有对方需要的资源，并等待对方释放锁。

    解决方法：让所有线程按照同一次序获取资源。

    

  