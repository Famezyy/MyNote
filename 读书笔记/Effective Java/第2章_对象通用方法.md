# 第2章_对象通用方法

尽管`Object`是一个具体类，但设计它主要是为了扩展。它所有的非`final`方法（`equals`、`hashCode`、`t oString`、`clone`和`finalize`）都有明确的通用约定，因为它们设计成是要被覆盖的。任何一个类在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如`HashMap`和`HashSet`）就无法正常运作。

本章将讲述何时以及如何覆盖这些非`final`的`Object`方法。本章不再讨论`finalize`方法，因为<a href="第1章_创建和销毁对象.md#8">第8条</a>已经讨论过这个方法了。而`Comparable.compareTo()`虽然不是`Object`方法，但是本章也将对它进行讨论，因为它具有类似的特征。

## 10.覆盖equals时请遵守通用约定
覆盖`equals`方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问题的办法就是不覆盖`equals`方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，这就正是所期望的结果：
- **类的每个实例本质上都是唯一的**

  对于代表活动实体而不是值的类来说确实如此，例如`Thread`。`Object`提供的`equals`实现对于这些类来说正是正确的行为。

- **类没有必要提供“逻辑相等”的测试功能**

  例如，`java.util.regex.Pattern`可以覆盖`equals`，以检查两个`Patter`实例是否代表同一个正则表达式，但是设计者并不认为客户需要或者期望这样的功能。在这类情况之下，从`Object`继承得到的`equals`实现已经足够了。

- **超类已经覆盖了`equals`，超类的行为对于这个类也是合适的**

  例如，大多数的`Set`实现都从`Abstract Set`继承`equals` 实现，`List`实现从`AbstractList`继承`equals`实现，`Map`实现从`AbstractMap`继承`equals`实现。

- **类是私有的，或者是包级私有的，可以确定它的`equals`方法永远不会被调用**

  如果你非常想要规避风险，可以覆盖`equals`方法，以确保它不会被意外调用：

  ```java
  public boolean equals(Object o) {
      // method is never called
      throw new AssertError();
  }
  ```

那么，什么时候应该覆盖`equals`方法呢？如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖`equals`。这通常属于“值类”的情形。值类仅仅是一个表示值的类，例如`Integer` 或者`String`。程序员在利用`equals`方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足程序员的要求，不仅必须覆盖`equals`方法，而且这样做也使得这个类的实例可以被用作映射表的键(`map`的`key`)，或者集合的元素，使映射或者集合表现出预期的行为。

有一种“值类”不需要覆盖`equals`方法，即用单例（详见第 1 条）确保“每个值至多只存在一个对象”的类。枚举类型（详见第 34 条）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此`Object`的`equals`方法等同于逻辑意义上的`equals`方法。

在覆盖`equals`方法的时候，必须要遵守它的通用约定。下面是约定的内容，来自`Object`的规范。

`equals`方法实现了等价关系，其属性如下：
- **自反性（reflexive）**：对于任何非 null 的引用值 x，`x.equals(x)`必须返回 true。
- **对称性（symmetric）**：对于任何非 null 的引用值 x 和 y，当`y.equals(x`)返回 true 时，`x.equals(y)`必须返回true。
- **传递性（transitive）**：对于任何非 null 的引用值 x、y 和 z，如果`x.equals(y)`返回 true ，并且`y.equals(z)`也返回 true，那么`x.equals(z)`也必须返回 true。
- **一致性（consistent）**：对于任何非 null 的引用值 x 和 y，只要`equals`的比较操作在对象中所用的信息没有被修改，多次调用`x.equals(y)`就会一致地返回 true，或者一致地返回 false。
- 对于任何非 null 的引用值 x，`x.equals(null)`必须返回 false。

除非你对数学特别感兴趣，否则这些规定看起来可能有点让人感到恐惧，但是绝对不要忽视这些规定！如果违反了，就会发现程序将会表现得不正常，甚至崩溃，而且很难找到失败的根源。有许多类，包括所有的集合类在内，都依赖于传递给它们的对象是否遵守了`equals`约定。

那么什么是等价关系呢？不严格地说，它是一个操作符，将一组元素划分到其元素与另一个元素等价的分组中。这些分组被称作等价类。从用户的角度来看，对于有用的`equals`方法，每个等价类中的所有元素都必须是可交换的。现在我们按照顺序逐一查看以下 5 个要求。

### 10.1 自反性

第一个要求仅仅说明对象必须等于其自身。假如违背了这一条，然后把该类的实例添加到集合中，该集合的`contains`方法将果断地告诉你，该集合不包含你刚刚添加的实例。

### 10.2 对称性
第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。例如下面的类，它实现了一个不区分大小写的字符串，在`equals`操作中忽视了大小写。
```java
public final class CaseInsensitiveString {
    private final String s;
    
    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }
    
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        }
        if (o instanceof String) {
            return s.equalsIgnoreCase((String) o);
        }
        return false;
    }
}
```
在这个类中，`equals`方法企图与普通的字符串对象进行比较操作。假设我们有一个`CaseInsensitiveString`的字符串和一个普通的字符串：
```java
CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish";
```
不出所料，`cis.equals(s)`返回 true。问题在于，虽然`CaseinsensitiveString`类中的`equals`方法知道普通的字符串对象，但是，`String`类中的`equals`方法却并不知道不区分大小写的字符串。因此，`s.equals(cis)`返回 false，这显然违反了对称性。假设你把不区分大小写的字符串对象放到一个集合中：
```java
List<CaseInsensitiveString> list = new ArrayList<>();
list.add(cis);
```
此时`list.contains(s)`会返回什么结果呢？没人知道。在当前的 OpenJDK 实现中，它碰巧返回 false，但这只是这个特定实现得出的结果而已。在其他的实现中，它有可能返回 true，或者抛出一个运行时异常。**一旦违反了`equals`约定，当其他对象面对你的对象时，你完全不知道这些对象的行为会怎么样**。

为了解决这个问题，只需把企图与`String`的比较操作的这段代码从`equals`方法中去掉就可以了。这样做之后，就可以重构该方法，使它变成一条单独的返回语句：
```java
@Override
public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &&
        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```
### 10.3 传递性

`equals`约定的第三个要求是，如果一个对象等于第二个对象，而第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。违背传递性往往多发生在有子类继承时。假设在子类中添加了一个新的属性，就会有可能违背传递性。我们首先以一个简单的不可变的二维整数型 Point 类作为开始：
```java
public class Point {
    private final int x;
    private final int y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point)) {
            return false;
        }
        Point p = (Point) o;
        return p.x = x && p.y = y;
    }
}
```
假设你想要扩展这个类，为其添加颜色信息：
```java
public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }
}
```
如果完全不重写`equals`方法，而是直接从 Point 继承过来，在`equals`做比较的时候颜色信息就被忽略掉了。虽然这样做不会违反`equals`约定，但很明显这是无法接受的。但假设编写了一个`equals`方法，只有当它具有同样的位置和颜色时，它才会返回 true，此时也会有新的问题:
```java
@Override
public boolean equals(Object o) {
    if (!(o instanceof ColorPoint)) {
        return false;
    }
    return super.equlas(o) && ((ColorPoint) o).color == color;
}
```
这个方法的问题在于，在比较普通点和有色点，以及相反的情形时，可能会得到不同的结果。前一种比较忽略了颜色信息，而后一种比较则总是返回 false，因为参数的类型不正确。为了直观地说明问题所在，我们创建一个普通点和一个有色点：
```java
Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED); 
```
然后，`p.equals(cp)`返回 true，`cp.equals(p)`则返回 false。你可以做这样的尝试来修正这个问题，让`ColorPoint.equals`在进行“混合比较”时忽略颜色信息：
```java
@Override
public boolean equals(Object o) {
    if (!(o instanceof Point)) {
        return false;
    }
    // if o is a normal Point
    if(!(o instanceof ColorPoint)) {
        return o.equals(this);
    }
    // o is a ColorPoint, do a full comparison
    return super.equals(o) && ((ColorPoint) o).color == color;
}
```
这种方法确实提供了对称性，但是却牺牲了传递性：
```java
ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new CoporPoint(1, 2, COlor.BLUE);
```
此时，`p1.equals(p2)`和`p2.equals(p3)`都返回 true，但是`p1.equals(p3)`则返回 false，很显然这违反了传递性。前两种比较不考虑颜色信息，而第三种比较则考虑了颜色。

此外，这种方法还可能导致无限递归问题：假设 Point 有两个子类，如  ColorPoint 和 SmellPoint，它们各自都带有这种 equals 方法。那么执行`myColorPoint.equals(mySmellPoint)`将会抛出`StackOverflowError`异常。

那该怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。**我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留`equals`约定**，除非愿意放弃面向对象的抽象所带来的优势。

你可能听说过，在`equals`方法中用`getClass`测试代替`instanceof`测试，可以扩展可实例化的类和增加新的值属性，同时保留`equals`约定：
```java
@Override
public boolean equlas(Ojbect o) {
    if (o == null || o.getClass() != getClass()) {
        return false;
    }
    Point p = (Point) o;
    return p.x = x && p.y = y;
}
```
这段程序只有当对象具有相同的实现类时，才能使对象等同。虽然这样也不算太糟糕，但结果却是无法接受的：Point 子类的实例仍然是一个 Point，应该进行进一步比较，但是如果采用了这种方法，它就永远返回 false！假设我们要编写一个方法，以检验某个对象是否位于集合中。下面是可以采用的其中一种方法：
```java
private static final Set<Point> unitCircle = Set.of(
    new Point(1, 0),
    new Point(0, 1),
    new Point(-1, 0),
    new Point(0, -1);
);
public static boolean onUnitCircle(Point p) {
    return unitCircle.contains(p);
}
```
虽然这可能不是实现这种功能的最快方式，不过它的效果很好。但是假设你通过某种不添加值组件的方式扩展了 Point，例如让它的构造器记录创建了多少个实例：
```java
public class CounterPoint extends Point {
    private static final AtomicInteger counter = new AtomicInteger();
    
    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }
    
    public static int numberCreated() {
        return counter.get();
    }
}
```
里氏替换原则认为，父类能正常工作的地方子类同样应该正常运行，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。例如这里 Point 和CounterPoint 就需要满足里氏替换原则。但是假设我们将 CounterPoint 实例传给了`onUnitCircle`方法，而如果 Point 类使用了基于`getClass`的`equals`方法，无论 CounterPoint 实例的 x 和 y 值是什么，`onUnitCircle`都会返回 false。这是因为`HashSet`是利用`equals`方法检验包含条件。但是，如果在 Point 上使用适当的基于`instanceof`的`equals`方法，当遇到 CounterPoint 时，相同的`onUnitCircle`方法就会工作得很好。

虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计：遵从第 18 条**复合优先于继承**的建议。我们不再让 ColorPoint 扩展 Point，而是在 ColorPoint 中加入一个私有的`Point域`以及一个公有的获得该域方法（详见第 6 条），此方法返回一个与该有色点处在相同位置的普通 Point 对象：
```java
public class ColorPoint {
    private final Point point;
    private final Color color;
    
    public ColorPoint(int x, int y, Color color) {
        point = new Point(x, y);
        this.color = Objects.requiredNonNull(color);
    }
    
    public Point point() {
        return point;
    }
    
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof ColorPoint)) {
            return false;
        }
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) && cp.color.equals(color);
    }
}
```
在 Java 平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，`java.sql.Timestamp`对`java.util.Date`进行了扩展，并增加了`nanoseconds`域。`Timestamp`的`equals`实现确实违反了对称性，如果`Timestamp`和`Date`对象用于同一个集合中，或者以其他方式被混合在一起，则会产生意想不到的错误。`Timestamp`类有一个免责声明，告诫程序员不要混合使用`Date`和`Timestamp`对象。只要你不把它们混合在一起，就不会有麻烦，除此之外没有其他的更好的办法，而且结果导致的错误将很难调试。`Timestamp`类的这种行为是个错误，不值得仿效。

注意，你可以在一个抽象类的子类中增加新的值组件且不违反`equals`约定。对于根据第 23 条的建议而得到的那种类层次结构来说，这一点非常重要。例如，你可能有一个抽象的 Shape 类，它没有任何值组件， Circle 子类添加了一个`radius`域，`Rectangle`子类添加了`length`和`width`域。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。

### 10.3 一致性

`equals`约定的第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象（或者两个都）被修改了。换句话说，可变对象在不同的时候可以与不同的对象相等，而不可变对象则不会这样。当你在写一个类的时候，应该仔细考虑它是否应该是不可变的（详见第 17 条）。如果认为它应该是不可变的，就必须保证`equals`方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。

无论类是否是不可变的，都不要使`equals`方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，`java.net.URL`的`equals`方法依赖于对 URL 中主机 IP 地址的比较。将一个主机名转变成 IP 地址可能需要访问网络，随着时间的推移，就不能确保会产生相同的结果， 即有可能 IP 地址发生了改变。这样会导致 URL 的`equals`方法违反`equals`约定，在实践中有可能引发一些问题。URL的`equals`方法的行为是一个大错误并且不应被模仿。遗憾的是，因为兼容性的要求，这一行为元法被改变。为了避免发生这种问题，`equals`方法应该对驻留在内存中的对象执行确定性的计算。

### 10.4 非空性

最后一个要求没有正式名称，我姑且称它为“非空性”，意思是指所有的对象都不能等于 null。尽管很难想象在什么情况下`a.equals(null)`调用会意外地返回 true，但是意外抛出`NullPointerException`异常的情形却不难想象。通用约定不允许抛出`NullPointerException`异常。许多类的`equals`方法都通过一个显式的`null`测试来防止这种情况：
```java
@Override
public boolean equals(Object o) {
    if (o == null) {
        return false;
    }
}
```
这一步其实是不需要执行的。为了测试其参数的等同性，`equals`方法必须先把参数转换成适当的类型，以便可以调用它的访问方法，或者访问它的域。所以往往在进行转换之前，`equals`方法都会使用`instanceof`操作符，检查其参数的类型是否正确：
```java
@Override
public boolean equals(Object o) {
    if (!(o instanceof MyType)) {
        return false;
    }
    MyType mt = (MyType) o;
}
```
如果漏掉了这一步的类型检查，并且传递给`equals`方法的参数又是错误的类型，那么`equals`方法将会抛出`ClassCastException`异常，这就违反了`equals`约定。但是，如果`instanceof`的第一个操作数为 null，那么，不管第二个操作数是哪种类型，`instanceof`操作符都指定应该返回 false。因此，如果把 null 传给`equals`方法，类型检查就会返回 false，所以不需要进行显式的 null 检查。

### 10.5 总结
结合所有这些要求，得出了以下实现高质量 equals 方法的诀窍：
1. 使用`==`操作符检查“对象的引用是否相同”。如果是，则返回 true。

2. 使用`instanceof`操作符检查“参数是否为正确的类型”。如果不是，则返回 false。

   > 一般说来，所谓“正确的类型”是指`equals`方法所在的那个类，某些情况下是指该类所实现的某个接口。如果接口改进了`equals`约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口如`Set`、`List`、`Map`和`Map.Entry`具有这样的特性。
3. 把参数转换成正确的类型。转换之前进行`instanceof`测试。

4. 对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。

   > 如果这些检测全部成功，则返回 true；否则返回 false。如果第 2 步中的类型是个接口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问参数中的域，这要取决于它们的可访问性。

对于既不是`float`也不是`double`类型的基本类型域，可以使用`==`操作符进行比较；对于对象引用域，可以递归地调用`equals`方法；对于`float`域，可以使用静态`Float.compare(float, float)`方法；对于`double`域，则使用`Double.compare(double, double)`。对`float`和`double`域进行特殊的处理是有必要的，因为存在着`Float.NaN`、`-0.0f`以及类似的`double`常量；虽然可以用静态方法`Float.equals()`和`Double.equals()`对`float`和`double`域进行比较，但是每次比较都要进行**自动装箱**，这会导致性能下降。对于数组域，则要把以上这些指导原则应用到每一个元素上。如果数组域中的每个元素都很重要，就可以使用其中一个`Arrays.equals()`方法。

有些对象引用域包含`null`可能是合法的，所以，为了避免可能导致`NullPointerException`异常，则使用静态方法`Objects.equals(Object, Object)`来检查这类域的等同性。

对于有些类，比如前面提到的`CaseInsenstiveString`类，域的比较要比简单的等同性测试复杂得多。如果是这种情况，可能需要保存该域的一个“范式”，这样`equals`方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（详见第 17 条）是最为合适的；如果对象可能发生变化，就必须使其范式保持最新。

域的比较顺序可能会影响`equals`方法的性能。为了获得最佳的性能，应该**最先比较最有可能不一致的域**，或者是开销最低的域，最理想的情况是两个条件同时满足的域。不应该比较那些不属于对象逻辑状态的域，例如用于同步操作的 Lock 域。也不需要比较衍生域，因为这些域可以由“关键域”计算获得，但是比较衍生域有时可能会提高 equals 方法的性能。如果衍生域代表了整个对象的综合描述，比较这个域可以节省在比较失败时去比较实际数据所需要的开销。例如，假设有一个 Polygon 类，并缓存了该面积。如果两个多边形有着不同的面积，就没有必要去比较它们的边和顶点。

在编写完`equals`方法之后，应该问自己三个问题：它是否是**对称的**、**传递的**、**一致的**。并且不要只是自问，还要编写单元测试来检验这些特性，除非用 AutoValue 生成`equals`方法，在这种情况下就可以放心地省略测试，如果答案是否定的，就要找出原因，再相应地修改`equals`方法的代码。当然，`equals`方法也必须满足其他两个特性（自反性和非空性），但是这两种特性通常会自动满足。

根据上面的诀窍构建`equals`方法的具体例子，请看下面这个简单的 PhoneNurnber 类：

```java
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
    
    public PhoneNumber(int areaCode, int prefix, int lineNum) {
        this.areaCode = rangeCheck(areaCode, 999, "area code");
        this.prefix = rangeCheck(prefix, 999, "prefix");
        this.lineNum = rangeCheck(lineNum, 9999, "line num");
    }
    
    private static short rangeCheck(int val, int max, String arg) {
        if (val < 0 || val > max) {
            thorw new IllegalArgumentException(arg + ": " + val);
            return (short) val;
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof PhoneNumber)) {
            return false;
        }
        PhoneNumber pn = (PhoneNumber)o;
        return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode = areaCode;
    }
}
```

下面是最后的一些告诫：

- **覆盖`equals`时总要覆盖`hashCode`（详见第 11 条）**

- **不要让`equals`方法过于臃肿**

  如果只是简单地测试域中的值是否相等，则不需要遵守`equals`约定。如果想过度地去寻求各种等价关系，很容易陷入麻烦 之中。把任何一种别名形式考虑到等价的范围内，往往不会是个好主意。例如，File 类不应该试图把指向同一个文件的符号链接当作相等的对象来看待。所幸 File 类没有这样做。

- **不要将`quals`声明中的`object`对象替换为其他的类型**

  程序员编写出下面这样的`equals`方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作：

  ```java
  // parameter type must be Object!
  public boolean equals(MyClass o) {   
  }
  ```

  问题在于，这个方法并没有覆盖`Object.equals`，因为它参数应该 Object 类型，相反，它重载了`Object.equals`（详见第 52 条）。`@Override`注解可以防止犯这种错误（详见第 40 条）。 加上注解后`equal`方法不能编译，错误消息会告诉你到底哪里出了问题。

编写和测试`equals` （及`hashCode`）方法都是十分烦琐的，得到的代码也很琐碎。代替手工编写和测试这些方法的最佳途径是使用 Google 源的 AutoValue 框架，它会自动替你生成这些方法，通过注解就能工作。在大多数情况下，AutoVaue 生成的方法本质上与你亲自编写的方法是一样的。

IDE 也有工具可以生成`equals`和`hashCode`方法，但得到的源代码比使用 AutoValue 更加冗长，可读性也更差，它无法自动追踪类中的变化。但是让 IDE 生成`equals`及`hashCode`方法通常优于手工实现它们。

总而言之，不要轻易覆盖`equals`方法，除非迫不得已。因为在许多情况下，从 Object 处继承的实现正是你想要。如果覆盖`equals`，一定要比较这个类的所有关键域，并且查看它是否遵守`equals`合约的所有五个条件。

## 11.覆盖equals时总要覆盖hashCode

**在每个盖了`equals`方法的类中，都必须覆盖`hashCode`方法**。如果不这样做的话，就会违反`hashCode`的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这类集合包括`HashMap`和`HashSet`。下面是约定的内容，摘自 Object 规范：

- 在应用程序的执行期间，只要对象的`equals`方法的比较操作所用到的信息没有被修改，那么对同一个对象多次调用`hashCode`方法都必须始终返回同一个值。在两个应用程序执行过程中执行`hashCode`方法所返回的值可以不一致。
- 如果两个对象根据`equals(Object)`方法比较是相等的，那么调用这两个对象中的`hashCode`方法返回值也必须一致。
- 如果两个对象根据`equals(Object)`方法比较是不相等的，那么调用这两个对象中的`hashCode`方法不要求一定不同。但是程序员应该知道，不相等的对象产生不同的`hashCode`值，有可能提高散列表（HashTable）的性能。

因没有覆盖`hashCode`而违反的关键约定是第二条：相等的对象必须具有相等的`hashCode`值。根据类的`equals`方法，两个截然不同的实例在逻辑上有可能是相等的，但是 Object 类的`hashCode`方法往往会返回两个不同的随机的整数。

假设在`HashMap`中用第 10 条中出现过的 PhoneNumber 类的实例作为键：

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5409), "Jenny");
```

此时，你可能期望`m.get(new PhoneNumber(707, 867, 5309))`会返回 Jenny，但它实际上返回的是 null。注意，这里涉及两个 PhoneNumber 实例：第一个被插入 HashMap 中，第二个实例与第一个逻辑上相等，用于从 Map 中根据 PhoneNumber 去获取用户名字。由于 PhoneNumber 类没有覆盖`hashCode`方法，从而导致两个逻辑上相等的实例具有不相等的`hashCode`，违反了`hashCode`的约定。因此，`put`方法把电话号码对象存放在一个散列桶（hash bucket）中， `get`方法却在另一个散列桶中查找这个电话号码。即使这两个实例正好被放到同一个散列桶中，`get`方法也必定会返回 null，因为 HashMap 有一项优化，可以将每个项的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性。

修正这个问题非常简单，只需为 PhoneNumber 类提供一个适当的`hashCode`方法即可。编写一个合法但并不好用的`hashCode`方法并没有任何价值。例如下面这个方法总是合法的，但是确实没有任何用处的：

```java
@Override
public int hashCode() {
    return 42;
}
```

上面这个`hashCode`方法是合法的，因为它确保了相等的对象总是具有同样的散列码。但它也极为恶劣，因为它使得每个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，使散列表退化为链表。它使得本该线性时间运行的程序变成了 以平方级时间在运行。对于规模很大的散列表而言，这会关系到散列表能否正常工作。

一个好的散列函数通常倾向于**为不相等的对象产生不相等的散列码**。这正是`hashCode`约定中第三条的含义。理想情况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的 int 值上。要想完全达到这种理想的情形是非常困难的。幸运的是， 相对接近这种理想情形则并不太困难，下面给出一种简单的解决办法：

1. 声明一个 int 变量并命名为 result，将它初始化为对象中第一个关键域的散列码，如步骤 2.a 中计算所示（如第 10 条所述，关键域是指影响`equals`比较的域）

2. 对剩下的每个关键域 f 都完成以下步骤：

   **a.** 为该域计算 int 类型的散列码 C：

   1. 如果该域是基本类型，则计算`Type.hashCode()`，这里的 Type 是基本类型的装箱类，与 f 的类型相对应
   2. .如果该域是一个对象引用，并且该类的`equals`方法通过递归地调用`equals`的方式来比较这个域，则同样为这个域递归地调用`hashCode`。如果需要更复杂的比较，则为这个域计算一个“范式”，然后针对这个范式调用`hashCode`。如果这个域的值为 null，则返回 0（或者其它某个常数，但通常是 0）
   3. 如果该域是一个数组，则要把每一个元素当作单独的域来处理。递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤 **2.b** 中的做法把这些散列值组合起来。如果数组域中没有重要的元素，可以使用一个常量，但最好不要用 0，如果数组域中的所有元素都很重要，可以使用`Arrays.hashCode`方法。

   **b.** 按照下面的公式，把步骤 **2.a** 中计算得到的散列码 C 合并到 result 中：`result = 31 * result + c`

3. 返回 result

写完了`hashCode`方法之后，问问自己“相等的实例是否都具有相等的散列码”。要编写单元测试来验证你的推断（除非利用 AutoValue 生成`equals`和`hashCode`方法）。

在散列码的计算过程中，可以把衍生域排除在外。换句话说，如果一个域的值可以根据参与计算的其它域值计算出来，则可以把这样的域排除在外。必须排除`equals`比较计算中所有没有用到的域，否则很有可能违反`hashCode`约定的第二条。

步骤 **2.b** 中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似的域，这样的乘法运算就会产生一个更好的散列函数。例如，如果 String 散列函数省略了这个乘法部分，那么只是字母顺序不同的字符串将会有相同的散列码。之所以选择 31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与 2 相乘等价于移位运算。使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。31 有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：`31 * i == (i << 5) - i`。现代的虚拟机可以自动完成这种优化。

现在我们要把上述解决办法用到 PhoneNumber 类中：

```java
@Override
public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

因为这个方法返回的结果是一个简单、确定的计算结果，它的输入只是 PhoneNumber 实例中的三个关键域，因此相等的 PhoneNumber 实例显然都会有相等的散列码。实际上，对于 PhoneNumber 的`hashCode`实现而言，上面这个方法是非常合理的，相当于 Java 类库中的实现。它的做法非常简单，也相当快捷，恰当地把不相等的电话号码分散到不同的散列桶中。

虽然本条目中前面给出的`hashCode`实现方法能够获得相当好的散列函数，但它们并不是最先进的。尽管如此，它们的质量堪比 Java 类库的值类型中提供的散列函数，这些方法对于绝大多数应用程序而言已经足够了。

**Objects 类有一个静态方法**，它接受任意数量的对象，并为它们返回一个散列码。这个方法名为`hash`，它生成的`hashcode`质量与我们介绍的方法差不多，但运行速度更慢一些，因为它创建使用了数组以便接受数目可变的参数， 如果参数中有基本类型，还需要装箱和拆箱。建议只将这类散列函数用于不太注重性能的情况。下面就是用这种方法为 PhoneNumber 的散列函数：

```java
@Override
public int hashCode() {
    return Objects.hash(lineNum, prefix, areaCode);
}
```

如果 类是不可变的，并且计算散列码的开销也比较大，就应该考虑**把散列码缓存在对象内部**，而不是每次请求的时候都重新计算散列码。如果某个类的大多数对象都会被用作散列键（如作为 Map 的 key），就应该在创建实例的时候计算散列码。否则可以选择“延迟初始化”散列码，即一直`hashCode`被第一次调用的时候才初始（见第 83 条）。虽然我们的 PhoneNumber 类不值得这样处理，但是可以通过它来说明这种方法该如何实现。注意`hashCode`域的初始值（在本例中是0）一般不能成为实例的散列码：

```java
// 延迟初始化
private int hashCode;

@Override
public int hashCode() {
    int result = hashCode;
    if (result == 0) {
        result = Short.hashCode(areaCode);
        result = 31 * result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        hashCode = result;
    }
    return result;
}
```

**不要试图从散列码计算中排除掉一个关键域来提高性能**。虽然这样得到的散列函数运行起来可能更快，但是它的效果不见得会好，可能会导致散列表慢到根本无法使用。特别是在实践中，散列函数可能面临大量的实例，而你选择忽略的域的对象间的区分度很高，那么散列函数就可能把所有这些实例映射到极少数的散列码上，原本应该以线性级时间运行的程序，将会以平方级的时间运行。

这不只是一个理论问题。在 Java2 发行版本之前， 一个String 散列函数最多只能使 16 个字符，若长度少于 16 个字符就计算所有的字符，否则就从第一个字符开始，在整个字符串中间隔均匀地选取样本进行计算。对于像 URL 这种层次状名称的大型集合，该散列函数正好体现出了我们所描述的问题。

**不要对 hashCode 方法的返回值做出具体的规定，因此客户端无法理所当然地依赖它**。这样可以为修改提供灵活性。Java 类库中的许多类，比如 String、Integer ，都可以把它们的`hashCode`方法返回的确切值设置为该实例值。一般来说，这并不是个好主意，因为这样做严格地限制了在未来的版本中改进散列函数的能力。如果没有规定散列函数的细节，那么当你发现了它的内部缺陷时，或者发现了更好的散列函数时·，就可以在后面的发行版本中修正它。

总而言之，每当覆盖`equals`方法时都必须覆盖`hashCode`，否则程序将无法正确运行。`hashCode`方法必须遵守 Object 规定的通用约定，并且必须完成一定的工作，将不相等的散列码分配给不相等的实例。这个很容易实现，但是如果不想那么费力，也可以使用前文建议的解决方法。如第 10 条所述， AutoValue 框架提供了很好的替代方法，可以不必手工编写`equals`和`hashCode`方法，并且现在的集成开发环境 IDE 也提供了类似的部分功能。

## 12.始终要覆盖toString
虽然 Object 提供了默认的`toString`方法，但它返回的字符串往往不尽人意：它的格式为`类的名称@散列码（无符号16进制表示）`，例如`PhoneNumber@163b91`。`toString`的通用约定指出，被返回的字符串应该是一个简介但信息丰富，并且易于阅读的表达形式。并且建议所有子类都覆盖这个方法。

提供好的`toString`方法可以使类使用起来更加舒适，也更易于调试。当对象传递给`println`、`printf`、`字符串连接操作（+）`以及`assert`，或者被调试器打印出来时，`toString`方法会被调用。例如当记录错误信息的时候，往往需要打印对象。特别是将对象放到集合中并打印该集合时，相比于`{Jenny=PhoneNumber@163b91}`，`{Jenny=707-867-5309}`更易于阅读。

**在实际应用中，toString 方法应该返回对象中包含的所有关键信息**（Thread 不满足这样的条件）。如果对象太大，则应该返回一个摘要信息。如果字符串的`toString`方法中没有包含对象所有的关键信息，测试失败时将可能得到下面的报告：
```bash
Assersion failure: expected {abc, 123}, but was {abc, 123}.
```
在实现`toString`方法时，可以**在文档中指定返回值的格式**。对于仅含有值的类建议这么做。它可以规范输入输出的格式，可以被记录到文件中（例如 CSV文档）。此时最好在提供一个相匹配的静态工厂或者构造器，用于将规定格式的字符串转换为对象。Java 类库的许多值类都采用了这种做法，例如 BigInteger、BigDecimal 和绝大多数包装类。

指定`toString`返回值的格式也有缺点：**一旦指定格式并应用于生产中就很难再更改**。如果变更的话相应的解析方法、存储文档都需要更新。如果不指定格式的话就可以保留灵活性。鉴于将来在类中增加信息或改进格式。

无论是否决定指定格式，都应该在文档中明确指明。例如，下面是第 11 条中 PhoneNumber 类的 toString 方法：

```java
/**
 * Returns the string representation of this phone number.
 * The string consists of twelve characters whose format is "XXX-YYY-ZZZZ", where XXX is the area code, YYY is the prefix, and ZZZZ is the line number.
 * Each of the capital letters represents a single decimal digit.
 * 
 * If any of the three parts of this phone number is too smaill to fill up its field, the field is padded with leading zeros.
 * For example, if the value of the line number is 123, the last four characters of the string representation will be "0123".
 */
@Override
public String toString() {
    return String.format("%03d-%03d-%04d", areaCode, prefix, lineNum);
}
```
如果不指定格式，那么文档注释也应该做出提示：
```java
/**
 * Returns a brief description of this potion. The exact details of the representation are unspecified and subject to change, but the following may be regarded as typical:
 * "[potion #9: type=love, smell=turpentive, look=india ink]"
 */
@Override
public String toString(){...}
```
无论是否指定格式，都应该提供访问`toString`方法中的信息的途径（例如`Getter`方法），使得程序员不需要仅靠解析`toString`方法的返回值来获得相应的值。

在静态工具类（第 4 条）中编写`toString`方法是没有意义的。也不需要在大多数枚举类型（第 34 条）中编写`toString`方法，因为 Java 已经提供了非常完美的方法。但是如果某个抽象类的子类共用一个通用的字符串表示，一定要在抽象类中编写一个`toString`方法。例如，大多数集合实现中的`toString`方法都继承自抽象类。

虽然 Google 的开源工具`AutoValue`和大多数 IDE 集成开发环境都提供生成`toString`方法，但是其生成的方法并不能表示特殊含义。例如 PhoneNumber 就需要特殊的字符串表示。但其仍然要优于继承自 Object 的`toString`方法。

总之，要在编写的每一个可实例化的类中覆盖 Object 的`toString`方法，除非已经在父类中实现了。其返回值应该是关于对象的简洁的、有意义的描述。

## 13.谨慎地覆盖clone
Cloneable 接口的目的是作为对象的一个 mixin 接口（第 20 条），表明这样的类的对象允许克隆。但是该接口并没有提供`clone`方法，而 Object 中的`clone`方法是`protected`。即使一个类实现了 Cloneable 接口，不借助反射（第 65 条）就无法调用 clone 方法。即使是反射也可能失败，因为无法保证对象具有可访问的`clone`方法。

Cloneable 决定了 Object 中受保护的`clone`方法实现的行为，如果一个类实现了 Cloneable，Object 的`clone`方法就会返回该对象的拷贝，否则就会抛出`CloneNotSupportedException`。这是接口的一种非典型的极端用法，不值得效仿。

尽管规范中没有表明，实际上，实现 Cloneable 的类应该提供一个可访问的克隆方法。为了达到这个目的，类和它的所有超类都必须遵守一个相当复杂的、不可实施的，并且基本上没有文档说明的协议。由此得到一种脆弱的、危险的机制：**无需调用构造器就可以创建对象**。

`clone`方法的通用约定是非常脆弱的，下面是从 Object 规范中复制的：

创建和返回该对象的一个拷贝。这个“拷贝”的精确含义取决于该对象的类。一般的含义是，对于任何对象 x，表达式`x.clone() != x`将会是 true，并且，表达式`x.clone().getClass() == x.getClass()`将会返回 true，但这些都不是绝对的要求。虽然通常情况下，表达式`x.clone().equals(x)`将会是 true，但是，这也不是一个绝对的要求。

按照惯例，此方法返回的对象应该通过调用`super.clone`来获取。如果一个类及其所有超类（Object 除外）都遵循这个约定，那么将会得到`x.clone().getClass() == x.getClass()`。

另外，返回的对象应该独立于被克隆的对象。要实现这种独立性，可能需要在返回之前修改`super.clone`返回的对象的一个或多个字段。

这个机制与构造函数调用链类似【子类的构造函数调用父类的构造函数】，它只是没有强制执行：如果一个类的`clone`方法返回一个不是通过`super.clone`而是通过调用构造函数获得的实例，虽然编译器不会报错，但是如果一个该类的子类调用`super.clone`，将会生成父类的对象而不是子类的克隆对象。如果重写`clone`的类是`final`，因为没有子类，所以不需要担心。但是如果一个`final`类有 clone 方法，但是该方法没有调用`super.clone`方法，那么该类没有理由实现 Cloneable，因为它不依赖于 Object 的`clone`实现的行为。

假设你希望在一个类中实现 Cloneable，并且它的超类都提供良好的`clone`方法。**先调用 super.clone**。就能获得一个原始的完整功能的对象副本。在你的类中声明的任何字段将具有与原始对象相同的值。如果每个字段都包含原始值或是不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步处理。 例如，对于第 11 项中的 PhoneNumber 类就是这种情况。但请注意，**不可变类应该永远不会提供 clone 方法，直接使用该对象即可**。下面是 PhoneNumber 的 clone 方法的例子：

```java
@Override public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new AssertionError(); // Can't happen
    }
}
```
为了使此方法起作用，必须让 PhoneNumber 实现 Cloneable 接口。 虽然 Object 的 clone 方法返回 Object，而此处 clone 方法返回 PhoneNumber，但是这样做是可取的，因为 Java 支持协变返回类型。即重写方法的返回类型可以是被重写的返回类型的子类。这样客户端就不需要进行转换了。

对`super.clone`的调用包含在`try-catch`块中。这是因为 Object 声明其`clone`方法（本地方法）抛出`CloneNotSupportedException`，这是一个可检查异常。 当 PhoneNumber 实现了 Cloneable 接口就不会抛出该异常。在这个例子中，`CloneNotSupportedException`被捕获并抛出了另一种异常，因此它不会被外界检查到（71）。

如果对象包含引用可变对象的字段，使用上述这种简单的`clone`实现可能会不尽人意。例如，对于第 7 项中的 Stack 类：
```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static 
        int DEFAULT_INITIAL_CAPACITY = 16;
    public Stack() {
        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }
    // Ensure space for at least one more element.
    private void ensureCapacity() {
    if (elements.length == size)
        elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```
如果仅仅把它的`clone`方法返回`super.clone()`，这样得到的 Stack 实例的 size 具有正确的值，但是它的 elements 字段将引用与原始 Stack 实例相同的数组。修改原始对象中的数组，克隆出来的对象中的数组也会跟着变，反之亦然。

如果使用 Stack 类的构造器新建一个对象，这种情况就不会发生。实际上，clone 方法就是另一个构造器；你必须确保它不会改变原始对象，并确保正确地创建被克隆对象。为了使 Stack 上的`clone`方法正常工作，它必须复制对象的内部信息。最简单的方法是在 elements 数组上继续调用 clone：
```java
// Clone method for class with references to mutable state
@Override public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        result.elements = elements.clone();
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```
> 数组的`clone`、`System.arraycopy`、`Arrays.copyOf`对于引用对象都是浅拷贝

请注意，**我们不必将 elements.clone 的结果强制转换为 Object[]**。在数组上调用 clone 会返回一个数组，其运行时和编译时类型与要克隆的数组的类型相同。这是复制数组首选的习惯用法。

还要注意，如果 elements 字段是`final`的，就不能使用上述方法，因为`clone`方法无法给 elements 字段赋新值。这是一个根本的问题：与序列化一样，Cloneable 与引用可变对象的`final`字段的正常使用不兼容，除非可以在对象与其克隆之间安全地共享可变对象。为了使类可以克隆，可能需要从某些字段中删除`final`修饰符。

仅递归调用克隆有时是不够的。假设你正在为哈希表编写`clone`方法，该哈希表的内部由桶数组组成，每个桶都包含一个键值对单链表并指向链表中的第一个数据。为了提高性能，该类实现了自己的轻量级单链表，而不是在内部使用 `java.util.LinkedList`：
```java
public class HashTable implements Cloneable {
    private Entry[] buckets = ...;
    private static class Entry {
        final Object key;
        Object value;
        Entry next;
        Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
            ... // Remainder omitted
        }
    }
}
```
假设你只是递归地克隆 bucket 数组，就像我们对 Stack 所做的那样：
```java
@Override public HashTable clone() {
    try {
        HashTable result = (HashTable) super.clone();
        result.buckets = buckets.clone();
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```
虽然克隆出来的对象拥有自己的桶数组，但此数组与原始对象引用的是相同的链表。要解决此问题，你必须复制每个链表。这是一种常见的方法：
```java
// Recursive clone method for class with complex mutable state
public class HashTable implements Cloneable {
    private Entry[] buckets = ...;
    private static class Entry {
        final Object key;
        Object value;
        Entry next;
        Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
        // Recursively copy the linked list headed by this Entry
        Entry deepCopy() {
            return new Entry(key, value, next == null ? null : next.deepCopy());
        }
    }
    @Override public HashTable clone() {
        try {
            HashTable result = (HashTable) super.clone();
            result.buckets = new Entry[buckets.length];
            for (int i = 0; i < buckets.length; i++)
                if (buckets[i] != null)
                    result.buckets[i] = buckets[i].deepCopy();
            return result;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
    ... // Remainder omitted
}
```
在私有类`HashTable.Entry`中创建了一个`deepcopy`方法，然后在HashTable 上的`clone`方法新建一个适当大小的桶数组，并遍历原始桶数组，深度拷贝每个非空桶。Entry 上的`deepCopy`方法以递归方式调用自身，以复制该 Entry 为首的整个链表。虽然说这种方法很灵活，并且如果散列桶不是很长的话，也可以正常工作，但它会为链表列表中的每个元素消耗一个堆栈帧。如果列表比较长，这很容易导致**堆栈溢出**。为了防止这种情况，你可以在 deepCopy 中用遍历代替递归：
```java
Entry deepCopy() {
    Entry result = new Entry(key, value, next);
    for (Entry p = result; p.next != null; p = p.next)
        p.next = new Entry(p.next.key, p.next.value, p.next.next);
    return result;
}
```
克隆复杂可变对象的最后一种方法是先调用`super.clone`，然后初始化对象中的所有字段，然后调用相应的方法赋值。在我们的 HashTable 示例的情况下，先创建一个新的 bucket 数组，并且为每个键值映射调用`put（key，value）`方法。这种方法虽然简单，其运行速度不如直接操作克隆【对象】内部的克隆方法。它与整个 Cloneable 体系结构是对立的，因为它舍弃了 Cloneable 的逐域对象复制的机制。

与构造函数一样，**克隆方法中一定不能在构造的过程中调用可以被子类重写的方法**（19）。如果 clone 方法调用了一个在子类中被重写的方法，那么在该方法所在的子类就有可能在调用`clone`方法时执行被重写的方法，从而导致克隆对象和原始对象之间状态的不一致。因此，前一段中讨论的`put(key, value)`方法应该是`final`或者`private`。

Object 的`clone`方法可抛出 `CloneNotSupportedException`异常，但是，**重写的 clone 方法不应该继续 throws 该异常**，因为不抛出受检异常的方法更容易使用（71）。

在设计继承类时，你有两种选择（19），但无论你选择哪一种，该类都不应该实现 Cloneable。你可以选择模拟 Object 的行为：实现一个适当的`proteced`的克隆方法，该方法被声明为抛出`CloneNotSupportedException`异常。这样子类就可以选择实现或不实现 Cloneable，就像它们直接扩展 Object 一样。或者，你可以选择不去实现克隆方法，为了防止子类实现，可以提供以下简化了的克隆方法：
```java
@Override
protected final Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException();
}
```
还有一个点需要注意，如果编写一个实现 Cloneable 接口的线程安全类，请记住它的`clone`方法必须同步，就像任何其他同步的方法一样（78）。**因为Object 的 clone 方法没有实现同步**。

简而言之，**所有实现 Cloneable 的类都应该使用返回类型为类本身的公共方法来覆盖 clone**。此方法首先调用`super.clone()`，然后修改必要的字段。即复制包含对象的内部“深层结构”的任何可变对象，并用指向新对象的引用代替原来指向这些对象的引用。虽然这些内部副本通常可以通过递归调用`clone`来完成，但这通常不是最佳方法。如果类值包含基本类型的字段或是对不可变对象的引用，则不需要修改任何字段，这条规则也有**例外**。例如，代表序列号或其他唯一 ID 的字段需要修复，即使它是基本类型或者不可变的也要被修正。

如果你扩展一个已经实现 Cloneable 的类，那么除了实现一个良好行为的`clone`方法之外别无选择。否则，最好提供另一种对象拷贝的方法。例如提供拷贝构造器或拷贝工厂。拷贝构造器就是一个构造器，他接收一个参数，其类型是包含该构造器的类，例如：
```java
// Copy constructor
public Yum(Yum yum) { ... };
```
拷贝工厂是一个类似于拷贝构造器的静态工厂(1)：
```java
// Copy factory
public static Yum newInstance(Yum yum) { ... };
```
拷贝构造器的做法，及其静态工厂方法的变型都比`Cloneable/clone`方法具有更多的优点：它们不依赖于某一种很有风险的对象创建机制；他们不需要遵守尚未完善的规范；它们不会与`final`字段的正常使用发生冲突；它们不会抛出不必要的受检异常；而且它们不需要进行类型转换。

此外，拷贝构造函数或工厂可以使用一个接口类型的参数。例如，所有通用集合实现都提供一个构造函数，其参数的类型为 Collection 或 Map。基于接口的复制构造函数和工厂（更恰当地称为转换构造函数和转换工厂），允许客户端选择拷贝的实现类型，而不是强迫客户端接受原始的实现类型。例如，假设你有一个 HashSet：s，并且你希望将其拷贝成一个 TreeSet。用转换构造函数很容易实现：new TreeSet<>(s)。

既然 Cloneable 具有上述那么多问题，新的接口就不应该对它进行扩展，而且新的可扩展的类也不应该实现它。虽然实现 Cloneable 接口对 final 类的危害较小，但应将其视为性能优化，仅适用于极少数情况（67）。总之，**复制功能最好由构造函数或工厂提供**。此规则的一个值得注意的例外是值类型的数组，最好使用 clone 方法进行复制。

## 14.考虑实现Comparable接口
与本章中讨论的其他方法不同，`compareTo`方法并没有在 Object 中声明。相反，它是`Comparable`接口中唯一的方法，它与 Object 的`equals`方法类似，只是除了简单的等同性比较之外，它还允许进行顺序比较，并且它还支持泛型。通过实现`Comparable`，来表明类的实例具有排序关系。对实现了 Comparable 的数组对象进行排序非常简单：
```java
Arrays.sort(a);
```
它同样易于搜索，计算极值，和自动维护。例如，下面的程序依赖于实现了 Comparable 的 String，它将命令行参数按字母的顺序打印出来，并删除重复项：
```java
public class WordList {
    public static void main(String[] args) {
        Set<String> s = new TreeSet<>();
        Collections.addAll(s, args);
        System.out.println(s);
    }
}
```
通过实现 Comparable，你可以让你的类与依赖于此接口的许多泛型算法和依赖于该接口的**有序集合**进行交互操作。实际上，Java 类库中的所有值类以及所有枚举类型（34）都实现了 Comparable。如果你正在编写具有明显排序关系的值类，例如字母顺序，数字顺序或时间顺序，则应考虑实现 Comparable 接口：
```java=
public interface Comparable<T> {
    int compareTo(T t);
}
```
`compareTo`方法的通用约定与`equals`方法相似：

将这个对象与指定对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。如果指定对象的类型无法与该对象进行比较，则抛出`ClassCastException`异常。

在下面的说明中，符号 sgn 表示数学中的 signum 函数，它根据表达式的值为负值、零和正值分别返回 -1、0 或 1。

- 必须确保所有的 x 和 y 都满足`sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`。（这也暗示着，当且仅当`y.compareTo(x)`抛出异常时，`x.compareTo(y)`才抛出异常）

- 实现者还必须确保这个比较关系是可传递的：`(x.compareTo(y) > 0 && y.compareTo(z) > 0)`意味着`x.compareTo(z) > 0`。

- 最后，实现者必须确保`x.compareTo(y) == 0`意味着所有的 z 都满足`sgn(x.compareTo(z)) == sgn(y.compareTo(z))`。

- 强烈建议`(x.compareTo(y) == 0) == (x.equals(y))`，但这并非绝对必要。一般来说，任何实现了 Compareable 接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有自然的排序功能，但是与 equals 不一致”。

与`equals`方法不同，`equals`方法对所有对象强加了一种等价关系，`compareTo`不必跨越不同类型的对象：当遇到不同类型的对象时抛出`ClassCastException`。但是也允许进行跨类型比较，这通常在被比较的对象实现的接口中定义。

就好像违反了`hashCode`约定的类会破坏依赖于哈希值的类一样，**违反 compareTo 约定的类也会破坏其他依赖于比较关系的类**。依赖于比较关系的类包括有序集合`TreeSet`和`TreeMap`以及包含搜索和排序算法的工具类`Collections`和`Arrays`。


前三条规定说的是，`compareTo`方法的等同性测试，也一定遵守跟`equals`约定的限制条件：自反性、对称性和传递性。因此，下面的条件也同样适用：除非你愿意放弃面向对象抽象的优势（10），否则**无法在扩展类的同时保持 compareTo 约定**。针对`equals`的解决方法也同样适用于`compareTo`方法。如果你想为一个实现了`Comparable`接口的类增加值组件，请不要扩展这个类，而是要编写一个不相关的类，其中包含第一个类的一个实例，然后提供一个“视图（view）”方法返回这个实例。这样就可以让你在第二个类上实现`compareTo`方法，同时允许其客户端在必要的时候，把第二个类的实例视同第一个类的实例（调用 view 方法）。

`compareTo`约定的最后一个只是一条建议，而不是真正的规则，只是说明了`compareTo`方法施加的等同性测试通常应该返回与`equals`方法相同的结果。如果遵守此约定，那么由`compareTo`方法的顺序关系就被认为与`equals`一致。如果违反了这条规则，顺序关系就被认为与`equals`不一致。如果一个类的`compareTo`方法执行结果与`equals`方法不一致，尽管它仍然能够正常工作，但是如果一个有序集合包含了该类的对象，这个集合就可能无法遵守相应集合接口的通用约定。因为这些接口的通用约定是按照`equals`方法来定义的，但是有序集合是按照`compareTo`方法来定义的。

例如，对于**BigDecimal**类，它的`compareTo`方法与`equals`不一致。如果你创建了一个 HashSet 实例，并且添加`new BigDecimal("1.0")`和`new BigDecimal("1.00")`，这个集合就将包含两个元素，因为新增到集合中的两个 BigDecimal 实例通过 equals 方法来比较时是不相等的。然而，如果你使用 TreeSet 而不是 HashSet 来执行同样的过程，集合中将只包含一个元素，因为这两 BigDecimal 实例在通过使用`compareTo`方法进行比较时是相等的。

编写`compareTo`方法与编写`equals`方法相似，但是也存在几处重大差别。因为`Comparable`接口带泛型，而且是静态的类型（T），因此不必进行类型检查，也不必对它的参数进行类型转换。如果参数的类型是错的，这个调用不会被译。如果参数是 null，调用应该抛出`NullPointerException`，并且当该方法访问它的成员时也应该抛出。

在`compareTo`方法中，字段比较主要是顺序比较，而不是等同性比较。比较对象引用字段可以是通过递归地调用`compareTo`方法来实现。如果一个字段没有实现 Comparable 接口，或者你需要使用一个特殊的排序关系，则可以使用**Comparator**来代替，比如针对第 10 项中 CaseInsensitiveString 类的这个`compareTo`方法使用一个已有的 comparator：
```java
public final class CaseInsensitiveString implements Comparable<CaseInsensitiveString> {
    public int compareTo(CaseInsensitiveString cis) {
        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);
    }
    ... // Remainder omitted
}
```
注意 CaseInsensitiveString 类实现了`Comparable<CaseInsensitiveString>`接口。这意味着，CaseInsensitiveString 引用只能与另一个 CaseInsensitiveString 引用进行比较。

**包装类的静态比较方法**

在 Java7 中，静态比较方法被添加到所有 Java 的基本数据类型的包装类中。在 compareTo 方法中使用关系运算符`<`和`>`是冗长且容易出错的，不再推荐使用。

如果一个类有多个重要字段，那么比较它们的顺序至关重要。应该从最重要的字段开始，然后逐步比较其他字段。 如果比较产生的不是零（零代表相等），则整个比较结束，并返回该结果。如果最关键的字段相等，则比较次重要的字段，以此类推，如果所有的域都是相等的则对象就是相等的，并返回零。下面通过第 11 项中 PhoneNumber 类的`compareTo`方法来演示：
```java
public int compareTo(PhoneNumber pn) {
    int result = Short.compare(areaCode, pn.areaCode);
    if (result == 0) {
        result = Short.compare(prefix, pn.prefix);
        if (result == 0)
            result = Short.compare(lineNum, pn.lineNum);
    }
    return result;
}
```
**比较器构造方法**

在 Java8 中，Comparator 接口配备了一组比较器构造方法，可以精确构建比较器。然后可以按照 Comparable 接口的要求，使用这些比较器来实现`compareTo`方法。但它的性能很低：在我的机器上排序 PhoneNumber 实例的数组大约慢 10%。使用这种方法时，为了简洁起见，可以使用 Java 的静态导入（import static Comparator）。下面通过 PhoneNumber 的`compareTo`方法来演示如何使用这种方法：

```java
private static final Comparator<PhoneNumber> COMPARATOR = 
    comparingInt((PhoneNumber pn) -> pn.areaCode)
    .thenComparingInt(pn -> pn.prefix)
    .thenComparingInt(pn -> pn.lineNum);

public int compareTo(PhoneNumber pn) {
    return COMPARATOR.compare(this, pn);
}
```
这个实现在类初始化时构建了一个比较器，并使用了两种比较器构造方法。第一种是`comparingInt`。它是一个静态方法，带有一个键提取器函数，它将对象引用映射到 int 类型的键上，并返回一个对实例进行排序的比较器。在前面的示例中，`comparisonInt`采用`lambda()`从 PhoneNumber 中提取区域代码，并返回一个根据区号对电话号码进行排序的`Comparator<PhoneNumber>`。请注意，lambda 显式指定其输入参数的类型（PhoneNumber pn）。事实证明，在这种情况下，Java 的类型推断并不足以为自己确定类型，因此我们不得不帮助它来编译程序。

如果两个电话号码具有相同的区号，就需要进一步细化比较，这正是第二个比较器构造方法`thenComparingInt`所做的事情。它是 Comparator 上的一个实例方法，它接受一个 int 的键提取器函数，并返回一个比较器，该比较器首先应用第一个比较器，然后使用提取的键来继续比较。你可以根据需要将尽可能多的调用堆叠到`thenComparingInt`。在上面的示例中，我们将两个调用堆叠到`thenComparingInt`，按照第比较前缀、比较行数的顺序进行排序。请注意，我们没有必要指定传递给`thenComparingInt`的任一调用的键提取器函数的参数类型：Java 的类型推断足够聪明，可以自己解决这个问题。

Comparator 类具备全套的构造方法。对于基本类型 long 和 double，也有 comparingInt 和 thenComparingInt 类似的东西。Int 版本也适用于更狭义的整数类型，例如 PhoneNumber 例子中的 short。double 版本也可用于 float。这样便涵盖了所有的 Java 数字型基本类型。

对象引用类型也有比较器构造方法。静态方法`comparing`有两个重载。一个仅带有键提取器，并使用键的自然排序顺序。第二个既带有键提取器，还带有用于比较被提取的键上的比较器。
```java
static <T,U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T,? extends U> keyExtractor);
static <T,U> Comparator<T> comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator);
```
`thenComparing` 的重载方法有三个，第一个重载方法只带有比较器，并使用它来提供比较次级顺序。第二个重载方法只带有一个键提取器，并使用键的自然排序作为次级顺序。最后一个重载方法既带有键提取器，又带有一个用于比较提取的键的比较器。
```java
default Comparator<T> thenComparing(Comparator<? super T> other);
default <U extends Comparable<? super U>> Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor);
default <U> Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor,Comparator<? super U> keyComparator)
```
`compareTo`或`compare`方法有时也会依赖于两个值之间的区别：即如果第一个值小于第二个值，则为负，如果两个值相等则为零，如果第一个值更大则为正。下面举个例子：
```java
static Comparator<Object> hashCodeOrder = new Comparator<>() {
    public int compare(Object o1, Object o2) {
        return o1.hashCode() - o2.hashCode();
    }
};
```
**千万不要使用这种方法**。它很容器造成整数溢出，同时违反了 IEEE 754 浮点算术标准。此外，这种方式的运行速度也没有多大改善。

因此，要么使用一个静态比较方法`compare`：
```java
static Comparator<Object> hashCodeOrder = new Comparator<>() {
    public int compare(Object o1, Object o2) {
        return Integer.compare(o1.hashCode(), o2.hashCode());
    }
};
```
要么使用比较器的构造方法：
```java
static Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -> o.hashCode());
```
总之，每当实现一个对排序敏感的类时，都应该让该类实现 Comparable 接口，以便其实例可以轻松地被分类、搜索，以及用在基于比较的集合中。实现`compareTo`方法时都要避免使用`<`和`>`运算符，而**应该使用基本类型的包装类中的静态比较方法或 Comparator 接口中的比较器构造方法 comparing**。
