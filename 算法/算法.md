## 绳子覆盖最多的点数

> 给定一个有序数组 arr，代表坐落在 X 轴上的点，给定一个正数 K，代表绳子的长度，返回绳子最多覆盖住的点数，边缘处也算

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/1-d6fae9b7fa9d520dee4215ae404155d0-5bcdd0.png" style="zoom:67%;" />

```java
public static int maxPoint(int[] arr, int K) {
    int res = 0;
    int length = arr.length;
    if (length == 0 || K == 0) {
        return res;
    }
    for (int i = 0; i < length; i++) {
        int maxIndex = MaxIndex(arr, i, arr[i] - K);
        res = Math.max(res, i - maxIndex + 1);
    }
    return res;
}

public static int MaxIndex(int[] arr, int r, int value) {
    int l = 0;
    while (l < r) {
        int middle = l + (r - l) / 2;
        if (arr[middle] >= value) {
            r = middle;
        } else {
            l = middle + 1;
        }
    }
    return r;
}
```

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/2-d85cfad1ec71a93acf6502f863819b00-4348cf.png" style="zoom:67%;" />

```java
public static int moveWindow(int[] arr, int K) {
    int l = 0;
    int r = 0;
    int length = arr.length;
    int res = 0;
    while (l < length) {
        while (r < length && arr[r] - arr[l] <= K) {
            r++;
        }
        res = Math.max(res, r - l);
        l++;
    }
    return res;
}
```

---

## 统计不同电话号码个数

可以用位图来统计，代码上可以使用`int数组`，也可以使用<a href="../Java/集合/BitSet.md">BitSet</a>，每一个数组元素占用`4`字节，也就是`32`位，相当于可以存储 32 个号码。

以 00000100 号码为例：

第一步，计算数组下标，`100/32=3`，所以该号码对应的数组下标为`2`。

```java
int数组arr：[{0}, {1}, {2(存放在这里)}, {3}, ...]
```

第二步，计算电话号码在这个 int 数字中具体的 bit 的位置：`100%32=4`，即将 1 左移 4 位，然后与数组该位置元素进行或运算。

```java
{1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32}
 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0
arr[2] = arr[2] | 10000
```

第三步，统计数组中各个元素的二进制位上 1 的个数：

```java
// 方法 1：Integer 静态方法
Integer.bitCount(n);

// 方法 2：n&(n-1)
while (n != 0){// 数字的二进制表示中有多少个1就进行多少次操作
    result++;
    n = n&(n-1);
}
```

> 扩展：
>
> 一个数与该数减一的结果进行与运算`n&(n-1)`，会把该数右边（低位）第一个1变为0，而该位左边保持不变（高位）
>
> 例子：比如 1100（对应十进制是 12），减去 1 之后的结果是 1011（也就是十进制的 11），两个数进行与运算之后，我们发现最后的结果是 1000（对应十进制的 8，当然这个 8 与后面没有关系，可以略过）。这样我们每进行一次的与运算就消去一个 1，这样消到最后肯定是 0 了，所以我们可以在代码中以这个为循环的终止条件。

## 快速排序

从数组中选取一个中心元素，将比元素小的放在左边，比元素大的放在右边。然后再递归比较元素左边的数组和右边的数组。

```java

public class QuickSort {

    public static int partition(int[] array, int low, int high) {
        // 取最后一个元素作为中心元素
        int pivot = array[high];
        // 定义指向比中心元素大的指针，首先指向第一个元素
        int pointer = low;
        // 遍历数组中的所有元素，将比中心元素大的放在右边，比中心元素小的放在左边
        for (int i = low; i < high; i++) {
            if (array[i] <= pivot) {
                // 将比中心元素小的元素和指针指向的元素交换位置
                // 如果第一个元素比中心元素小，这里就是自己和自己交换位置，指针和索引都向下一位移动
                // 如果元素比中心元素大，索引向下移动，指针指向这个较大的元素，直到找到比中心元素小的元素，并交换位置，指针向下移动
                int temp = array[i];
                array[i] = array[pointer];
                array[pointer] = temp;
                pointer++;
            }
            System.out.println(Arrays.toString(array));
        }
        // 将中心元素和指针指向的元素交换位置
        int temp = array[pointer ];
        array[pointer] = array[high];
        array[high] = temp;
        return pointer;
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // 获取划分子数组的位置
            int position = partition(array, low, high);
            // 左子数组递归调用
            quickSort(array, low, position -1);
            // 右子数组递归调用
            quickSort(array, position + 1, high);
        }
    }

    public static void main(String[] args) {
        int[] array = {6,72,113,11,23};
        quickSort(array, 0, array.length -1);
        System.out.println("排序后的结果");
        System.out.println(Arrays.toString(array));
    }
}
```

