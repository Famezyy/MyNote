## 绳子覆盖最多的点数

> 给定一个有序数组 arr，代表坐落在 X 轴上的点，给定一个正数 K，代表绳子的长度，返回绳子最多覆盖住的点数，边缘处也算

<img src="img\1.png" style="zoom:67%;" />

```java
public static int maxPoint(int[] arr, int K) {
    int res = 0;
    int length = arr.length;
    if (length == 0 || K == 0) {
        return res;
    }
    for (int i = 0; i < length; i++) {
        int maxIndex = MaxIndex(arr, i, arr[i] - K);
        res = Math.max(res, i - maxIndex + 1);
    }
    return res;
}

public static int MaxIndex(int[] arr, int r, int value) {
    int l = 0;
    while (l < r) {
        int middle = l + (r - l) / 2;
        if (arr[middle] >= value) {
            r = middle;
        } else {
            l = middle + 1;
        }
    }
    return r;
}
```

<img src="img\2.png" style="zoom:67%;" />

```java
public static int moveWindow(int[] arr, int K) {
    int l = 0;
    int r = 0;
    int length = arr.length;
    int res = 0;
    while (l < length) {
        while (r < length && arr[r] - arr[l] <= K) {
            r++;
        }
        res = Math.max(res, r - l);
        l++;
    }
    return res;
}
```

---

## 统计不同电话号码个数

可以用位图来统计，代码上可以使用`int数组`，每一个数组元素占用`4`字节，也就是`32`位，相当于可以存储 32 个号码。

以 00000100 号码为例：

第一步，计算数组下标，`100/32=3`，所以该号码对应的数组下标为`2`。

```java
int数组arr：[{0}, {1}, {2(存放在这里)}, {3}, ...]
```

第二步，计算电话号码在这个 int 数字中具体的 bit 的位置：`100%32=4`，即将 1 左移 4 位，然后与数组该位置元素进行或运算。

```java
{1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32}
 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0
arr[2] = arr[2] | 10000
```

第三步，统计数组中各个元素的二进制位上 1 的个数：

```java
// 方法 1：Integer 静态方法
Integer.bitCount(n);

// 方法 2：n&(n-1)
while (n != 0){// 数字的二进制表示中有多少个1就进行多少次操作
    result++;
    n = n&(n-1);
}
```

> 扩展：
>
> 一个数与该数减一的结果进行与运算`n&(n-1)`，会把该数右边（低位）第一个1变为0，而该位左边保持不变（高位）
>
> 例子：比如 1100（对应十进制是 12），减去 1 之后的结果是 1011（也就是十进制的 11），两个数进行与运算之后，我们发现最后的结果是 1000（对应十进制的 8，当然这个 8 与后面没有关系，可以略过）。这样我们每进行一次的与运算就消去一个 1，这样消到最后肯定是 0 了，所以我们可以在代码中以这个为循环的终止条件。
