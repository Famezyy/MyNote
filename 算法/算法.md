## 绳子覆盖最多的点数

> 给定一个有序数组 arr，代表坐落在 X 轴上的点，给定一个正数 K，代表绳子的长度，返回绳子最多覆盖住的点数，边缘处也算

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/1-d6fae9b7fa9d520dee4215ae404155d0-5bcdd0.png" style="zoom:67%;" />

```java
public static int maxPoint(int[] arr, int K) {
    int res = 0;
    int length = arr.length;
    if (length == 0 || K == 0) {
        return res;
    }
    for (int i = 0; i < length; i++) {
        int maxIndex = MaxIndex(arr, i, arr[i] - K);
        res = Math.max(res, i - maxIndex + 1);
    }
    return res;
}

public static int MaxIndex(int[] arr, int r, int value) {
    int l = 0;
    while (l < r) {
        int middle = l + (r - l) / 2;
        if (arr[middle] >= value) {
            r = middle;
        } else {
            l = middle + 1;
        }
    }
    return r;
}
```

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/2-d85cfad1ec71a93acf6502f863819b00-4348cf.png" style="zoom:67%;" />

```java
public static int moveWindow(int[] arr, int K) {
    int l = 0;
    int r = 0;
    int length = arr.length;
    int res = 0;
    while (l < length) {
        while (r < length && arr[r] - arr[l] <= K) {
            r++;
        }
        res = Math.max(res, r - l);
        l++;
    }
    return res;
}
```

---

## 统计不同电话号码个数

可以用位图来统计，代码上可以使用`int数组`，也可以使用<a href="../Java/集合/BitSet.md">BitSet</a>，每一个数组元素占用`4`字节，也就是`32`位，相当于可以存储 32 个号码。

以 00000100 号码为例：

第一步，计算数组下标，`100/32=3`，所以该号码对应的数组下标为`2`。

```java
int数组arr：[{0}, {1}, {2(存放在这里)}, {3}, ...]
```

第二步，计算电话号码在这个 int 数字中具体的 bit 的位置：`100%32=4`，即将 1 左移 4 位，然后与数组该位置元素进行或运算。

```java
{1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32}
 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0
arr[2] = arr[2] | 10000
```

第三步，统计数组中各个元素的二进制位上 1 的个数：

```java
// 方法 1：Integer 静态方法
Integer.bitCount(n);

// 方法 2：n&(n-1)
while (n != 0){// 数字的二进制表示中有多少个1就进行多少次操作
    result++;
    n = n&(n-1);
}
```

> 扩展：
>
> 一个数与该数减一的结果进行与运算`n&(n-1)`，会把该数右边（低位）第一个1变为0，而该位左边保持不变（高位）
>
> 例子：比如 1100（对应十进制是 12），减去 1 之后的结果是 1011（也就是十进制的 11），两个数进行与运算之后，我们发现最后的结果是 1000（对应十进制的 8，当然这个 8 与后面没有关系，可以略过）。这样我们每进行一次的与运算就消去一个 1，这样消到最后肯定是 0 了，所以我们可以在代码中以这个为循环的终止条件。

## 线段树

多用于以线段为单位的统计计算，例如给定一个数组，每次更新区间时判断是否有区间重合。

[LeetCode 731](https://leetcode.cn/problems/my-calendar-ii/submissions/)—— 检查是否有重复插入 3 次的区间

```java
class MyCalendarTwo {

    Sector root;

    public MyCalendarTwo() {
        root = new Sector(0, 1000000000);
    }

    public boolean book(int start, int end) {
        // 检查区间
        if (query(root, start, end - 1) >= 2) {
            return false;
        }
        // 更新区间
        updateTree(root, start, end - 1);
        return true;
    }

    public int query(Sector sector, int start, int end) {

        // 如果 sector 不在 [start,end] 范围内直接返回
        if (sector.start > end || sector.end < start) return 0;

        // 如果 sector 完全被 [start,end] 覆盖则返回结果
        if (sector.start >= start && sector.end <= end) {
            return sector.val;
        }

        // 创建左右节点
        createTree(sector);
        // 查询左右子树中的最大值
        return Math.max(query(sector.left, start, end), query(sector.right, start, end));
    }

    public void updateTree(Sector sector, int start, int end) {
        // 如果 sector 不在 [start,end] 范围内直接返回
        if (sector.start > end || sector.end < start) return;

        // 如果 sector 完全被 [start,end] 覆盖则 lazy++, val++
        if (sector.start >= start && sector.end <= end) {
            sector.lazy++;
            sector.val++;
            return;
        }
        // 创建左右节点
        createTree(sector);
        
        // 递归更新左右子树
        updateTree(sector.left, start, end);
        updateTree(sector.right, start, end);
        // 更新当前值
        sector.val = Math.max(sector.left.val, sector.right.val);
    }

    public void pushDown(Sector sector) {
        sector.left.lazy += sector.lazy;
        sector.right.lazy += sector.lazy;
        sector.left.val += sector.lazy;
        sector.right.val += sector.lazy;
        sector.lazy = 0;
    }

    public void createTree(Sector sector) {
        int mid = sector.start + ((sector.end - sector.start) >> 1);
        if (sector.left == null) {
            sector.left = new Sector(sector.start, mid);
        }
        if (sector.right == null) {
            sector.right = new Sector(mid + 1, sector.end);
        }
        // 下传 lazy
        pushDown(sector);
    }
}

class Sector {
    Sector left, right;
    int start, end;
    int val;
    int lazy;
    public Sector(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
```

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220720004831315-aebc269660d82d44eaa6d5adf5354be8-01e0bb.png" alt="image-20220720004831315" style="zoom:80%;" />

### 1.查询树

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220720004903615-140d97bd941125d627ded6723880ff26-46b5f0.png" alt="image-20220720004903615" style="zoom:80%;" />

### 2.更新树

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220720004604270-7b8c002159ee19c9a85f3ffd8948a25e-f45289.png" alt="image-20220720004604270" style="zoom:80%;" />

> 创建左右节点时将懒更新的值下推到子节点
