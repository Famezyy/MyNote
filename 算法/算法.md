## 算法

## 1.绳子覆盖最多的点数

给定一个有序数组 arr，代表坐落在 X 轴上的点，给定一个正数 K，代表绳子的长度，返回绳子最多覆盖住的点数，边缘处也算。

### 1.1 贪心 + 二分 O(NlogN)

只需要让绳子右端点放在数组坐标上，观察左端点能覆盖的坐标即可。

<img src="img/算法/1-d6fae9b7fa9d520dee4215ae404155d0-5bcdd0.png" style="zoom:67%;" />

```java
int maxPoint(int[] arr, int k) {
    int res = 0;
    for (int r = 0; r < arr.length; r++) {
        int leftIndex = getLeftIndex(arr, r, arr[r] - k);
        res = Math.max(res, r - leftIndex + 1);
    }
    return res;
}


/**
 * 找出下标 R(r) 左边刚好比 arr[r]-k 大的点
 *
 * @param arr: 数组
 * @param r: R 的下标
 * @param value：左边下标 L 需要刚好超过的值
 * @return L-左边下标
 */
int getLeftIndex(int[] arr, int r, int value) {
    int l = 0;
    while (l < r) {
        int middle = (r - l) / 2 + l;
        if (arr[middle] >= value)
            r = middle;
         else
            l = middle + 1;
    }
    return l;
}
```

### 1.2 滑动窗口 O(n)

<img src="img/算法/2-d85cfad1ec71a93acf6502f863819b00-4348cf.png" style="zoom:67%;" />

```java
int moveWindow(int[] arr, int K) {
    int l = 0;
    int r = 0;
    int res =0;
    while (l < arr.length) {
        // 找到右边下标 r 使其值刚好超过 arr[l]+k
        while (r < arr.length && arr[r] - arr[l] <= k)
            r++;
        // 由于 r 的坐标超过了覆盖范围，求覆盖的点时用 r-l
        res = Math.max(res, r - l);
        l++;
    }
    return res;
}
```

## 2.统计不同电话号码个数

可以用位图来统计，代码上可以使用`int数组`，也可以使用<a href="../Java/集合/BitSet.md">BitSet</a>，每一个数组元素占用`4`字节，也就是`32`位，相当于可以存储 32 个号码。

以 00000100 号码为例：

第一步，计算数组下标，`100/32=3`，所以该号码对应的数组下标为`2`。

```java
int数组arr：[{0}, {1}, {2(存放在这里)}, {3}, ...]
```

第二步，计算电话号码在这个 int 数字中具体的 bit 的位置：`100%32=4`，即将 1 左移 4 位，然后与数组该位置元素进行或运算。

```java
{1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32}
 0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0
arr[2] = arr[2] | 10000
```

第三步，统计数组中各个元素的二进制位上 1 的个数：

```java
// 方法 1：Integer 静态方法
Integer.bitCount(n);

// 方法 2：n&(n-1)
while (n != 0){// 数字的二进制表示中有多少个1就进行多少次操作
    result++;
    n = n&(n-1);
}
```

> 扩展：
>
> 一个数与该数减一的结果进行与运算`n&(n-1)`，会把该数右边（低位）第一个1变为0，而该位左边保持不变（高位）
>
> 例子：比如 1100（对应十进制是 12），减去 1 之后的结果是 1011（也就是十进制的 11），两个数进行与运算之后，我们发现最后的结果是 1000（对应十进制的 8，当然这个 8 与后面没有关系，可以略过）。这样我们每进行一次的与运算就消去一个 1，这样消到最后肯定是 0 了，所以我们可以在代码中以这个为循环的终止条件。

## 3.快速排序

从数组中选取一个中心元素，将比元素小的放在左边，比元素大的放在右边。然后再递归比较元素左边的数组和右边的数组。

```java

public class QuickSort {

    public static int partition(int[] array, int low, int high) {
        // 取最后一个元素作为中心元素
        int pivot = array[high];
        // 定义指向比中心元素大的指针，首先指向第一个元素
        int pointer = low;
        // 遍历数组中的所有元素，将比中心元素大的放在右边，比中心元素小的放在左边
        for (int i = low; i < high; i++) {
            if (array[i] <= pivot) {
                // 将比中心元素小的元素和指针指向的元素交换位置
                // 如果第一个元素比中心元素小，这里就是自己和自己交换位置，指针和索引都向下一位移动
                // 如果元素比中心元素大，索引向下移动，指针指向这个较大的元素，直到找到比中心元素小的元素，并交换位置，指针向下移动
                int temp = array[i];
                array[i] = array[pointer];
                array[pointer] = temp;
                pointer++;
            }
        }
        // 将中心元素和指针指向的元素交换位置
        int temp = array[pointer];
        array[pointer] = array[high];
        array[high] = temp;
        return pointer;
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // 获取划分子数组的位置
            int position = partition(array, low, high);
            // 左子数组递归调用
            quickSort(array, low, position -1);
            // 右子数组递归调用
            quickSort(array, position + 1, high);
        }
    }

    public static void main(String[] args) {
        int[] array = {6,72,113,11,23};
        quickSort(array, 0, array.length -1);
        System.out.println("排序后的结果");
        System.out.println(Arrays.toString(array));
    }
}
```

## 4.交换字符

一个数组中只有两种字符 "G" 和 "B"，想把所有 "G" 放在一端，所有的 "B" 放在另一端，但是只能移动交换相邻的字符，返回最少交换的次数。

### 贪心 O(n)

将 "G" 全部放在左边时，对于出现的第一个 "G"，只需将其放在坐标 0 的位置，假如其下标是 3，则放到下标 0 的位置需要 3 次。第二个 "G" 的下标为  4，要将其移动到 1，则需移动 3 次。

```bash
arr                   BBBGGBBG
index                 01234567
index after moved        01  2
times                    33  5  
```

将 "B" 放在左边时同理。

```java
int getExchangeCount(String[] arr) {
    // gCount 表示移动过的 G 的次数
   int gCount = 0;
   int bCount = 0;
    // gLeftRes 表示将所有 G 移动到左侧的总次数
   int gLeftRes = 0;
   int bLeftRes = 0;
    for (int i = 0; i < arr.length; i++) {
        if ("G".equals(arr[i])) {
            gLeftRes += i - gCount;
            gCount++;
        } else {
            bLeftRes += i - bCount;
            bCount++;
        }
    }
    return Math.min(gLeftRes, bLeftRes);
}
```

##  5.大顶堆小顶堆

[源码解析](https://zhuanlan.zhihu.com/p/630992857)

大顶堆（Max Heap）和小顶堆（Min Heap）是两种特殊的二叉堆，它们都是一种完全二叉树（或近似完全二叉树），并且满足堆的性质。

1. **大顶堆（Max Heap）：**

   ```bash
          9
         / \
        7   5
       / \ / \
      6  2 4  3
   ```

   - 在大顶堆中，每个节点的值都大于或等于其子节点的值
   - 对于任意节点 `i`，其值大于等于节点 `2i` 和 `2i+1` 的值
   - 大顶堆的根节点是整个堆中的最大值

2. **小顶堆（Min Heap）：**

   ```bash
          2
         / \
        4   3
       / \ / \
      6  7 5  9
   ```

   - 在小顶堆中，每个节点的值都小于或等于其子节点的值
   - 对于任意节点 `i`，其值小于等于节点 `2i` 和 `2i+1` 的值
   - 小顶堆的根节点是整个堆中的最小值

在Java中，`PriorityQueue` 类是一个实现了小顶堆（Min Heap）的优先队列。默认情况下，`PriorityQueue` 使用自然顺序（元素的自然顺序，或者通过实现 `Comparable` 接口）来维护小顶堆的性质，即队头元素是最小的。

以下是一个简单的示例，演示如何使用 `PriorityQueue` 来创建一个小顶堆：

```java
// 创建一个小顶堆
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
// 输出小顶堆的元素（按照升序）
while (!minHeap.isEmpty()) {
    System.out.print(minHeap.poll() + " ");
}

// 创建一个大顶堆，需要通过自定义比较器（Comparator）来实现
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
// 输出大顶堆的元素（按照降序）
while (!maxHeap.isEmpty()) {
    System.out.print(maxHeap.poll() + " ");
}
```

