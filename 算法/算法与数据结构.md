## 算法与数据结构

## 1.快速排序

从数组中选取一个中心元素，将比元素小的放在左边，比元素大的放在右边。然后再递归比较元素左边的数组和右边的数组。

```java

public class QuickSort {

    public static int partition(int[] array, int low, int high) {
        // 取最后一个元素作为中心元素
        int pivot = array[high];
        // 定义指向比中心元素大的指针，首先指向第一个元素
        int pointer = low;
        // 遍历数组中的所有元素，将比中心元素大的放在右边，比中心元素小的放在左边
        for (int i = low; i < high; i++) {
            if (array[i] <= pivot) {
                // 将比中心元素小的元素和指针指向的元素交换位置
                // 如果第一个元素比中心元素小，这里就是自己和自己交换位置，指针和索引都向下一位移动
                // 如果元素比中心元素大，索引向下移动，指针指向这个较大的元素，直到找到比中心元素小的元素，并交换位置，指针向下移动
                int temp = array[i];
                array[i] = array[pointer];
                array[pointer] = temp;
                pointer++;
            }
        }
        // 将中心元素和指针指向的元素交换位置
        int temp = array[pointer];
        array[pointer] = array[high];
        array[high] = temp;
        return pointer;
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // 获取划分子数组的位置
            int position = partition(array, low, high);
            // 左子数组递归调用
            quickSort(array, low, position -1);
            // 右子数组递归调用
            quickSort(array, position + 1, high);
        }
    }

    public static void main(String[] args) {
        int[] array = {6,72,113,11,23};
        quickSort(array, 0, array.length -1);
        System.out.println("排序后的结果");
        System.out.println(Arrays.toString(array));
    }
}
```

## 2.动态规划

动态规划，英⽂：Dynamic Programming，简称 DP，如果某⼀问题有很多重叠⼦问题，使⽤动态规划是最有效的。基本步骤为：

1. 确定 dp 数组以及下标的含义
2. 确定递推公式
3. dp 数组如何初始化
4. 确定遍历顺序

### 2.1 背包问题

#### 1.01背包

有 `N` 件物品和⼀个最多能被重量为 `W` 的背包。第 `i` 件物品的重量是 `weight[i]`，得到的价值是 `value[i]` 。每 件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。

1. **确定 dp 数组以及下标的含义**

   `dp[i][j]` 表示从下标为 `[0-i]` 的物品⾥任意取，放进容量为 `j` 的背包，价值总和的最⼤值。

2. **确定递推公式**

   可以有两个⽅向：

   - 由 `dp[i - 1][j]` 推出：即背包容量为 `j`，⾥⾯不放物品i的最⼤价值，此时 `dp[i][j]` 就是 `dp[i - 1][j]`
   - 由 `dp[i - 1][j - weight[i]]` 推出：即背包容量为 `j - weight[i]` 的时候不放物品 `i` 的最⼤价值，那么 `dp[i - 1][j - weight[i]] + value[i]` 就是背包放物品 `i` 得到的最⼤价值

   `dp[i][j] = Max(dp[i - 1][j], dp[i-1][j - weight[i] + value)`

3. **dp 数组如何初始化**

   `dp[0][j]`：存放编号 0 的物品的时候，各个容量的背包所能存放的最⼤价值。 那么很明显当 `j < weight[0]` 的时候，`dp[0][j]` 应该是 0，因为背包容量⽐编号 0 的物品重量还小； 当 `j >= weight[0]` 时，`dp[0][j]` 应该是 `value[0]`，因为背包容量放⾜够放编号 0 物品

4. **确定遍历顺序**

   因为 `dp[i][j]` 不管是 `i` 还是 `j` 都是由左边的元素推导出来， 因此先遍历物品或背包都可以，但是先遍历物品比较好理解

   ```java
   // weight数组的⼤⼩ 就是物品个数
   for(int i = 1; i < weight.size(); i++) {             // 遍历物品
       for(int j = 0; j <= bagWeight; j++) {            // 遍历背包容量
           if (j - weight[i] > 0)                       // 只有当当前物品重量小于背包重量时才考虑当前物品
           	dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
       }
   }
   ```

#### 2.01背包一维解法



## 3.回溯算法

## 4.双指针

**典型问题：[leetcode 1624](https://leetcode.com/problems/largest-substring-between-two-equal-characters)**

Given a string `s`, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return `-1`.

```java
public int maxLengthBetweenEqualCharacters(String s) {
    int length = s.length();
    int ans = -1;
    for (int left = 0; left < length; left++) {
        // 当右指针访问到 left + ans + 2 即停止，再访问下去已经不会超过前一个 ans 了
        for (int right = length - 1; right >= left + ans + 2; right--) {
            if (s.charAt(left) == s.charAt(right))
                ans = Math.max(ans, right - left - 1);
        }
    }
    return ans;
}
```

