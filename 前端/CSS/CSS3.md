# CSS

## 1.简介

> CSS：
>
> - 层叠样式表
>
> - 网页实际上是一个多层结构，通过 CSS 可以分别为网页的每一层设置样式
>
> - CSS用来设置网页中元素的样式
>
> 快速入门：
>
> 1. **内联样式**（行内样式）
>
>    - 在标签内部通过 style 属性设置元素的样式
>    - 只能对一个标签生效，不便于维护
>
>    ```html
>    <p style="color: red; font-size: 20px;">测试CSS</p>
>    ```
>
> 2. **内部样式表**
>
>    - 将样式编写到 head 中的 style 标签中
>    - 通过 CSS 的选择器来选中元素并为其设置各种样式
>    - 便于样式的重复使用
>    - 只能作用于单个网页
>
>    ```html
>    <head>
>        <meta charset="UTF-8">
>        <title>Document</title>
>        <style>
>            p {
>                color: red;
>                font-size: 30px;
>            }
>        </style>
>    </head>
>    
>    <body>
>        <p>测试CSS</p>
>        <p>测试CSS</p>
>    </body>
>    ```
>
> 3. **外部样式表（最佳实践）**
>
>    - 可以将 CSS 样式编写到外部 CSS 文件中
>    - 通过 ==link== 标签引入外部 CSS 文件
>    - 可以在不同页面间复用
>    - 可以使用到浏览器的缓存机制，加快网页的加载速度，提高用户体验
>
>    ```html
>    <head>
>        <meta charset="UTF-8">
>        <title>Document</title>
>        <link rel="stylesheet" href="./style.css">
>    </head>
>    ```
>
>    ```css
>    style.css
>                                                 
>    p {
>        color: red;
>        font-size: 30px;
>    }
>    ```

### 2.基本语法

> - style 标签及 CSS 文件内部不能使用 html 的语法
> - 注释：/* */
> - ==选择器==
>   - 通过选择器可以选中页面中的指定元素，比如 p 的作用就是选中页面中所有的 p 元素
> - ==声明块==
>   - 通过声明块指定要为元素设置的样式
>   - 声明块由一个个的声明组成
>   - 声明是一个名值对结构：`样式名：样式值；`

#### 2.1 选择器

##### 2.1.1 常用选择器

> 1. 元素选择器：根据标签名选中指定元素
>
>    - 语法：==标签名{}==
>    - 例：p{}，h1{}，div{}
>
> 2. id 选择器：根据元素的 id 属性值选中一个元素
>
>    - 语法：==#id属性值{}==
>    - 例：#id{}
>
> 3. class 选择器：根据元素的 class 属性值选中一组元素
>
>    - class 是一个标签的属性，和 id 类似，不同的是 class 可以重复使用，用来给元素分组
>
>    - 可以同时为一个元素指定多个 class，多个 class 间使用空格隔开
>
>      ```html
>      <p class="blue bold"></p>
>      ```
>
>    - 语法：==.class属性值==
>
>    - 例：.class{}
>
> 4. 通配选择器：选中页面中的所有元素
>
>    - 语法：==*{}==

##### 2.1.2 复合选择器

> 1. 交集选择器：选中同时符合多个条件的元素
>
>    - 语法：==选择器1选择器2选择器3==
>
>    - 如果有元素选择器，必须使用元素选择器开头
>
>      ```html
>      <head>
>          <style>
>          div.red{
>              font-size: 30px;
>          }
>          .a.a.c{
>              color: blue;
>          }
>      </style>
>      </head>
>      <body>
>          <div class="red">it is a div</div>
>          <div class="a b c">it is a div</div>
>      </body>
>      ```
>
> 2. 并集选择器：同时选中多个选择器对应的元素
>
>    - 语法：==选择器1,选择器2==
>
>    - 例：#b1,.p1,h1,span,div.red{}
>
>      ```html
>      <head>
>          <style>
>          div,p{
>              font-size: 30px;
>          }
>      </style>
>      </head>
>      <body>
>          <div>it is a div</div>
>          <p>it is a div</p>
>          <p id="b1"></p>
>      </body>
>      ```

##### 2.1.3 关系选择器

1. 元素关系种类

> 1. 父元素：直接包含子元素的元素叫父元素
> 2. 子元素：直接被父元素包含的元素是子元素
> 3. 祖先元素：直接或间接包含后代的元素，父元素也是祖先元素
> 4. 后代元素：直接或间接被祖先元素包含的元素，子元素也是后代元素
> 5. 兄弟元素：拥有相同父元素的元素是兄弟元素

2. 选择器

> 1. 子元素选择器：选中指定父元素的子元素
>    - 语法：==父元素>子元素==
>    - 例：div>span{}，div.box>span>p{}
> 2. 后代元素选择器：选中指定元素的后代元素
>    - 语法：==祖先 后代==
>    - 例：div span{}，div.box span p{}
> 3. 兄弟元素选择器：选中兄弟元素
>    - 语法：==前一个+下一个==（选中紧挨着的下一个元素） or ==兄~弟==（选中后面所有的元素）
>    - 例：p+span{} or p~span{}

##### 2.1.4 属性选择器

> 1. 选择含有指定属性的所有类型的元素
>    - 语法：==元素[属性名]==
>    - 例：p[title]{}
> 2. 选择含有指定属性的指定类型的元素
>    - 语法：==[属性名]==
>    - 例：[title]{}
> 3. 选择含有指定属性和属性值的元素
>    - 语法：==元素[属性名=属性值]==
>    - 例：p[title=abc]{}
> 4. 选择属性值以指定值开头的元素
>    - 语法：==元素[属性名^=属性值]==
>    - 例：p[title^=abc]{}
> 5. 选择属性值以指定值结尾的元素
>    - 语法：==元素[属性名$=属性值]==
>    - 例：p[title$=abc]{}
> 6. 选择属性值中含有某值的元素
>    - 语法：==元素[属性名*=属性值]==
>    - 例：p[title*=abc]{}

##### 2.1.5 伪类选择器

>   不存在的类，用来描述一个元素的特殊状态，比如：第一个子元素，被点击的元素，鼠标移入的元素等，一般情况下使用 ":" 开头
>
>   1. `:first-child`：第一个子元素
>
>    - ```css
>      ul > li:first-child
>      ```
>
>   2. `:last-child`：最后一个子元素
>
>   3. `:nth-child(n)`：选中第 n 个子元素
>
>    - 特殊值
>      - `n`：选中所有子元素（0 ~ 无穷）
>      - `2n` or `even`：选中偶数位的元素
>      - `2n+1` or `odd`：选中奇数位的元素
>
>   以上这些伪类都是根据 **所有子元素** 进行排序，若 li 不是 ul 的第一个元素，则不会使用样式
>
>   ---
>
>   4. `first-of-type`
>
>   5. `last-of-type`
>
>   6. `nth-of-type()`
>
>   这三个伪类与上述的类似，但是他们是在同类型元素中进行排序
>
>   ---
>
>   7. `not()`：否定伪类，将符合条件的元素从选择器中去除
>
>    ```css
>    /* 除了第三个 li 元素 */
>    ul>li:not(:nth-of-type(3))
>    ```
>
>   ---
>
>   8. 超链接的伪类
>
>      1. 没有访问过的链接——`link`（正常的链接）**（若定义在 hover or active 后，会覆盖 hover 和 active 的相同的样式）**
>
>          ```css
>          a:link{
>              color:red;
>          }
>          ```
>
>      2. 访问过的链接——`visited`**（若定义在 hover or active 后，会覆盖 hover 和 active 的相同的样式）**
>
>          ```css
>          a:visited{
>              color:orange;
>          }
>          ```
>
>      3. 由于隐私的原因， visited 只能修改链接的颜色
>
>      4. 鼠标移入的状态——`hover`**（可以绑定给其他标签）**
>
>          ```css
>          a:hover{
>              color:red;
>              font-size:50px;
>          }
>          ```
>
>      5. 鼠标点击的状态——`active`**（可以绑定给其他标签）**
>
>          ```css
>          a:active{
>              color:red;
>          }
>          ```
>

##### 2.1.6 伪元素选择器

>   表示页面中一些特殊的并不真实存在的元素（特殊的位置），使用 `::` 开头
>
>   1. `::first-letter`：表示第一个字母
>
>      ```css
>      p::first-letter{
>          font-size:50px;
>      }
>      ```
>
>   2. `::first-line`：表示第一行
>
>      ```css
>      p::first-line{
>          background-color:yellow;
>      }
>      ```
>
>   3. `::selection`：表示选中的内容
>
>   4. ==::before==：元素的开始位置
>
>   5. ==::after==：元素的最后位置，默认行内元素
>
>    - before 和 after 必须结合 content 属性使用（无法选中）
>
>      ```css
>      div::before{
>          content:'abc';
>          color:red;
>      }
>      ```
>

#### 2.2 样式的继承

> - 我们为一个元素设置的样式，同时也会应用到它的后代元素上,利用继承可以设置一些通用的样式
> - 并不是所有的样式都会被继承，比如背景(`background-color`)，布局相关的样式不会被继承
>   - 背景颜色会扩展至边框下面，当边框为透明时可在边框位置看到背景颜色
> - 可以查看文档中对应标签的 inherited 属性是否支持继承

#### 2.3 ==选择器的权重==

> 样式的冲突：当我们通过不同的选择器选中相同的元素，并且为相同的样式设置不同的值，此时就发生了样式的冲突
>
> - 发生样式冲突时，由选择器的权重（优先级）决定
>
> 选择器的权重：
>
> 1. 内联样式（直接声明在标签的 style 属性中）：1000
>
> 2. id 选择器：100
>
> 3. 类和伪类选择器：10
>
> 4. 元素选择器：1
>
> 5. 通配选择器（*{}）：0
>
> 6. 继承的样式：没有优先级
>
>    ```html
>    <div>
>        father
>        <span>child</span>
>    </div>
>    ```
>
>    ```css
>    *{} > div{}
>    ```
>
> > - 比较优先级时，需要将所有的选择器的优先级进行相加计算，优先级越高，越优先显示
> >
> >   ```html
> >   <div id="box1">div</div>
> >   ```
> >
> >   ```css
> >   div#box1{} > #box1{}
> >   ```
> >
> > - 分组选择器单独计算
> >
> >   ```css
> >   div,p,span{}
> >   ```
> >
> > - 选择器的累加不会超过其最大的数量级，类选择不会超过 id 选择器
> >
> > - 如果优先级计算后相等，则优先使用后定义的样式
> >
> > - 可以在某一个样式后边添加 `!important`，则此时该样式会获得最高的优先级，超过内联样式，慎用！！

#### 2.4 像素和百分比

> 1. 长度单位
>
>    - 像素：不同屏幕像素大小不同，像素越小的屏幕显示效果越清晰，同一样的 200px 在不同设备下显示效果不同
>
>    - 百分比：设置属性**相对于父元素**属性的百分比
>
>      ```html
>      <div class="box1">
>          <div class="box2"></div>
>      </div>
>      ```
>
>      ```css
>      .box1{
>          width:300px;
>          height:100px;
>          background-color:orange;
>      }
>      .box2{
>          width:50%;
>          height:50%;
>          background-color:aqua;
>      }
>      ```
>
>    - em：相对于元素自身的字体大小，1em = 1font-size，会根据字体大小改变而变，默认字体大小 16 像素
>
>    - rem：相对于根元素（html）的字体大小
>
>      ```css
>      html{
>          font-size:10px;
>      }
>      div{
>          /* 相当于 100px */
>          width:10em;
>      }
>      ```
>
> 2. 颜色单位
>
>    1. CSS 中可以直接使用 **颜色名** 来设置各种颜色
>    2. 还可使用 **RGB** 表示颜色，`RGB(红色，绿色，蓝色)`，每种颜色范围在 0 ~ 255（0% ~ 100%）
>    3. 也可使用 **RGBA**，`RGBA(红色，绿色，蓝色，不透明度)`，不透明度范围在 0 ~ 1，1 表示完全不透明，.5 表示半透明
>    4. **十六进制 RGB 值**：`#红色绿色蓝色`，范围在 00 ~ FF，如果颜色两位两位重复可以简写：#aabbcc -> #abc
>    5. **HSL** & **HSLA**：`hsl(H,S,L)`，H 指色相（0 ~ 360），S 指饱和度(0% ~ 100%)，L 指亮度（0% ~ 100%）

### 3.布局

#### 3.1 文档流（normal flow）

> - 网页是一个多层的结构，通过 CSS 可以给每一层来设置样式，用户只能看到最顶上一层
> - 最下的一层称为 **文档流**，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列
> - 元素主要有两个状态：
>   - 在文档流中
>     - **块元素**
>       - 块元素会在页面中 **独占一行**，自上向下垂直排列
>       - 默认宽度是父元素的全部（会把父元素撑满）
>       - 默认高度是被内容（子元素）撑开
>     - **行内元素**
>       - 行内元素不会独占一行，只占自身的大小
>       - 行内元素在页面中自左向右水平排列
>       - 会自动换行
>       - 默认高度和宽度总是被内容撑开
>   - 不在文档流中（脱离文档流）

#### ==3.2 盒子模型==

> - CSS 将页面中的所有元素都设置为了一个矩形的盒子
>
> - 只需将不同的盒子摆放到不同的位置
>
> - 每一个盒子都由以下几个部分组成
>
>   - 内容区（content）
>   - 内边距（padding）
>   - 边框（border）
>   - 外边距（margin）
>
> - 一个盒子的可见框的大小，由 **内容区，内边距和边框共同决定**，在计算盒子大小时，需要将三个区域加到一起计算
>
> - 相关属性
>
>   ```css
>   .box1{
>       /**
>       1. 内容区，元素中的所有子元素和文本内容都在内容区排列
>       	width：内容区的宽度，默认 auto，被内容撑开
>       	height：内容区的高度 	
>       **/
>       width:200px;
>       height:200px;
>       background-color:#bfa;
>       /**
>       2. 边框，属于盒子边缘，边框大小会影响整个盒子大小
>       	border-width：边框的宽度
>       	border-color：边框的颜色
>       	border-style：边框的样式
>       **/
>       border-width:10px;
>       border-color:red;
>       border-style:solid;
>   }
>   ```
>

##### 3.2.1 边框

> - `border-width`
>
>   - 默认 3 个像素
>   - 用来指定四个方向的边框的宽度
>   - 四个值：上 右 下 左
>   - 三个值：上 左右 下
>   - 两个值：上下 左右
>   - 一个值：上下左右
>   - 除了 border-width 还有一组 `border-xxx-width`（top,right,bottom,left），用来单独指定某一边的宽度，border-color 和 border-style 同样
>
> - `border-color`
>
>   - 指定边框颜色，同样可以分别指定四个边的边框，规则同 border-width
>   - 如果省略，则自动使用 **color** 标签的颜色值
>   - **transparent**：边框透明
>
> - `border-style`
>
>   - 指定边框的样式，同样可以指定四个边的样式
>   - 默认值是 **none**，表示没有边框
>   - solid：实线
>   - dotted：点状虚线
>   - dashed：虚线
>   - double：双线
>
> - ==border==
>
>   - 同时设置边框所有的相关样式，没有顺序要求，用空格隔开
>
>     ```css
>     div{
>         border:solid 10px orange;
>     }
>     ```
>
>   - `border-top`，`border-right`，`border-bottom`，`border-left`

##### 3.2.2 内边距

> 内边距
>
> - 内容区和边框之间的距离
> - 共有四个方向的内边距：`padding-top`，`padding-right`，`padding-bottom`，`padding-left`
> - 内边距的设置会影响到盒子的大小
> - 背景颜色会延伸到内边距上
> - ==padding==
>   - 同时指定四个方向的内边距，规则同 `border-width`

##### 3.2.3 外边距

>
> - 外边距不会影响盒子可见框的大小
> - 会影响盒子的位置
> - 一共四个方向的外边距（默认为 0）：
>
>    - `margin-top`：正值元素向下移动
>    - `margin-right`：**默认情况下不会生效**
>    - `margin-bottom`：正值其下方元素向下移动
>    - `margin-left`：正值元素向右移动
>    - 负值则元素会向相反方向移动
> - 元素在页面中按照自左向右顺序排列，所以默认情况下如果设置**左**和**上**外边距则会移动元素自身，而设置**下**和**右**外边距会移动其他元素
> - ==mergin==
>
>    - 同时指定四个方向的外边距，规则同 `border-width`

##### 3.2.4 水平方向布局

> - 元素在其父元素中水平方向的位置有以下几个属性共同决定
>
>   - margin-left
>   - border-left
>   - padding-left
>   - width
>   - padding-right
>   - border-right
>   - margin-right
>
> - 元素在其父元素中，水平布局必须满足以下等式：
>
>   - <p name="horizon">margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 父元素内容区宽度</p>
>
>   - 如果相加结果不成立，则称为过度约束，则等式会自动调整
>
>     - 如果所有的值中没有 auto，则浏览器会自动调整 **margin-right** 值使等式成立
>
>     - 7 个值中 3 个可以设置成 auto
>
>       - **width**，**margin-left**，**margin-right**
>
>         - 如果某个值为 auto，则会自动调整 auto 的值使等式成立
>
>         - 如果将 width 和一个外边距设置为 auto，则会将宽度会调整最大，另一个外边距为 0
>
>         - 如果三个值都设置为 auto，则外边距为0，宽度调整至最大
>
>         - 如果两个外边距设置为 auto，宽度值固定，则会将外边距设置为相同的值，效果为**居中**
>
>           - 示例：
>
>             ```css
>             width:200px;
>             margin 0 auto;
>             ```

##### 3.2.5 垂直方向布局

> - 默认情况下父元素的高度被内容撑开
> - 如果子元素的大小超过父元素，则子元素会从父元素中溢出
>   - 使用 <a name="overflow">`overflow`</a> 属性设置父元素如何处理溢出的子元素
>     - `visible`：默认值，子元素会从父元素中溢出，在父元素外部显示
>     - `hidden`：溢出的内容将会被裁剪，不会显示
>     - `scroll`：生成两个滚动条，通过滚动条查看完整内容
>     - `auto`：根据需要生成滚动条
>   - `overflow-x`：处理水平方向
>   - `overflow-y`：处理垂直方向

##### 3.2.6 垂直外边距的折叠

> - ==相邻==的==垂直方向==的外边距会发生折叠现象
> - 兄弟元素
>   - 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值）
>   - 特殊情况：
>     - 如果相邻外边距一正一负，则取两者的和
>     - 如果相邻外边距都是负值，则取两者绝对值较大的
> - 父子元素
>   - 父子元素间的相邻外边距，子元素会传递给父元素（上外边距）
>     - 可通过设置父元素外边框或父元素上内边距使子元素与父元素上边界分开
>     - 或开启 BFC

##### 3.2.7 行内元素的盒模型

> - 行内元素不支持设置高度和宽度，被内容撑开
> - 行内元素可以设置 padding，border，margin，但是垂直方向不会挤开下面的元素，自身文字位置也不会变，不会影响页面的布局
> - `display`：用来设置元素显示的类型
>   - `inline`：将元素设置为行内元素
>   - `block`：将行内元素设置为块元素
>   - `inline-block`：将元素设置为行内块元素，既可以设置高度和宽度，又不会独占一行
>   - `table`：将元素设置为一个表格
>   - `none`：元素不在页面显示
> - `visibility`：用来设置元素的显示状态
>   - `bisible`：默认值，元素在页面正常显示
>   - `hidden`：元素在页面中隐藏，不显示，但是依然占据页面位置

#### 3.3 浏览器的默认样式

> - 通常情况下，浏览器都会为元素设置默认样式，会影响到页面的布局
>
> - 编写时要去除浏览器的默认样式（PC端）
>
>   ```css
>   body{
>       margin:0;
>   }
>   p{
>       margin:0;
>   }
>   ul{
>       margin:0;
>       padding:0;
>       /* 去除项目符号 */
>       list-style:none;
>   }
>   ```
>
>   ```css
>   /* 可以直接声明所有的 margin 和 padding */
>   *{
>       margin:0;
>       padding:0;
>   }
>   ```
>
> - 外部 CSS 重置样式表：重置浏览器的样式
>
>   - **reset.css**：直接去除了浏览器的默认样式
>   - **normalize.css**：对默认样式进行统一，保证在所有浏览器中都是同一样式

#### 3.4 练习

```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./CSS/reset.css">
    <style>
        body {
            background-color: rgb(244, 244, 244);
        }

        .left_menu {
            margin: 50px auto;
            width: 190px;
            height: 450px;
            background-color: white;
            padding: 10px 0;
        }

        .left_menu li {
            height: 25px;
            /* 让文字垂直居中，只需将父元素的 line-height 设置与父元素的 height 相同 */
            line-height: 25px;
            /* 将文字向右移动 */
            padding-left: 18px;
            font-size: 14px;
        }

        /* 设置鼠标移入状态 */
        .left_menu li:hover {
            background-color: #d9d9d9;
        }

        .left_menu a {
            color: #333;
            /* 去除超链接下划线 */
            text-decoration: none;
        }

        .left_menu a:hover {
            color: rgb(200, 22, 35);
        }
        
        /* 通过伪元素为每一个li项目添加符号 */
        .left_menu>li::before{
            content: "■";
            color: rgb(218, 218, 218);
            margin-right:8px;
            font-size: 1px;
        }
    </style>
</head>

<body>
    <ul class="left_menu">
        <li><a href="#">家用电器</a></li>
        <li>
            <a href="#">手机</a>/<a href="#">运营商</a>/<a href="#">数码</a>
        </li>
        <li>电脑/办公</li>
        <li>家居/家具/家装/厨具</li>
        <li>男装/女装/童装/内衣</li>
        <li>美妆/个护清洁/宠物</li>
        <li>女鞋/箱包/钟表/珠宝</li>
        <li>男鞋/运动/户外</li>
        <li>房产/汽车/汽车用品</li>
        <li>母婴/玩具乐器</li>
        <li>食品/酒类/生鲜/特产</li>
        <li>艺术/礼品鲜花/农资绿植</li>
        <li>医药保健/计生情趣</li>
        <li>图书/文娱/教育/电子书</li>
        <li>机票/酒店/旅游/生活</li>
        <li>理财/众筹/白条/保险</li>
        <li>安装/维修/清洗/二手</li>
        <li>工业品</li>
    </ul>
</body>
```

#### 3.5 盒子的大小

> - 默认情况下，盒子可见框的大小由内容区，内边距和边框共同决定
> - `box-sizing` 用来设置盒子尺寸的计算方式（设置 width 和 height 的作用） 
>   1. content-box：默认值，宽度和高度用来设置内容区的大小
>   2. border-box：宽度和高度设置整个盒子可见框的大小，即此时 width 和 height 指的是 内容区，边框，内边距的总大小
>

#### 3.6 轮廓、阴影和圆角

> 1. 轮廓阴影
>
>    - `outline`：用来设置元素的轮廓线，用法和 border 相同，不同的是轮廓不会影响可见框的大小，不会挤开下方元素，相当于描边
>
> 2. 阴影
>
>    - `box-shadow`：设置元素的阴影效果，同样不会影响页面布局
>
>      - 第一个值：水平偏移量，设置阴影的水平位置，正值向右
>
>      - 第二个值：垂直偏移量，设置阴影的垂直位置，正值向下
>
>      - 第三个值：阴影的模糊半径（像素），可以不指定
>
>      - 第四个值：阴影的颜色
>
>        ```css
>        box-shadow: 10px 10px 50px rgba(0, 0, 0, .3);
>        ```
>
> 3. 圆角
>
>    - `border-radius`：设置圆角的半径大小（像素），或者椭圆的长短半轴
>
>    - `border-top-left-radius`，`border-top-right-radius`，`border-bottom-left-radius`，`border-bottom-right-radius`
>
>      ```css
>      /* 
>      左上，右上，右下，左下
>      左上，右上/左下，右下
>      左上/右下，右上/左下
>      */
>      border-radius: 10px 20px 30px 40px;
>      border-radius: 10px / 20px; /* 指定四个角的椭圆半轴 */
>      border-radius: 50%; /* 圆形 */
>      ```

### 4.浮动

#### 4.1 简介

> - 通过浮动可以使一个元素向父元素的左侧或右侧移动，可以制作**水平方向**的布局
> - 使用 `float` 属性设置
>   - null：默认值，不浮动
>   - left：向左浮动
>   - right：向右浮动
> - 注意
>   - 设置浮动以后，水平布局的等式不再强制成立，该元素不会再占据一行
>   - 完全从文档流脱离，不在占用文档流位置，所以元素下面还在文档流的元素会自动向上移动
> - **特点**
>   1. 浮动元素会完全脱离文档流，不再占据文档流的位置
>      1. **块元素不再独占一行，宽度和高度被内容撑开**
>      2. 行内元素和浮动块元素一样，此时不再区分行内元素和块元素
>   2. 设置浮动以后，元素会向左侧或右侧移动
>   3. 浮动元素默认不会从父元素移出
>   4. 浮动元素向左或向右移动时，不会超过前面定义的其他浮动元素（水平方向和垂直方向）
>   5. 如果浮动元素上边是一个没有浮动的块元素，则浮动元素无法上移
>   6. **浮动元素不会盖住文字，文字自动环绕在浮动元素周围**，可以用来设置文字环绕效果

#### ==4.2 高度塌陷和BFC==

> 1. **高度塌陷问题**：浮动布局中常见问题
>    - 在浮动布局中，父元素的高度默认被子元素撑开，当子元素浮动后，会完全脱离文档流，无法再撑起父元素高度，导致父元素高度丢失
>    - 父元素高度丢失后，其下方元素会自动上移，导致页面布局混乱
> 2. **BFC**: Block Formatting Context，块级格式化环境
>    - CSS 中隐含属性，可以为一个元素开启 BFC
>    - 开启 BFC 后，元素会变成一个独立的布局区域
>    - 开启后特点：
>      1. 不会被浮动元素覆盖
>      2. 子元素和父元素外边距不会重叠
>      3. 可以包含浮动的子元素
>    - 通过特殊方式开启
>      1. 设置父元素浮动
>         - 宽度塌陷，父元素也脱离文档
>      2. 将父元素设置为行内块元素
>         - 宽度塌陷
>      3. 将元素 [overflow](#overflow) 设置为非 visible
>         - 常设置为 hidden 开启 BFC

##### 4.2.1 clear 属性

- 作用：用于清除浮动元素对当前元素产生的影响
  - 用于解决当 box1 浮动后，box2 受到影响位置上移

- 可选值：

  - left：清楚左侧浮动元素对当前元素的影响

  - right：清除右侧浮动元素对当前元素的影响
  - both：清除两侧中影响最大的

- 原理：设置后，浏览器会自动为元素添加一个上边距，使其位置不受影响

```css
.box1{
    float:left;
}
.box2{
    clear:left;
}
```

##### 4.2.2 使用 after 伪类解决高度塌陷

- 解决想法

  ```html
  <style>
      .box2{
          float:left;
      }
      .box3{
          clear:left;
      }
  </style>
  <div class="box1">
      <div class="box2"></div>
      <!-- 添加一个 box3，清除浮动元素对它的影响，则box1 会被 box3 的位置撑开 -->
      <div class="box3"></div>
  </div>
  ```

- 高级实现

  ```html
  <style>
      .box2{
          float:left;
      }
      .box1::after{
          content:"";
          /** 默认行内元素，需要转换为块元素，或者 table **/
          display:block;
          clear:both;
      }
  </style>
  <div class="box1">
      <div class="box2"></div>
  </div>
  ```

##### 4.2.3 扩展：利用 before 解决[父子元素外边距折叠](#3.2.6 垂直外边距的折叠)

```html
<style>
    .box2{
        margin-top:100px;
    }
    .box1::before{
        content:"";
        /** table 不会占一行 **/
        display:table;
    }
</style>
<div class="box1">
    <div class="box2"></div>
</div>
```

##### 4.2.4 终极版本

```html
<style>
    .box2{
        margin-top:100px;
    }
    /** 用来同时解决高度塌陷和外边距重叠问题 **/
	.clearfix::before,
    .clearfix::after{
        content:"";
        display:table;
        clear:both;
    }
</style>
<div class="box1 clearfix">
    <div class="box2"></div>
</div>
```

### ==5.定位==

- 定位是一种更加高级的布局手段
- 通过定位可以将元素摆放到任意位置
- 使用 **position** 属性设置定位
  - `static`：默认值，元素是静止的没有开启定位
  - `relative`：相对定位
  - `absolute`：绝对定位
  - `fixed`：固定定位
  - `sticky`：粘滞定位

#### 5.1 相对定位-relative

```css
postion:relative;
```

- 相对于元素在文档流中**本来的位置**进行定位
- 会提升元素的层级，盖住其他元素
- 不会使元素脱离文档流，不会影响其他元素
- 不会改变元素的性质，块->块，行内->行内

- 偏移量：可以通过偏移量（offset）改变元素位置

  - `top`：定位元素和定位位置上边的距离，越大则向下移动

  - `bottom`：定位元素和定位位置下边的距离，越大则向上移动

  - `left`：定位元素和定位位置左边的距离

  - `right`：定位元素和定位位置右边的距离

#### 5.2 绝对定位-absolute

- 相对于其包含块进行定位

  - **包含块（containing block）**
    - 正常情况下，包含块指离当前元素最近的祖先块元素
    - 绝对定位的包含块
      - **离它最近的开启了定位（position 的值不是 static）的祖先元素**
      - 如果所有的祖先元素都没有开启定位，则相对于根元素进行定位——html（初始包含块）、
      - 一般配合相对定位使用

- 会提升元素的层级，盖住其他元素

- 元素会从文档流脱离，但不会改变位置，会影响下面元素的位置

- 会改变元素性质，行内->块，**块->大小会被内容撑开**，但不是行内元素，宽度和高度依然可以设置

- 偏移量：可以通过偏移量（offset）改变元素位置

  - `top`：定位元素和定位位置上边的距离，越大则向下移动
  - `bottom`：定位元素和定位位置下边的距离，越大则向上移动
  - `left`：定位元素和定位位置左边的距离
  - `right`：定位元素和定位位置右边的距离
  
- ==元素的布局==

  1. 水平布局

     - 开启绝对定位后，水平方向的[布局等式](#horizon)就需要添加 left 和 right

     - 规则和之前一样

       - 发生过度约束时，如果 9 个值中没有 auto，则自动调整 right 值以使等式满足

       - 如果有 auto，则自动调整 auto 以使等式满足

         - 可以调整的属性为：margin、width、left、right

       - left 和 right 默认 auto，默认 left 为 0，right 最大，如果不设置 left 和 right，当等式不满足时，会自动优先调整 left 和 right

         ```css
         /* 水平居中 */
         margin-left: auto;
         margin-right: auto;
         left: 0px;
         right: 0px;
         ```

  2. 垂直布局

     - top + margin-top / bottom + padding-top / bottom + height + border-top / bottom + bottom = 包含块高度

     - 默认自动调整 bottom

       ```css
       /* 垂直居中 */
       top: 0px;
       bottom: 0px;
       margin-top: auto;
       margin-bottom: auto;
       ```

       

#### 5.3 固定定位-fixed

- 也是一种绝对定位，大部分特点和绝对定位相同
- 不同的是固定定位永远参照浏览器的**视口**进行定位
- 不会随滚动条滚动

#### 5.4 粘滞定位-sticky

- 和相对定位特点基本一致，但是相对于 body 的位置
- 当元素通过滚动条滚动到达某一位置后固定不动
- 通过偏移量指定到达的位置
- 兼容性不好

```css
postion:sticky;
top:10px;
```

#### 5.5 元素的层级

- 对于开启了定位的元素，可以使用 `z-index` 属性指定元素的层级，传入一个整数，值越大层级越高越优先显示
- 如果元素的层级一样，则优先显示靠下的元素
- 祖先元素的层级再高，也不会盖住后代元素

### 6.字体

P76





