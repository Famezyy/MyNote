# MySQL知识点

从初期设计开始就要考虑调优，确定每个字段的**类型**和**大小**。

## 1.NULL注意点

### **1. count 数据丢失**

> - 当某列存在 NULL 值时，使用 `count(colum)` 查询该列，就会出现数据丢失问题
> - ==解决==：若某列存在 NULL 值时，使用 `count(*)` 或者 `count(id)` 进行数据统计
>

### **2. distinct 数据丢失**

> - 当使用 `count(distinct col1， col2)` 查询时，若其中一列为 NULL，那么即使另一列有不同的值，那么查询结果也会丢失数据： 
>
>   `select count(distinct name， mobile) from person`
>

### **3. select 数据丢失**

> - 如果某列存在 NULL 值，如果执行非等于查询（<> / !=）则会导致 NULL 值的结果丢失：
>
>   `select * from person where name <> 'java' order by id`
>
> - ==解决==：`select * from person where name <> 'java' or isnull(name) order by id`
>

### **4. 聚合函数计算时不会考虑 null 值**

#### 导致空指针异常

> - 如果某列存在 NULL 值，可能会导致 sum(col) 的返回结果为 NULL 而非 0，如果 sum 查询的结果为 NULL 就可能会导致程序执行时空指针异常：
>
>   `select sum(num) from goods where id > 4`（当仅有一个 id 大于 4 的数据且该数据值为 null 时）
>
> - ==解决==：`select ifnull(sum(num)， 0) from goods where id > 4`
>

### **5. 增加了查询难度**

> - 当进行 NULL 值查询时，必须使用 NULL 匹配的查询方法，比如 `IS NULL` 或者 `IS NOT NULL` 或者 `IFNULL(com)`，而不能使用传统的 =，!=，<>...
>   - `select * from person where name != null` 结果为空
>
> - 正确写法：
>   - `select * from person where name is not null`
>   - `select * from person where name !isnull(name)`：推荐，效率更快
>

### **6. NULL 不会影响索引**

### **7. NOT IN 返回 NULL**

> - 当给定的值不在列表中且列表中含有 null 时，结果返回 null
>
>   ```mysql
>   SELECT "2" NOT IN ("3"， "1"， NULL); # 会返回 null
>   SELECT "2" NOT IN ("3"， "1"， "4");  # 返回 1
>   SELECT "2" NOT IN ("3"， "1"， "2");  # 返回 0
>   ```

### 8.节约空间

1. 修改行格式

   Compressed 在发生行溢出时会以 Zlib 算法将溢出页压缩

2. 修改编码

   - UTF-8 占用 3 或 4 个字节
   - 全英文考虑使用 ASIIC

3. 使用 VARCHAR 或 CHAR 时声明字段大小

3. 声明为 NOT NULL，节省 1 字节

4. 整数避免使用字符串

5. 主键不要太长

   - 聚簇索引
   - 二级索引

7. 在服务层使用 map 映射通用的字段，数据库中只存储编号即可

6. 没有创建索引且没有 UNIQUE 字段时，默认会创建一个 row_id 作为索引，占 6 字节，可自己定义索引

### 9.使用函数时

对应列上的索引将失去作用

## 2.8.0 和 5.7 区别

- 默认字符集不同

  5.7 默认的客户端和服务器 latin1，utf8 字符集指向的是 utf8mb3，8.0 默认 utf8mb4

- 8.0 的 DDL 语句支持原子操作

- MySQL 8.0 支持窗口函数

- 从 MySQL 8.0.17 开始，不推荐使用显示宽度属性

## 3.B+树

基于主键索引建立的 B+ 树，每张表只有一个，每个节点以 16KB 内存页的形式存储数据。

- 叶子节点存储整个数据

- 非叶子节点存储索引和向下的指针（6 个字节），如果主键索引是 BIGINT 类型，则占用 8 个字节，此时每个数据占用 14 个字节。

  > **主键存储的格式**
  >
  > - id 为 1：80 00 00 01
  > - id 为 3：80 00 00 03

- 根节点占用 16KB，`16*1024/14=1170` 约等于能存储 1100 个索引数据，以 3 层 B+ 树为例，则一颗 B+ 树能存储`1100*1100=1210000`约等于 100 万个索引数据（一个索引指向一个内存页）。如果每条记录占用 1KB，则一条内存页最多包含 16 条记录，此时这颗 B+ 树能存储 1600 万条记录。

对于 3 层 B+ 树，每次查找数据都会进行 3 次 IO 操作加载内存页，每次以二分查找的方式查找到相应索引后加载下一个节点数据。时间复杂度为 O(logn)。

**优点**

- 通过`B+树`的结构来存储数据，可以大大减少数据检索时的`磁盘IO`次数，从而提升数据查询的性能
- `B+树`索引在进行范围查找的时候，只需要找到起始节点，然后基于叶子节点的链表结构往下读取即可查询，效率较高
- 通过唯一索引约束，可以保证数据表中每一行数据的唯一性

**缺点**

- 数据的增删改需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大的`性能开销`
- 一个表中允许存在一个聚簇索引和多个非聚簇索引，但是索引数不能创建太多，否则索引维护成本过高
- 创建索引的时候，需要考虑到索引字段值的分散性，如果字段的重复数据过多，创建索引反而会带来性能降低
- 若主键索引的长度过大，则由于不论是聚簇索引还是多个非聚簇索引，每个节点都会存储主键索引，因此会造成较大的空间开销

**为什么不用其他数据存储结构**

1. **B 树**

   - B 树叶子节点存储数据，所以存储的索引数量少，因此通常 B 树的深度比 B+ 树大，所需磁盘 IO 更多，查询效率低

   - B 树查询不稳定，B+ 树数据都在叶子节点，每次查询访问的节点数相同，查询效率稳定

   - 范围查询时，B 树需要通过中序遍历，B+ 树叶子节点间是双向链表结构，叶子节点内部是单向链表结构，只需便利指针即可，但是链表维护较困难

2. **二叉树**

   每个节点仅有 2 个子节点，同理树的深度会非常大，还不如 B 树。

3. **跳表**

   跳表是基于链式结构而引出的比较新颖的数据结构。一般的链式结构可能是 1->2->3->4， 跳表中还可能构建了 1->3，1->4 的链接。虽然时间复杂度是 O(n)，但是可以通过好的设计来降低 n 的值。
   而因为 mysql 的持久化存储是在磁盘中，跳表的结构体则需要存储到内存中。mysql 进行数据索引的时候是基于内存页的形式，跳表是基于 Node 节点，且索引结构非常复杂。比如对于联合索引，需要同时维护多个索引的跳跃指针，维护复杂。客观上跳表的出现比较晚，出现时 mysql 已经使用 B+ 树了。

4. **哈希map**

   - 不支持模糊查询（`like`语法）
     存储时首先计算 key 的 hashcode，然后右移 16 位异或自身得到 hash 值，再与运算`size -1`得到桶位。如果加上`%` hash 结果就会不同。
   - 不支持范围查询（`where id > 10`）
   - 产生哈希冲突时时间复杂度会退化，查询不稳定

## 4.索引的特点

定义索引时，识别区分度要大。通过查看`show index`的`cardinality`的值可以得到该索引的离散值，越接近 1 离散值越大。

最左前缀原则：如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。索引相同顺序不同时会被优化。

覆盖索引：查询的值在辅助索引中就可以全部找到，不需要回表。

**索引失效案例**

1. `like`语句中以`%`开头
2. `or`前后两个字段中有一个没有使用索引
3. `联合查询`没有从左开始依次使用索引（顺序不同则会被优化）
4. 对索引字段进行`运算`
5. 非逻辑（`!=`、`<>`、`is not`）
6. `is null`或`is not null`不一定会导致索引失效
   （mysql 不会对 null 值进行索引，建议创建字段时设置`is not null`或者设置默认值）
7. 对索引字段使用`内置函数`
8. 对索引字段进行类型转换（实际为 VARCHAR 类型，传入 int 类型：`id=1`）
9. 对于以下语句：`select * from table where a > 3`，a 为辅助索引，根据版本不同情况不同：
    - 对于 5.6 版本之前， mysql 会考虑两种情况：查询辅助索引后随机回表进行查询（离散读），例如拿到了 5、6、7，可能先回表查询 7，再查 5，再查 6，所以要回 3 次表；或者直接全表扫描，对于 3 层树只需要 3 次 IO。如果阈值为 20 万，则数据小于 20 万时就会进行全表扫描，否则使用辅助索引
    - 对于 5.6 版本及之后，mysql 引入了`MultiRange Read`用来解决离散读问题，当查询辅助索引后，在 InnoDB 存储层对主键进行排序并存入内存中，然后再回表进行查询

## 5.MVCC及事务隔离级别

### 5.1 MVCC

一致性非锁定读、多版本并发控制，是 MYSQL 基于自身的**回滚机制**对并发场景下的**读操作**的优化，即并发场景下读操作时不需要进行锁定，从而优化读取速度。

### 5.2 事务隔离级别

1. read uncommitted - 没有用到 MVCC，会产生脏读
2. read committed（大厂常用） - 每次都读取最新的快照，违背了事务的隔离性，会产生幻读（同一事务两次读取同一区段的数据量不同）和不可重复读（同一事务两次读取同一记录的数据不同）
4. repeatable read（默认）- 读取的是事务刚发起时的快照
5. serialize - 没有用到 MVCC

尽管 RC 级别下违背了隔离性，但是它明确地反映了数据的变化，可以读取到当前数据的值，符合大多数项目的需求，且没有间隙锁，并发效率高，所以大厂多采用 RC 模式。

由于 mysql5.0 之前 BIN LOG 只有 STATEMENT 模式，无法与 RC 模式完美兼容，会造成主从不一致，因此 RR 作为了默认模式。

5.1 之后引入了 ROW 和 MIX 模式，但是默认依然为 STATEMENT。现在大厂多采用 RC + ROW 模式。

## 6.备份、删除、回撤

```sql
# 备份
CREATE TABLE mytable_2023_1_2 SELECT * FROM mytable;
# 删除
DELETE FROM mytable LIMIT 1;
# 回撤
INSERT INTO mytable SELECT * FROM mytable_2023_1_2;
```

**通过 EVENT 定时定量删除**

```sql
DROP EVENT event_delete;
DELIMITER $$
	CREATE EVENT IF NOT EXISTS event_delete
	ON SCHEDULE EVERY 1 SECOND on COMPLETION PRESERVE
	DO BEGIN
		DECLARE num integer;
		SELECT COUNT(*) INTO num FROM mytable;
		IF num > 0 
			THEN DELETE FROM mytable limit 1;
		END IF;
END$$
```

查看：`SHOW VARIABLES LIKE 'event_scheduler';`

开启：`SET GLOBAL event_scheduler = 1; `

关闭：`SET GLOBAL event_scheduler = 0;`

## 7.多线程读写数据

MySQL 默认有 4 条读线程和 4 条写线程，1 条 master 线程，1 条 page cleaner 线程，1 条 purge 线程。

**案例：读取 1 亿条数据插入数据库**

- 创建读取文件的线程和插入数据库的线程，中间用 MQ 衔接
  - 读取文件
    - 考虑服务器的内存设定一次读取的字节数
    - 不考虑插入顺序的话可以多线程读取
  - 插入数据库
    - 使用`batch`插入，减少与数据库的交互成本，提高插入效率
    - 插入线程可以创建 MySQL 最大的读线程数，最大效率利用 MySQL 线程；例如如果服务器 CPU 是 16 核，则可以分别指定 6 条读写线程，1 条 master 线程，1 条 page cleaner 线程，1 条 purge 线程

## 8.主键的选择

在数据量 100W 左右的时候，uuid 的插入效率垫底，并且在后序增加了 130W 的数据，uudi 的时间又直线下降。时间占用量总体可以打出的效率排名为：auto_key>random_key>uuid，uuid 的效率最低，在数据量较大的情况下，效率直线下滑。

**使用自增 ID**

自增的主键的值是顺序的，所以 Innodb 把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候（innodb 默认的最大填充因子是页大小的 15/16，会留出 1/16 的空间留作以后的修改)：

- 下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费
- 新插入的行一定会在原有的最大数据行下一行，mysql 定位和寻址很快，不会为计算新行的位置而做出额外的消耗
- 减少了页分裂和碎片的产生

缺点

- 别人一旦爬取你的数据库，就可以根据数据库的自增 id 获取到你的业务增长信息，很容易分析出你的经营情况
- 对于高并发的负载，innodb 在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争
- Auto_Increment 锁机制会造成自增锁的抢夺,有一定的性能损失

**使用 uuid**

因为 uuid 相对顺序的自增 id 来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以 innodb 无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：

- 写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb 在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机 IO

- 因为写入是乱序的，innodb 不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据

- 由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片

## 9.MySQL和PostgreSQL区别

**相同点**

- 都是关系型数据库
- 都支持 SQL 语法查找数据

**不同点**

在 Postgres 中，严格来说没有主索引，所有的索引都是二级索引，它们都指向加载在堆中的数据页中由系统管理的元组标识符，在 Postgres 中，更新和删除实际上是插入操作。每次更新或删除都会创建一个新的元组标识符。

- PG 主表采用堆表存放，MySQL 采用索引组织表

  - 堆表：数据存储在表中，索引存储在索引里，两者分开的。数据在堆中是无序的，索引让键值有序，但数据还是无序的。堆表中主键索引和普通索引一样的，都是存放指向堆表中数据的指针

  - 索引组织表：数据存储在聚簇索引中，或者说，数据按照主键的顺序来组织数据，两者合二为一。主键索引，叶子节点存放整行数据。其他索引称为辅助索引（二级索引），叶子节点存放键值和主键值

    - 优点：
      1. 降低了 IO，提高了查询的性能。尤其是当我们的数据几乎总是通过主键来进行搜索时，查询效率的提升将会很显著；并且当进行范围查询时，索引组织表只需要找到第一个符合条件的记录然后向后遍历即可，但是堆表需要进行随机IO
      2. 在 MySQL 中，更新一个未建立索引的列只会导致更新包含该行的叶子页，并将其更新为新值。不需要更新其他任何二级索引，因为它们都指向的是未发生变化的主键；在 Postgres 中，更新一个未建立索引的列将生成一个新的元组，并可能需要更新所有的二级索引以使用新的元组 ID

    - 缺点：
      1. 当索引组织表上有二级索引，并且频繁使用二级索引进行访问时，它的缺点也很明显了，那就是二级索引需要回表，它的效率要比堆表直接使用行指针访问数据的效率要低的
      2. 在 MySQL 中，选择主键数据类型非常重要，因为该键将出现在所有的二级索引中
      3. 对于长时间运行的事务，undo 日志会对其他正在运行的事务产生影响。需要更多的 I/O 操作来构建旧状态，并且 undo 日志可能会满，导致事务失败的可能性；Postgres 在这方面处理方式完全不同，每次更新、插入和删除都会得到一份具有新的元组 ID 的新行副本，并附带有关创建该元组的事务 ID 和删除该元组的事务 ID 的提示。因此，Postgres 可以安全地将更改写入数据页面，并且并发事务可以根据其事务 ID 读取旧的或新的元组（但是弊端是，如果所有正在运行的事务 ID 都大于删除元组的事务 ID，则 Postgres 需要清除不再需要的旧元组）
- 在 SQL 的标准实现上 PG 要比 MySQL 完善，而且功能实现比较严谨
- PG 的主备复制属于物理复制，相对于 MySQL 基于 binlog 的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能的影响也更小
- PG 更适合具有频繁写入操作和复杂查询的大型应用场景；MySQL 适用于读取多写入少的中小型应用场景
