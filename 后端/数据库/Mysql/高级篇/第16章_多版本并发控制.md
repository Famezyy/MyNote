# 第16章_多版本并发控制

## 1.什么是MVCC

MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的`并发控制`。这项技术使得在 InnoDB 的事务隔离级别下执行`一致性读`操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。

MVCC 没有正式的标准，在不同的 DBMS 中 MVCC 的体现方式可能是不同的，也不是普遍使用的。这里讲解`InnoDB`中 MVCC 的实现机制（MySQL 其他的存储引擎并不支持它）。

## 2.读操作的类别

MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理`读-写冲突`，做到即使有读写冲突时，也能做到`不加锁`，`非阻塞并发读`，而这个读指的就是`快照读`, 而非`当前读`。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。

### 2.1 快照读

快照读又叫一致性读，读取的是快照数据。**不加锁的简单的 SELECT 都属于快照读**，即不加锁的非阻塞读。比如这样：

```sql
SELECT * FROM player WHERE ...
```

之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于 MVCC，它在很多情况下，避免了加锁操作，降低了开销。

既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。

快照读的前提是隔离级别`不是串行级别`，串行级别下的快照读会退化成当前读。

### 2.2 当前读

当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：

```sql
# 共享锁
SELECT * FROM student LOCK IN SHARE MODE;
# 排他锁
SELECT * FROM student FOR UPDATE; 
INSERT INTO student values ...
DELETE FROM student WHERE ...
UPDATE student SET ...
```

### 2.3 半一致性读

在 5.1.15 的时候，InnoDB 引入了一个概念叫做 “semi-consistent”，减少了更新同一行记录时的冲突，减少锁等待。它只在 `READ COMMITTED` 隔离级别下（或者在开启了 `innodb_locks_unsafe_for_binlog` 系统变量，该参数 8.0 后被移除，即 8.0 版本中 `RR` 下不支持半一致性读）使用 `UPDATE` 语句时才会使用，只适用于事务 2 进行==全表扫描==的情况。

具体的含义就是当 `UPDATE` 语句读取已经被其他事务加了锁的记录时， InnoDB 会将该记录的最新提交的版本读出来，然后判断该版本是否与 `UPDATE` 语句中的 `WHERE` 条件相匹配，如果不匹配则不对该记录加锁，从而跳到下一条记录；如果匹配则再次读取该记录并对其进行加锁。这样子处理只是为了让 `UPDATE` 语句尽量少被别的语句阻塞。

表结构：

```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number),
    KEY idx_name (name)
) Engine=InnoDB CHARSET=utf8;

INSERT INTO hero VALUES
    (1, 'l刘备', '蜀'),
    (3, 'z诸葛亮', '蜀'),
    (8, 'c曹操', '魏'),
    (15, 'x荀彧', '魏'),
    (20, 's孙权', '吴');

mysql> SELECT * FROM hero;
+--------+------------+---------+
| number | name       | country |
+--------+------------+---------+
|      1 | l刘备      | 蜀      |
|      3 | z诸葛亮    | 蜀      |
|      8 | c曹操      | 魏      |
|     15 | x荀彧      | 魏      |
|     20 | s孙权      | 吴      |
+--------+------------+---------+
5 rows in set (0.01 sec)
```

开启一个事务 `T1` 并执行查询语句 `SELECT * FROM hero WHERE country = '魏' FOR UPDATE;`，虽然进行了全表扫描，但其最终只会对 number 等于 8 和 15 的记录加锁。我们可以使用 `SHOW ENGINE INNODB STATUS` 命令验证：

```sql
mysql> SHOW ENGINE INNODB STATUS\G
... 省略了很多内容

------------
TRANSACTIONS
------------
...
RECORD LOCKS space id 287 page no 3 n bits 72 index PRIMARY of table `db`.`hero` trx id 39763 lock_mode X locks rec but not gap
Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 80000008; asc     ;;
 1: len 6; hex 000000009b4a; asc      J;;
 2: len 7; hex 80000001d3012a; asc       *;;
 3: len 7; hex 63e69bb9e6938d; asc c      ;;
 4: len 3; hex e9ad8f; asc    ;;

Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
 0: len 4; hex 8000000f; asc     ;;
 1: len 6; hex 000000009b4a; asc      J;;
 2: len 7; hex 80000001d30137; asc       7;;
 3: len 7; hex 78e88d80e5bda7; asc x      ;;
 4: len 3; hex e9ad8f; asc    ;;

 ... 省略了很多内容
```

其中 `id `为 39763 的事务就是指 `T1`，可以看出它为 `heap no` 值为 4 和 5 的两条记录加了 `X 型记录锁`（lock_mode X locks rec but not gap）。

> **注意**
>
> 在 `RC` 级别下的查询语句，如果采用全表扫描的方式执行查询语句时，InnoDB 存储引擎将依次对每条记录添加记录锁，在 server 层测试该记录是否符合 `WHERE` 条件，如果不符合则会将锁释放掉。

然后再开启一个隔离级别也为 `READ COMMITTED` 的事务 `T2`，在其中执行：

```sql
# T2中，隔离级别为READ COMMITTED
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM hero WHERE country = '吴' FOR UPDATE;
(进入阻塞状态)
```

很显然，这条语句也会采用**全表扫描**的方式来执行，会依次去获取每一条聚簇索引记录的锁。不过因为 number 值为 8 的记录已经被 `T1` 加了记录锁，`T2` 只能进行阻塞状态，此时的 `SHOW ENGINE INNODB STATUS` 也能证明我们的猜想（只截取了一部分）：

```sql
---TRANSACTION 39764, ACTIVE 34 sec fetching rows
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1160, 1 row lock(s)
MySQL thread id 20, OS thread handle 123145471168512, query id 590 localhost 127.0.0.1 root Sending data
SELECT * FROM hero WHERE country = '吴' FOR UPDATE
------- TRX HAS BEEN WAITING 34 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 287 page no 3 n bits 72 index PRIMARY of table `xiaohaizi`.`hero` trx id 39764 lock_mode X locks rec but not gap waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0
0: len 4; hex 80000008; asc     ;;
1: len 6; hex 000000009b4a; asc      J;;
2: len 7; hex 80000001d3012a; asc       *;;
3: len 7; hex 63e69bb9e6938d; asc c      ;;
4: len 3; hex e9ad8f; asc    ;;
```

可以看到 `T2` 正在等待获取 `heap no` 为 4 的记录上的 X型记录锁（lock_mode X locks rec but not gap waiting）。

不过如果在 `T2` 中执行下边的 `UPDATE` 语句，则会发现没有阻塞：

```sql
# T2中，隔离级别为READ COMMITTED
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> UPDATE hero SET name = 'xxx' WHERE country = '吴';
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

因为事务 `T2` 执行 `UPDATE` 语句时使用了半一致性读，判断 number 列值为 8 和 15 这两条记录的最新提交版本的 `country` 列值均不为 `UPDATE` 语句中 `WHERE` 条件中的'吴'，所以直接就跳过它们，不对它们加锁了。

## 3.复习

### 3.1 再谈隔离级别

我们知道事务有 4 个隔离级别，可能存在三种并发问题：

<img src="img\image-20220402010700630.png" alt="image-20220402010700630" style="zoom:50%;" />

在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，他并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。

MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。

<img src="img\image-20220402010713077.png" alt="image-20220402010713077" style="zoom:50%;" />

### 3.2 隐藏字段、Undo Log版本链

对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：

- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给`trx_id`隐藏列
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息

**举例：**student 表数据如下

```sql
mysql> SELECT * FROM student;
+----+--------+--------+
| id | name   | class  |
+----+--------+--------+
|  1 | 张三   |  一班   |
+----+--------+--------+
1 rows in set (0.10 sec)
```

假设插入该记录的`事务id`为 8，那么此刻该条行记录的示意图如下所示：

<img src="img\image-20220402010738171.png" alt="image-20220402010738171" style="zoom: 50%;" />

> insert undo 只在事务回滚时起作用，当事务提交后，该类型的 undo 日志就没用了，它占用的 UndoLog Segment 也会被系统回收（也就是该 undo 日志占用的 undo 页面链表要么被重用，要么被释放）。

假设之后两个事务 id 分别为 10、20 的事务对这条记录进行 `UPDATE` 操作，操作流程如下：

| 时间顺序 |                   事务10                   |                   事务20                   |
| :------: | :----------------------------------------: | :----------------------------------------: |
|    1     |                   BEGIN;                   |                                            |
|    2     |                                            |                   BEGIN;                   |
|    3     | UPDATE student SET name="李四" WHERE id=1; |                                            |
|    4     | UPDATE student SET name="王五" WHERE id=1; |                                            |
|    5     |                  COMMIT;                   |                                            |
|    6     |                                            | UPDATE student SET name="钱七" WHERE id=1; |
|    7     |                                            | UPDATE student SET name="宋八" WHERE id=1; |
|    8     |                                            |                  COMMIT;                   |

每次对记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 `roll_pointer` 属性（`INSERT` 操作对应的 undo 日志没有该属性，因为该记录并没有更早的版本），可以将这些 `undo日志` 都连起来，串成一个链表：

<img src="img\image-20220402010932959.png" alt="image-20220402010932959" style="zoom:67%;" />

对该记录每次更新后，都会将旧值放到一条 `undo日志` 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 `roll_pointer` 属性连接成一个链表，我们把这个链表称之为 `版本链`，版本链的头节点就是当前记录最新的值。

每个版本中还包含生成该版本时对应的 `事务id`。

## 4.MVCC实现原理之ReadView

MVCC 的实现依赖于：**行记录的隐藏字段**、**Undo Log**、**Read View**。

### 4.1 什么是ReadView

在 MVCC 机制中，多个事务对同一个行记录进行更新会产d生多个历史快照，这些历史快照保存在 Undo Log 中。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 ReadView 了，它帮我们解决了行的可见性问题。

ReadView 就是一个事务在使用 MVCC 机制进行快照读操作时产生的`读视图`。当事务启动时，会生成数据库系统当前的一个快照，InnoDB 为每个事务构造了一个数组，用来记录并维护系统当前`活跃事务`的 ID（活跃指的就是，启动了但还没提交）。

### 4.2 设计思路

使用`READ UNCOMMITTE`隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。

使用`SERIALIZABLE`隔离级别的事务，InnoDB 规定使用加锁的方式来访问记录。

使用`READ COMMITTED`和`REPEATABLE READ`隔离级别的事务，都必须保证读到`已经提交了的`事务修改过的记录。不同的是`READ COMMITTED`在每次读操作时都会生成一个新的`ReadView`，`REPEATABLE READ`在只会在第一次读操作时生成一个`ReadView`。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是 ReadView 要解决的主要问题。

这个 ReadView 中主要包含 4 个比较重要的内容，分别如下：
- `creator_trx_id`，创建这个 Read View 的事务 ID

  > 说明：只读事务不分配 trx_id（会分配一个假 trx_id），只有在对表中的记录做改动时（执行 INSERT、DELETE、UPDATE 这些语句时）才会为事务分配事务 id

- `trx_ids`，表示在生成 ReadView 时当前系统中`活跃的`读写事务的`事务id列表`

- `up_limit_id`，活跃的事务中最小的事务 ID

- `low_limit_id`，表示生成 ReadView 时系统中应该分配给下一个事务的`id`值。low_limit_id 是系统最大的事务 id 值，这里要注意是系统中的事务 id，需要区别于正在活跃的事务 id

  > 注意：low_limit_id 并不是 trx_ids 中的最大值，事务 id 是递增分配的。比如，现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，trx_ids 就包括 1 和 2，up_limit_id 的值就是 1，low_limit_id 的值就是 4。

**举例：**

trx_ids 为 trx2、trx3、trx5 和 trx8 的集合，系统的最大事务 ID（low_limit_id）为 trx8+1（如果之前没有其他的新增事务），活跃的最小事务 id（up_limit_id）为 trx2。

<img src="img\image-20220402204245072.png" alt="image-20220402204245072" style="zoom:67%;" />

### 4.3 ReadView的规则

有了这个 ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的 trx_id 属性值与 ReadView 中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问
- 如果被访问版本的 trx_id 属性值小于 ReadView 中的`up_limit_id`值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问
- 如果被访问版本的 trx_id 属性值大于或等于 ReadView 中的`low_limit_id`值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问
- 如果被访问版本的 trx_id 属性值在 ReadView 的`up_limit_id`和`low_limit_id`之间，那就需要判断一下 trx_id 属性值是不是在 trx_ids 列表中
  - 如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问
  - 如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问

### 4.4 MVCC整体操作流程

了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过 MVCC 找到它：

- 首先获取事务自己的版本号，也就是事务 ID
- 获取 ReadView
- 查询得到的数据，然后与 ReadView 中的事务版本号进行比较
- 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照
- 最后返回符合规则的数据

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，以此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那就意味着这条记录对该事务完全不可见，查询结果就不包含该纪录。

> InnoDB 中，MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。

在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。

如表所示：

|                事务                 |       说明        |
| :---------------------------------: | :---------------: |
|               BEGIN;                |                   |
| SELECT * FROM student WHERE id > 2; | 获取一次Read View |
|               ......                |                   |
| SELECT * FROM student WHERE id > 2; | 获取一次Read View |
|               commit;               |                   |

> 注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。

当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的`SELECT`都会复用这个 Read View，如下表所示：

<img src="img\image-20220402011157214.png" alt="image-20220402011157214" style="zoom:67%;" />

## 5.举例说明

假设现在 student 表中只有一条由`事务id` 为 8 的事务插入的一条记录：

```sql
mysql> SELECT * FROM student;
+----+--------+--------+
| id | name   | class  |
+----+--------+--------+
|  1 | 张三   |  一班   |
+----+--------+--------+
1 rows in set (0.10 sec)
```

MVCC 只能在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。接下来看一下`READ COMMITTED`和`REPEATABLE READ`所谓的生成 ReadView 的时机不同到底不同在哪里。

### 5.1 READ COMMITTED隔离级别下

**READ COMMITTED ：每次读取数据前都生成一个ReadView**

现在有两个`事务id`分别为 10、20 的事务在执行：

```sql
#Transaction 10
BEGIN;
UPDATE student SET name="李四" WHERE id=1;
UPDATE student SET name="王五" WHERE id=1;

#Transaction 20
BEGIN;
#更新了一些别的表的记录
...
```

> 说明：事务执行过程中，只有在第一次真正修改记录时（INSERT、DELETE、UPDATE）才会被分配一个真正的事务 id，这个事务 id 时递增的。所以我们才在事务 2 中更新一些别的表的记录，目的是让它分配事务 id。

此刻，表 student 中 id 为 1 的记录得到的版本链表如下所示：

<img src="img\image-20220402011230613.png" alt="image-20220402011230613" style="zoom:67%;" />

假设现在有一个使用`READ COMMITTED`隔离级别的事务开始执行：

```sql
#使用 READ COMMITTED 隔离级别的事务
BEGIN;

#SELECT1：Transaction 10、20 未提交
SELECT * FROM student WHERE id = 1; # 得到的列 name 的值为'张三'
```

这个`SELECT1`的执行过程如下：

- 在执行`SELECT`语句时会先生成一个`ReadView`，ReadView 的`trx_idx`列表的内容就是`[10, 20]`，`up_limit_id`为 10，`low_limit_id`为 21，`creator_trx_id`为 0（假事务 id）
- 从版本链中挑选可见的记录，从图中看出，最新版本的列`name`的内容是`王五`，该版本的`trx_id`为 10，在`trx_idx`列表内，所以不符合可见性要求，根据`roll_pointer`跳到下一个版本
- 下一个版本的列`name`的内容是`李四`，该版本的`trx_id`也为 10，也在`trx_idx`列表内，所以也不符合要求，继续跳到下一个版本
- 下一个版本的列`name`的内容是`张三`，该版本的`trx_id`值为 8，小于`ReadView`中的`up_limit_id`值为 10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列`name`为`张三`的记录

之后，我们把`事务id`为 10 的事务提交一下：

```sql
#Transaction 10
BEGIN;

UPDATE student SET name="李四" WHERE id=1;
UPDATE student SET name="王五" WHERE id=1;

COMMIT;
```

然后再到`事务id`为 20 的事务中更新一下表`student`中 id 为 1 的记录：

```sql
#Transaction 20
BEGIN;

#更新了一些别的表的记录
...
UPDATE student SET name="钱七" WHERE id=1;
UPDATE student SET name="宋八" WHERE id=1;
```

此刻，表 student 中 id 为 1 的记录的版本链就长这样：

<img src="img\image-20220402011311562.png" alt="image-20220402011311562" style="zoom: 80%;" />

然后再到刚才使用`READ COMMITTED`隔离级别的事务中继续查找这个 id 为 1 的记录，如下：

```sql
#使用 READ COMMITTED 隔离级别的事务
BEGIN;

#SELECT1：Transaction 10、20 均未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为'张三'

#SELECT2：Transaction 10 提交，Transaction 20 未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为'王五'
```

这个`SELECT2`的执行过程如下：

- 在执行`SELECT`语句时又会单独生成一个`ReadView`，该`ReadView`的`trx_idx`列表的内容是`[20]`，`up_limit_id`为 20，`low_limit_id`为 21，`creator_trx_id`为 0
- 从版本链中挑选可见的记录，从图中看出，最新版本的列`name`的内容是`宋八`，该版本的`trx_id`为 20，在`trx_idx`列表内，所以不符合可见性要求，根据`roll_pointer`跳到下一个版本
- 下一个版本的列`name`的内容是`钱七`，该版本的`trx_id`也为 20，也在`trx_idx`列表内，所以也不符合要求，继续跳到下一个版本
- 下一个版本的列`name`的内容是`王五`，该版本的`trx_id`值为 10，小于`ReadView`中的`up_limit_id`值为 20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列`name`为`王五`的记录

以此类推，如果之后`事务20`的记录也提交了，再次在使用`READ COMMITTED`隔离级别的事务中查询表`student`中 id 为 1 的记录时，得到的结果就是`宋八`了。

> 强调：使用 READ COMMITTED 隔离级别的事务在**每次查询开始时都会生成一个独立的 ReadView**。

### 5.2 REPEATABLE READ隔离级别下

使用`REPEATABLE READ`隔离级别的事务来说，**只会在第一次执行查询语句时生成一个 ReadView**，之后的查询就不会重复生成了。

比如，系统里有两个`事务id`分别为 10 、 20 的事务在执行：

```sql
#Transaction 10
BEGIN;
UPDATE student SET name="李四" WHERE id=1;
UPDATE student SET name="王五" WHERE id=1;

#Transaction 20
BEGIN;
#更新了一些别的表的记录
...
```

此刻，表 student 中 id 为 1 的记录得到的版本链表如下所示：

<img src="img\image-20220402011400215.png" alt="image-20220402011400215" style="zoom:80%;" />

假设现在有一个使用`REPEATABLE READ`隔离级别的事务开始执行：

```sql
#使用 REPEATABLE READ 隔离级别的事务
BEGIN;

#SELECT1：Transaction 10、20 未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为'张三'
```

这个`SELECT1`的执行过程如下：

- 在执行`SELECT`语句时会先生成一个`ReadView`，ReadView 的`trx_idx`列表的内容就是`[10, 20]`，`up_limit_id`为 10，`low_limit_id`为 21，`creator_trx_id`为 0（假事务 id）
- 从版本链中挑选可见的记录，从图中看出，最新版本的列`name`的内容是`王五`，该版本的`trx_id`为 10，在`trx_idx`列表内，所以不符合可见性要求，根据`roll_pointer`跳到下一个版本
- 下一个版本的列`name`的内容是`李四`，该版本的`trx_id`也为 10，也在`trx_idx`列表内，所以也不符合要求，继续跳到下一个版本
- 下一个版本的列`name`的内容是`张三`，该版本的`trx_id`值为 8，小于`ReadView`中的`up_limit_id`值为 10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列`name`为`张三`的记录

之后，我们把`事务id`为 10 的事务提交一下，就像这样：

```sql
#Transaction 10
BEGIN;

UPDATE student SET name="李四" WHERE id=1;
UPDATE student SET name="王五" WHERE id=1;

COMMIT;
```

然后再到`事务id`为 20 的事务中更新一下表 student 中 id 为 1 的记录：

```sql
#Transaction 20
BEGIN;

#更新了一些别的表的记录
...
UPDATE student SET name="钱七" WHERE id=1;
UPDATE student SET name="宋八" WHERE id=1;
```

此刻，表 student 中 id 为 1 的记录的版本链长这样：

<img src="img\image-20220402011440498.png" alt="image-20220402011440498" style="zoom:80%;" />

然后再到刚才使用`REPEATABLE READ`隔离级别的事务中继续查找这个 id 为 1 的记录，如下：

```sql
#使用REPEATABLE READ隔离级别的事务
BEGIN;

#SELECT1：Transaction 10、20均未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为'张三'

#SELECT2：Transaction 10提交，Transaction 20未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为'张三'
```

这个`SELECT2`的执行过程如下：

- 因为当前事务的隔离级别是`REPEATABLE READ`，而之前在执行`SELECT1`语句时已经生成过`ReadView`，所以直接复用之前的`ReadView`，之前的`ReadView`的`trx_idx`列表的内容是`[10, 20]`，`up_limit_id`为 10，`low_limit_id`为 21，`creator_trx_id`为 0
- 从版本链中挑选可见的记录，从图中看出，最新版本的列`name`的内容是`宋八`，该版本的`trx_id`为 20，在`trx_idx`列表内，所以不符合可见性要求，根据`roll_pointer`跳到下一个版本
- 下一个版本的列`name`的内容是`钱七`，该版本的`trx_id`也为 20，也在`trx_idx`列表内，所以不符合要求，继续跳到下一个版本
- 下一个版本的列`name`的内容是`王五`，该版本的`trx_id`值为 10，也在`trx_idx`中，所以该版本也不符合要求，同理下一个`李四`的版本也不符合要求，继续跳到下一个版本
- 一个版本的列`name`的内容是`张三`，该版本的`trx_id`为 8，小于`up_limit_id`值为 10，所以这个版本符合要求，最后返回给用户的就是`张三`的记录

### 5.3 如何解决幻读

接下来说明 InnoDB 是如何解决幻读的。

假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。

<img src="img\image-20220402011502420.png" alt="image-20220402011502420" style="zoom: 50%;" />

假设现在有事务 A 和事务 B 并发执行，`事务 A`的事务 id 为 20，`事务 B`的事务 id 为 30。

步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。

```sql
SELECT * FROM student where id >= 1;
```

在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：trx_ids=[20,30]，up_limit_id=20，low_limit_id=31，creator_trx_id=20。

由于此时表 student 中只有一条数据，且符合 where id>=1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。

结论：事务 A 的第一次查询，能读取到一条数据，id=1。

步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。

```sql
insert into student(id,name) values(2,'李四');
insert into student(id,name) values(3,'王五');
```

此时表 student 中就有三条数据了，对应的 undo 如下图所示：

<img src="img\image-20220402011542604.png" alt="image-20220402011542604" style="zoom:67%;" />

步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id>=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。

- 首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到
- 然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到
- 同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见

<img src="img\image-20220402011558139.png" alt="image-20220402011558139" style="zoom:67%;" />

结论：

最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象（但是如果插入主键相同的数据则会因为主键冲突而报错），所以说在 MySQL 的可重复读隔离级别下，一般不存在幻读问题。

但是如果触发了**当前读**后会出现幻读：

|                            事务1                             |                事务2                 |
| :----------------------------------------------------------: | :----------------------------------: |
|                            BEGIN;                            |                                      |
|                      SELECT * FROM t1;                       |                BEGIN;                |
|                                                              | INSERT INTO t1 VALUE(4, "zhangsan"); |
|                                                              |               COMMIT;                |
| ==SELECT * FROM t1 FOR UPDATE;==（触发了当前读，会读取到所有数据） |                                      |

## 6.总结

这里介绍了`MVCC`在`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。

核心点在于 ReadView 的原理，`READ COMMITTD`、`REPEATABLE READ`这两个隔离级别的一个很大不同就是生成 ReadView 的时机不同：

- `READ COMMITTD`在每一次进行普通 SELECT 操作前都会生成一个 ReadView
- `REPEATABLE READ`只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView 就好了

> 说明：我们之前说执行 DELETE 语句或者更新主键的 UPDATE 语句并不会立即把对应的纪录完全从页面中删除，而是执行一个所谓的 delete mark 操作，相当于只对记录打上了一个删除标志位，这主要就是为 MVCC 服务的

通过 MVCC 我们可以解决：

- `读写之前阻塞的问题`：通过 MVCC 可以让读写互相不阻塞，提升事务并发处理能力
- `降低了死锁的概率`：因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
- `解决快照读的问题`：当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果
