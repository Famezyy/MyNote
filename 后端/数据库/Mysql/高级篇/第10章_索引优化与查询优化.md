# 第10章_索引优化与查询优化

​    都有哪些维度可以进行数据库调优？简言之：

- 索引失效、没有充分利用到索引——索引建立
- 关联查询太多 JOIN（设计缺陷或不得已的需求）——SQL 调优
- 服务器调优及各个参数设置（缓冲、线程数等）——调整 my.cnf
- 数据过多——分库分表

​    关于数据库调优的知识非常分散，不同的 DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。

​    虽然 SQL 查询优化的技术有很多，但是大方向上完全可以分成`物理查询优化`和`逻辑查询优化`。

- 物理查询优化是通过`索引`和`表连接方式`等技术来进行优化，这里重点需要索引的使用
- 逻辑查询优化是通过 SQL`等价交换`提升查询效率，即换一种查询写法

## 1.数据准备

学员表插 50 万条， 班级表插 1 万条。
**步骤1：建表**

```sql
CREATE TABLE `class` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`className` VARCHAR(30) DEFAULT NULL,
`address` VARCHAR(40) DEFAULT NULL,
`monitor` INT NULL ,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
CREATE TABLE `student` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`age` INT(3) DEFAULT NULL,
`classId` INT(11) DEFAULT NULL,
PRIMARY KEY (`id`)
#CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**步骤2：设置参数**
命令开启：允许创建函数设置：

```sql
set global log_bin_trust_function_creators=1;   # 不加global只是当前窗口有效。
```

**步骤3：创建函数**
保证每条数据都不同。

```sql
#随机产生字符串
DELIMITER //
CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
BEGIN
    DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
    DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i INT DEFAULT 0;
    WHILE i < n DO
        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
        SET i = i + 1;
    END WHILE;
    RETURN return_str;
END //
DELIMITER ;
#假如要删除
#drop function rand_string;
```

随机产生班级编号

```sql
#用于随机产生多少到多少的编号
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0; 
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1));
RETURN i; 
END //
DELIMITER ;
#假如要删除
#drop function rand_num;
```

**步骤4：创建存储过程**

```sql
#创建往stu表中插入数据的存储过程
DELIMITER //
CREATE PROCEDURE insert_stu(START INT , max_num INT)
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0;
#设置手动提交事务
REPEAT
	SET i = i + 1;
	INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
	((START+i),rand_string(6),rand_num(1,50),rand_num(1,1000));
	UNTIL i = max_num
END REPEAT;
COMMIT;
END //
DELIMITER ;
#假如要删除
#drop PROCEDURE insert_stu;
```

创建往 class 表中插入数据的存储过程

```sql
#执行存储过程，往class表添加随机数据
DELIMITER //
CREATE PROCEDURE `insert_class`(max_num INT)
BEGIN
    DECLARE i INT DEFAULT 0; 
    SET autocommit = 0;
    REPEAT
        SET i = i + 1;
        INSERT INTO class ( classname,address,monitor ) VALUES
        (rand_string(8),rand_string(10),rand_num(1,100000));
        UNTIL i = max_num
    END REPEAT;
    COMMIT;
END //
DELIMITER ;
#假如要删除
#drop PROCEDURE insert_class;
```

**步骤5：调用存储过程**
class

```sql
#执行存储过程，往class表添加1万条数据 
CALL insert_class(10000);
```

stu

```sql
#执行存储过程，往stu表添加50万条数据 
CALL insert_stu(100000,500000);
```

**步骤6：删除某表上的索引**
创建存储过程

```sql
DELIMITER //
CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE ct INT DEFAULT 0;
    DECLARE _index VARCHAR(200) DEFAULT '';
#seq_in_index：联合索引中的序号
    DECLARE _cur CURSOR FOR SELECT index_name FROM information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND seq_in_index=1 AND index_name <> 'PRIMARY';
#每个游标必须使用不同的 declare continue handler for not found set done=1 来控制游标的结束
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done=2;
#若没有数据返回,程序继续,并将变量done设为2
    OPEN _cur;
    FETCH _cur INTO _index;
    WHILE _index <> '' DO
        SET @str = CONCAT("drop index " , _index , " on " , tablename);
#将字符串转为 SQL 语句
        PREPARE sql_str FROM @str;
        EXECUTE sql_str;
	DEALLOCATE PREPARE sql_str;
	SET _index='';
	FETCH _cur INTO _index;
    END WHILE;
    CLOSE _cur;
END //
DELIMITER ;
```

执行存储过程

```sql
CALL proc_drop_index("dbname","tablename");
```

## 2.索引失效案例

​    MySQL中`提高性能`的一个最有效的方式是对数据表`设计合理的索引`。索引提供了高校访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

- 使用索引可以`快速地定位`表中的某条记录，从而提高数据库查询的速度，提高数据库的性能
- 如果查询时没有使用索引，查询语句就会扫描表中的`所有记录`

​    大多数情况下（默认）都采用`B+树`来构建索引。只是空间列类型的索引使用`R-树`，并且 MEMORY 表还支持`hash索引`。

​    其实，用不用索引最终由优化器决定。优化器是基于`成本开销（CostBaseOptimizer）`，他不是基于`规则（Rule-BasedOptimizer）`，也不是基于`语义`，怎么开销小就怎么来。另外，SQL 语句是否使用索引，跟**数据库版本**、**数据量**、**数据选择度**都有关系。

### 2.1 全值匹配我最爱

系统中经常出现的 sql 语句如下：

```sql
EXPLAIN SELECT * FROM student WHERE age=30;
EXPLAIN SELECT * FROM student WHERE age=30 and classId=4;
EXPLAIN SELECT * FROM student WHERE age=30 and classId=4 AND name = 'abcd';
```

建立索引前执行：（关注执行时间）

```sql
mysql> SELECT * FROM student WHERE age=30 and classId=4 AND name="abcd";
Empty set, 1 warning (0.21 sec)
```

**建立索引**

```sql
CREATE INDEX idx_age ON student(age);
CREATE INDEX idx_age_classid ON student(age,classId);
CREATE INDEX idx_age_classid_name ON student(age,classId,name);
```

建立索引后执行：

```sql
mysql> SELECT * FROM student WHERE age=30 and classId=4 AND name="abcd";
Empty set, 1 warning (0.00 sec)
```

### 2.2 最佳左前缀法则

在 MySQL 建立联合索引时会遵守`最佳左前缀原则`，即最左优先，在检索数据时从联合索引的`最左边开始匹配`。

举例 1：仅使用 age 的索引。

```sql
mysql> EXPLAIN SELECT * FROM student WHERE student.age = 30 AND student.name = 'abcd';
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                                | key     | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age,idx_age_classid,idx_age_classid_name | idx_age | 5       | const | 10169 |    10.00 | Using where |
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

举例 2：不会使用索引。

```sql
mysql> EXPLAIN SELECT * FROM student WHERE student.classid = 1 AND student.name = 'abcd';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |     1.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

举例 3：使用了联合索引。

```sql
mysql> EXPLAIN SELECT * FROM student WHERE classid = 4 AND student.age = 30 AND student.name = 'abcd';
+----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys                                | key                  | key_len | ref               | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age,idx_age_classid,idx_age_classid_name | idx_age_classid_name | 73      | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

如果索引了多列，要遵守`最左前缀法则`，指的是查询从索引的最左前列开始并且不跳过索引中的列。如下面的查询因为跳过了 classId，所以`不会使用到联合索引`，仅使用了 age 上的索引：

```sql
mysql> EXPLAIN SELECT * FROM student WHERE student.age = 30 AND student.name = 'abcd';
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                                | key     | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age,idx_age_classid,idx_age_classid_name | idx_age | 5       | const | 10169 |    10.00 | Using where |
+----+-------------+---------+------------+------+----------------------------------------------+---------+---------+-------+-------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

​    **结论：**MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段，对于多列索引，`过滤条件要使用索引必须按照索引建立时的顺序依次满足，一旦跳过某个字段，索引后面的字段都无法使用`，如果查询条件中没有使用这些字段中第 1 个字段时，联合索引不会被使用。

> 拓展：Alibaba《Java开发手册》
> 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

### 2.3 主键插入顺序

​    对于一个使用`InnoDB`存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在`聚簇索引`的叶子结点的。而记录又是存储在数据页中的，数据页和记录又是按照记录`主键值从小到大`的顺序进行排序，所以如果我们`插入`的记录的`主键值是依次增大`的话，那我们每插满一个数据页就换到了下一个数据页继续插，而如果我们插入的`主键值忽大忽小`的话，假设某个数据页存储的纪录已经满了，它存储的主键值在`1~100`之间：

<img src="img\image-20220215234105002.png" alt="image-20220215234105002" style="zoom:67%;" />

如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：

<img src="img\image-20220215234119704.png" alt="image-20220215234119704" style="zoom:67%;" />

​    可这个数据页已经满了，再插进来咋办呢？我们需要把当前`页面分裂`成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：`性能损耗`！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的`主键值依次递增`，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入，比如：person_info 表：

```sql
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
); 
```

   我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。

### 2.4 计算、函数、类型转换(自动或手动)导致索引失效

**这两条 SQL 哪种写法好**

第一种能够使用上索引，第二种因为`使用了函数，所以不会使用索引`。

```sql
EXPLAIN SELECT * FROM student WHERE student.name LIKE 'abc%';
```

```sql
EXPLAIN SELECT * FROM student WHERE LEFT(student.name,3) = 'abc';
```

**创建索引**

```sql
CREATE INDEX idx_name ON student(NAME);
```

**第一种：索引优化生效**

```sql
mysql> EXPLAIN SELECT * FROM student WHERE student.name LIKE 'abc%';
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_name      | idx_name | 63      | NULL |   24 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

**第二种：索引优化失效**

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

type 为 ALL，表示没有使用到索引，查询效率较之前会低很多。

**再举例：**

student 表的字段 stuno 上设置有索引：

```sql
CREATE INDEX idx_sno ON student(stuno);
```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

​    `如果使用了表达式计算，索引就失效了`。这是因为我们需要把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是`全表扫描`的方式，运行时间也会慢很多。

索引优化生效：

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

**再举例：**
student 表的字段 name 上设置有索引

```sql
CREATE INDEX idx_name ON student(NAME);
```

我们想要对 name 的前三位为 abc 的内容进行条件筛选，这里我们来查看下执行计划：

```sql
# 索引优化失败
mysql> EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)='abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

```sql
# 索引优化生效
mysql> EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE 'abc%';
# filtered：20 * 3 + 2 + 1
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_name      | idx_name | 63      | NULL |   24 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

### 2.5 类型转换导致索引失效

```sql
# 未使用到索引
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_name      | NULL | NULL    | NULL | 499086 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 5 warnings (0.00 sec)
```

```sql
# 使用到索引
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name='123';
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_name      | idx_name | 63      | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 2 warnings (0.00 sec)
```

name=123 发生类型转换，索引失效。

### 2.6 范围条件右边的列索引失效

```sql
CALL proc_drop_index('myDatabase2', 'student');
create index idx_age_name_classid on student(age,classid,name);
```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student.name = 'abc';
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_name_classid | idx_age_name_classid | 10      | NULL | 18402 |    10.00 | Using index condition |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+
1 row in set, 2 warnings (0.00 sec)
```

​    此时`idx_age_name_classid`索引将不能被全部使用（len 仅为 3），`范围右边的列不能使用索引`，比如：<、<=、>、>= 和 between 等。因为过滤条件时，**当发现第二个索引用了范围查询，则会直接查询在B+树中符合该索引范围的各个节点，不会查询每个节点的第三个索引**。

​    如果这种 sql 出现较多，应该将范围查询条件放置语句最后：

```sql
CALL proc_drop_index('myDatabase2', 'student');
create index idx_age_name_classid on student(age,name,classid);
```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student.name = 'abc';
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_name_classid | idx_age_name_classid | 73      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
1 row in set, 2 warnings (0.00 sec)

```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abc' AND student.classId>20;
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_name_classid | idx_age_name_classid | 73      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+
1 row in set, 2 warnings (0.00 sec)
```

> 应用开发中范围查询，例如：金额查询、日期查询往往都是范围查询，应该将查询条件放置 where 语句最后（创建的联合索引中务必把范围涉及到的字段放到最后）

### 2.7 非运算(!= 或者<>或者 is not)索引失效

为 name 字段创建索引：

```sql
CALL proc_drop_index('myDatabase2', 'student');
create index idx_name on student(name);
```

```sql
# 索引成功：使用等值判断时
mysql> EXPLAIN SELECT * FROM student WHERE student.name = 'abc';
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_name      | idx_name | 63      | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

# 索引失效
mysql> EXPLAIN SELECT * FROM student WHERE student.name <> 'abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_name      | NULL | NULL    | NULL | 499086 |    50.15 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

```sql
# 索引失效
mysql> EXPLAIN SELECT * FROM student WHERE student.name != 'abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_name      | NULL | NULL    | NULL | 499086 |    50.15 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

> 注意：==有<a href="#8.优先考虑覆盖索引">索引覆盖</a>时，依然可能会使用到索引！==

### 2.8 is null可以使用索引，is not null无法使用索引

创建索引

```sql
CREATE INDEX idx_age ON student(age);
```

**IS NULL 可以触发索引**

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;
+----+-------------+---------+------------+------+---------------+---------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+---------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age       | idx_age | 5       | const |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+------+---------------+---------+---------+-------+------+----------+-----------------------+
1 row in set, 2 warnings (0.00 sec)
```

**IS NOT NULL 无法使用索引**

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age       | NULL | NULL    | NULL | 499086 |    50.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

> 结论：最好在设计数据表的时候就将`字段设置为 NOT NULL 约束`，比如可以将 INT 类型的字段默认值设置为 0，将字符类型的默认值设置为空字符串('')。
>
> 拓展：同理，在查询中使用`NOT LIKE`也无法使用索引，导致全表扫描。

### 2.9 like以通配符%开头索引失效

在使用`LIKE`关键字进行查询时，如果匹配字符串的第一个字符为`%`，索引就会失效，只有`%`不在第一个位置时索引才会起作用。

```sql
# 使用到索引
mysql> EXPLAIN SELECT * FROM student WHERE name LIKE 'ab%';
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_name      | idx_name | 63      | NULL |  731 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

```sql
# 未使用到索引
mysql> EXPLAIN SELECT * FROM student WHERE name LIKE '%ab%';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

> 拓展：Alibaba《Java开发手册》
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

### 2.10 OR前后存在非索引的列，索引失效

​    在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效，即`OR前后的两个条件中的列都是索引时，查询中才会使用索引`，因为 OR 含义就是两个只要满足一个即可，因此`只有一个条件列进行索引是没有意义的`，只要有条件列没有索引，那么就会进行`全表扫描`。

​    查询语句使用 OR 关键字的情况：

```sql
# 未使用到索引
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age       | NULL | NULL    | NULL | 499086 |    11.88 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

```sql
#使用到索引——index_merge
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = 'Abel';
+----+-------------+---------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table   | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+---------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | student | NULL       | index_merge | idx_name,idx_age | idx_age,idx_name | 5,63    | NULL | 9893 |   100.00 | Using union(idx_age,idx_name); Using where |
+----+-------------+---------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
1 row in set, 2 warnings (0.00 sec)
```

### 2.11 对于非主键索引的范围查询

对于以下语句：`select * from DB where a > 10`，`a`为辅助索引，则根据版本不同索引使用也不相同。

对于 5.6 以前的版本，mysql 会考虑以下两种场景的效率：

（1）每完成一次辅助索引的查询就会回表，对于 3 层 B+ 树，若辅助索引查询结果为 5 条，则总共要进行 15 次 IO 操作

（2）直接对聚簇索引进行全表扫描

如果阈值为 20 万条数据，则当数据少于 20 万时，会进行全表扫描。

对于 5.6 及之后的版本，mysql 引入了**MutiRange Read**，在查询辅助索引时，会一次性查询完所有符合条件的记录，在 InnoDB 的存储层对主键进行排序，然后再进行回表操作。

### 2.12 数据库和表的字符集统一使用utf8mb4

统一使用 utf8mb4（5.5.3 版本以上支持）兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的`字符集`进行比较前需要进行`转换`会造成索引失效。

### 2.13 练习及一般性建议

练习：假设创建了一个索引 index(a,b,c)



| Where语句                                           | 索引是否被使用                                               |
| --------------------------------------------------- | ------------------------------------------------------------ |
| where a = 3                                         | Y,使用到 a                                                   |
| where a = 3 and b = 5                               | Y,使用到 a,b                                                 |
| where a = 3 and b = 5 and c =4                      | Y,使用到 a,b,c                                               |
| where b = 3 or where b = 3 and c = 4 or where c = 4 | N                                                            |
| where a = 3and c = 5                                | 使用到 a， 但是 c 不可以，b 中间断了                         |
| where a = 3 and b > 4 and c = 5                     | 使用到 a 和 b，c 不能用在范围之后，b 断了                    |
| where a is null and b is not null                   | is null 支持索引 但是is not null 不支持,所以 a 可以使用索引,但是 b不可以使用 |
| where a <> 3                                        | N                                                            |
| where abs(a) =3                                     | N                                                            |
| where a = 3 and b like ‘kk%’ and c = 4              | Y,使用到 a,b,c                                               |
| where a = 3 and b like ‘%kk’ and c = 4              | Y,只用到 a                                                   |
| where a = 3 and b like ‘%kk%’ and c = 4             | Y,只用到 a                                                   |
| where a = 3 and b like ‘k%kk%’ and c = 4            | Y,使用到 a,b,c                                               |

**一般性建议：**

- 对于单列索引，计量选择针对当前 query `重复性最低`的索引
- 在选择组合索引的时候，当前 query 中`重复性最低的字段`在索引字段顺序中位置`越靠前越好`
- 在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引
- 在选择组合索引的时候，如果某个字段可能出现`范围查询`时，尽量把这个字段`放在索引次序的最后面`

## 3.关联查询优化

### 3.1 数据准备

```sql
#分类
CREATE TABLE IF NOT EXISTS `type` (
    `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `card` INT(10) UNSIGNED NOT NULL,
    PRIMARY KEY (`id`)
);
# 图书
CREATE TABLE IF NOT EXISTS `book` (
    `bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    `card` INT(10) UNSIGNED NOT NULL,
    PRIMARY KEY (`bookid`)
);

#向分类表中添加 20 条记录
INSERT INTO type(card) VALUES(FLOOR(1 + (RAND() * 28)));
#向图书表中添加 20 条记录
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 28)));
```

### 3.2 采用左外连接

**下面开始 EXPLAIN 分析**

```sql
mysql> EXPLAIN SELECT * FROM `type` LEFT JOIN book ON type.card = book.card;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                       |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
2 rows in set, 2 warnings (0.00 sec)
```

结论：type 有All。
**添加索引优化**

```sql
ALTER TABLE book ADD INDEX Y (card);  #【被驱动表】，可以避免全表扫描
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL                  |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | Y             | Y    | 4       | myDatabase2.type.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

​    可以看到第二行的`type`变为了`ref`，`rows`也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以`右边是我们的关键点，一定需要建立索引`。

```sql
ALTER TABLE `type` ADD INDEX X (card); #【驱动表】，无法避免全表扫描
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | index | NULL          | X    | 4       | NULL                  |   20 |   100.00 | Using index |
|  1 | SIMPLE      | book  | NULL       | ref   | Y             | Y    | 4       | myDatabase2.type.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

接着：

```sql
DROP INDEX Y ON book;
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | type  | NULL       | index | NULL          | X    | 4       | NULL |   20 |   100.00 | Using index                                |
|  1 | SIMPLE      | book  | NULL       | ALL   | NULL          | NULL | NULL    | NULL |   20 |   100.00 | Using where; Using join buffer (hash join) |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+
2 rows in set, 2 warnings (0.00 sec)
```

### 3.3 采用内连接

```sql
drop index X on type;
drop index Y on book;（如果已经删除了可以不用再执行该操作）
```

换成 inner join（MySQL 自动选择驱动表）

```sql
mysql> EXPLAIN SELECT * FROM type INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                       |
|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   20 |    10.00 | Using where; Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

**添加索引优化**

```sql
# CREATE INDEX X ON `type`(card)
ALTER TABLE book ADD INDEX Y(card);
mysql> EXPLAIN SELECT * FROM type INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL                  |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | Y             | Y    | 4       | myDatabase2.type.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

```sql
ALTER TABLE type ADD INDEX X(card); 
mysql> EXPLAIN SELECT * FROM type INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | book  | NULL       | index | Y             | Y    | 4       | NULL                  |   20 |   100.00 | Using index |
|  1 | SIMPLE      | type  | NULL       | ref   | X             | X    | 4       | myDatabase2.book.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

对于内连接来说，==查询优化器可以决定谁作为驱动表，谁作为被驱动表==，可以看到这里`book`作为了驱动表。

> 这里 book 表的索引类型为`index`，额外信息为`Using index`，即使用了索引覆盖（SELECT 的项目可以全部从索引中直接得到，不需要回表），但需要扫描 book 表的全部的索引记录

接着：

```sql
DROP INDEX X ON `type`;
```

```sql
mysql> EXPLAIN SELECT * FROM type INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | ALL  | NULL          | NULL | NULL    | NULL                  |   20 |   100.00 | NULL        |
|  1 | SIMPLE      | book  | NULL       | ref  | Y             | Y    | 4       | myDatabase2.type.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

对于内连接来说，==如果表的连接条件中只有一个字段有索引，则有索引的字段所在的表会被当作被驱动表出现==，此时效率更高。

接着：

```sql
ALTER TABLE `type` ADD INDEX X (card);
```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | book  | NULL       | index | Y             | Y    | 4       | NULL                  |   20 |   100.00 | Using index |
|  1 | SIMPLE      | type  | NULL       | ref   | X             | X    | 4       | myDatabase2.book.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

接着向`book`（主驱动表）中添加数据

```sql
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 28)));
```

再次查看查询分析：

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card=book.card;
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
|  1 | SIMPLE      | type  | NULL       | index | X             | X    | 4       | NULL                  |   20 |   100.00 | Using index |
|  1 | SIMPLE      | book  | NULL       | ref   | Y             | Y    | 4       | myDatabase2.type.card |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+-----------------------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

​    对于内连接来说，==在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表，即小表驱动大表==。

### 3.4 JOIN语句原理

​    join 方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环（Nested Loop Join）。如果关联表的数据量很大，则 join 关联的执行时间会非常长。在 MySQL5.5 以后，MySQL 通过引入 BNLJ 算法来优化嵌套执行。

#### 1.驱动表和被驱动表

驱动表就是主表，被驱动表就是从表、非驱动表。

- 对于内连接来说：

  ```sql
  SELECT * FROM A JOIN B ON ...
  ```

   A 不一定是驱动表，优化器会根据查询语句做出优化，决定先查哪张表，先查询的就是驱动表。通过 EXPLAIN 关键字查看（上边的是驱动表）。

- 对于外连接来说：

  ```sql
  SELECT * FROM A LEFT JOIN B ON ...
  SELECT * FROM B RIGHT JOIN A ON ...
  ```

  通常认为 A 是驱动表，B 是被驱动表，但也未必：

  ```sql
  CREATE TABLE a(f1 INT, f2 INT, INDEX(f1))ENGINE=INNODB;
  CREATE TABLE b(f1 INT, f2 INT)ENGINE=INNODB;
  
  INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
  INSERT INTO b VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
  
  #测试1（优化器转换成了内连接）
  mysql> EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) WHERE a.f2=b.f2;
  +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+
  | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref              | rows | filtered | Extra       |
  +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+
  |  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL             |    6 |   100.00 | Using where |
  |  1 | SIMPLE      | a     | NULL       | ref  | f1            | f1   | 5       | myDatabase2.b.f1 |    1 |    16.67 | Using where |
  +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+
  2 rows in set, 1 warning (0.00 sec)
  
  #测试2
  mysql> EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) AND a.f2=b.f2;
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
  | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
  |  1 | SIMPLE      | a     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL                                       |
  |  1 | SIMPLE      | b     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | Using where; Using join buffer (hash join) |
  +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
  2 rows in set, 1 warning (0.00 sec)
  ```

#### 2.简单嵌套循环连接（Simple Nested-Loop Join）

算法相当简单，从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result，以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断：

<img src="img\image-20220217203448060.png" alt="image-20220217203448060" style="zoom:67%;" />

可以看到这种方式效率非常低，如果 A 表有 100 条数据，B 表有 1000 条数据，则会查询 100 * 1000 = 10 万次，开销统计如下：

| 开销统计         | SNLJ  |
| ---------------- | ----- |
| 外表扫描次数     | 1     |
| 内表扫描次数     | A     |
| 读取记录数       | A+B*A |
| JOIN 比较次数    | B*A   |
| 回表读取记录次数 | 0     |

当然 mySQL 不会这样去连接表，所以出现了后面两种对 Nested-Loop Join 优化算法。

#### 3.索引嵌套循环连接（Index Nested-Loop Join）

​    Index Nested-Loop Join 优化的思路主要是为了`减少内层表数据的匹配次数`，所以要求被驱动表上必须`有索引`才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少的对内层表的匹配次数。

<img src="img\image-20220217204051571.png" alt="image-20220217204051571" style="zoom:67%;" />

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本比较固定，所以 MySQL 优化器都倾向于使用记录数少的表作为驱动表。

| 开销统计         | SNLJ  | INLJ                  |
| ---------------- | ----- | --------------------- |
| 外表扫描次数     | 1     | 1                     |
| 内表扫描次数     | A     | 0                     |
| 读取记录数       | A+B*A | A+B(匹配的个数)       |
| JOIN 比较次数    | B*A   | A*Index(Height)       |
| 回表读取记录次数 | 0     | B(match)(if possible) |

如果被驱动表加索引，效率非常高，但如果索引不是主键索引，还得进行一次回表查询，相比，被驱动表的索引是主键索引时效率会更高。

#### 4.块嵌套循环连接（Block Nested-Loop Join）

​    如果存在索引，那么会使用 Index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫面的次数太多。每次访问被驱动表，表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配。这样大大增加了 IO 的次数，为了减少被驱动表的 IO 次数，就出现了`块嵌套循环连接`。

​    不再是逐条获取，而是`一块一块的获取驱动表的数据`，引入了`join buffer缓冲区`，将驱动表 join 相关的部分数据列（大小手 join buffer 的限制）缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合成一次，降低了被驱动表的访问频率。

> 注意：
>
> ​    这里缓存的不只是关联表的列，select 后面的列也会缓存起来，在一个有 N 个 join 关联的 sql 中会分配 N-1 个 join buffer，所以查询的时候尽量减少不必要的字段，可以让 join buffer 中存放更多的列。

<img src="img\image-20220217205200376.png" alt="image-20220217205200376" style="zoom:67%;" />

| 开销统计         | SNLJ      | INLJ                  | BNLJ                                              |
| ---------------- | --------- | --------------------- | ------------------------------------------------- |
| 外表扫描次数     | 1         | 1                     | 1                                                 |
| 内表扫描次数     | A         | 0                     | A * used_column_size / join_buffer_size + 1       |
| 读取记录数       | A + B * A | A + B(匹配的个数)     | A + B * (A * used_column_size / join_buffer_size) |
| JOIN 比较次数    | B * A     | A * Index(Height)     | B * A                                             |
| 回表读取记录次数 | 0         | B(match)(if possible) | 0                                                 |

参数设置：

**block_nested_loop**

通过`SHOW VARIABLES LIKE '%optimizer_switch%'`查看`block_nested_loop`状态，默认是开启的（ON）。

<a id="关联缓存">**join_buffer_size**</a>

驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下`join_buffer_size=256k`。

```sql
mysql> SHOW VARIABLES LIKE '%join_buffer%';
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| join_buffer_size | 262144 |
+------------------+--------+
1 row in set (0.00 sec)
```

join_buffer_size 最大可以在 32 位系统中申请到 4G，64 位操作系统下可以申请大于 4G 的空间（Windows 中会被截断为 4GB 并发出警告）。

#### 5.Join小结

1、整体效率：INLJ > BNLJ > SNLJ

2、永远用小结果集驱动大结果集（本质就是减少外层循环的数据量）（小的度量单位指的是`表行数 * 每行大小`）

```sql
# straight_join：明确左边的为驱动表
select t1.b, t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id < 100; # 推荐
select t1.b, t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id < 100; # 不推荐
```

3、为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数），且需要 JOIN 的字段，数据类型保持绝对一致

4、增大 join buffer size 的大小（一次缓存越多的数据，内层表的扫描次数越少）

5、减少驱动表不必要的字段查询（字段越少，join buffer 所缓存的数据就越多）

6、能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)

#### 6.Hash Join

从 MySQL 的 8.0.20 版本开始将废弃 BNLJ，因为从 MySQL 8.0.18 版本开始加入了 hash join 默认都会使用`hash join`。

> ​    连接（join）是数据库表之间的常用操作，通过把多个表之间某列相等的元组提取出来组成新的表。两个表若是元组数目过多，逐个遍历开销就很大，哈希连接就是一种提高连接效率的方法。哈希连接主要分为两个阶段：建立阶段（build phase)和探测阶段（probe phase)。
>
> - **Bulid Phase**
>
>   选择一个表（一般情况下是较小的那个表，以减少建立哈希表的时间和空间），对其中每个元组上的连接属性（join attribute)采用哈希函数得到哈希值，从而建立一个哈希表。
>
> - **Probe Phase**
>
>   ​    对另一个表，扫描它的每一行并计算连接属性的哈希值，与bulid phase建立的哈希表对比，若有落在同一个bucket的，如果满足连接谓词（predicate)则连接成新的表。在内存足够大的情况下建立哈希表的过程时整个表都在内存中，完成连接操作后才放到磁盘里。但这个过程也会带来很多的I/O操作。

- Nested Loop

  对于被连接的数据子集比较小的情况，Nested Loop 是个较好的选择。

- Hash Join 

  是做`大数据集连接`时常用方式，优化器使用两个表中较小的表利用 join key 在内存中建立`散列表`，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。

  - 这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成文之和
  - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成`若干个不同的分区`，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能
  - 它能够很好地工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接（如 WHERE A.col1 = B.col2），这是由 Hash 的特点决定的

| 类别     | Nested Loop                                                  | Hash Join                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用条件 | 任何条件                                                     | 等值连接                                                     |
| 相关资源 | CPU、磁盘 I/O                                                | 内存、临时空间                                               |
| 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果 | 当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高 |
| 特点     | 当索引丢失或者查询条件限制不够时，效率很低；当表的记录数多时，效率低 | 建立哈希表需要消耗大量内存，第一次的结果返回较慢             |

## 4.子查询优化

​    MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。`子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作`。
​    ==子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。==原因：

- 执行子查询时，MySQL 需要为内层查询语句的查询结果`建立一个临时表`，然后外层查询语句从临时表中查询记录。查询完毕后，再`撤销这些临时表`。这样会消耗过多的CPU和IO资源，产生大量的慢查询

- 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都`不会存在索引`，所以查询性能会受到一定的影响

  > MySQL临时表分为“内存临时表”和“磁盘临时表”，其中内存临时表使用 MySQL 的 MEMORY 存储引擎，磁盘临时表使用 MySQL 的 MyISAM 存储引擎

- 对于返回结果集比较大的子查询，其对查询性能的影响也就越大

​    ==在MySQL中，可以使用连接（JOIN）查询来替代子查询==。连接查询`不需要建立临时表`，其`速度比子查询要快`，如果查询中使用索引的话，性能就会更好。

- 使用子查询

  > MySQL 从 8.0.16 开始，`增加对 EXISTS 的优化`，和 IN 一样也支持自动转换成`semi join`，从 8.0.18 开始，又`增加了对 NOT EXISTS 转变成 anti join 的优化`
  >
  > 总结：
  >
  > |            | 使用索引                             |
  > | ---------- | ------------------------------------ |
  > | IN         | 支持：会优化为`semi join`            |
  > | NOT IN     | ✖                                    |
  > | EXISTS     | 8.0.16 开始支持：会优化为`semi join` |
  > | NOT EXISTS | 8.0.18 开始支持：会优化为`anti join` |
  >
  > 

  ```sql
  #创建班级表中班长的索引
  CREATE INDEX idx_monitor ON class(monitor);
  ```

  ```sql
  mysql> EXPLAIN SELECT * FROM student stu1 WHERE stu1.stuno IN (SELECT monitor FROM class c WHERE monitor IS NOT NULL);
  +----+--------------+-------------+------------+--------+---------------------+---------------------+---------+------------------------+--------+----------+--------------------------+
  | id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref                    | rows   | filtered | Extra                    |
  +----+--------------+-------------+------------+--------+---------------------+---------------------+---------+------------------------+--------+----------+--------------------------+
  |  1 | SIMPLE       | stu1        | NULL       | ALL    | NULL                | NULL                | NULL    | NULL                   | 499086 |   100.00 | NULL                     |
  |  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_distinct_key> | <auto_distinct_key> | 5       | myDatabase2.stu1.stuno |      1 |   100.00 | NULL                     |
  |  2 | MATERIALIZED | c           | NULL       | index  | idx_monitor         | idx_monitor         | 5       | NULL                   |   9952 |   100.00 | Using where; Using index |
  +----+--------------+-------------+------------+--------+---------------------+---------------------+---------+------------------------+--------+----------+--------------------------+
  3 rows in set, 1 warning (0.00 sec)
  
  # 此时优化器会优化成 semi join，所以依然使用到了索引
  mysql> show warnings;
  ...
  | Note  | 1003 | /* select#1 */ select `myDatabase2`.`stu1`.`id` AS `id`,`myDatabase2`.`stu1`.`stuno` AS `stuno`,`myDatabase2`.`stu1`.`name` AS `name`,`myDatabase2`.`stu1`.`age` AS `age`,`myDatabase2`.`stu1`.`classId` AS `classId` from `myDatabase2`.`student` `stu1` semi join (`myDatabase2`.`class` `c`) where ((`<subquery2>`.`monitor` = `myDatabase2`.`stu1`.`stuno`) and (`myDatabase2`.`c`.`monitor` is not null)) |
  ...
  1 row in set (0.00 sec)
  ```

- 推荐：使用多表查询

  ```sql
  mysql> EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c ON stu1.stuno = c.monitor WHERE c.monitor IS NOT NULL;
  +----+-------------+-------+------------+------+---------------+-------------+---------+------------------------+--------+----------+-------------+
  | id | select_type | table | partitions | type | possible_keys | key         | key_len | ref                    | rows   | filtered | Extra       |
  +----+-------------+-------+------------+------+---------------+-------------+---------+------------------------+--------+----------+-------------+
  |  1 | SIMPLE      | stu1  | NULL       | ALL  | NULL          | NULL        | NULL    | NULL                   | 499086 |   100.00 | Using where |
  |  1 | SIMPLE      | c     | NULL       | ref  | idx_monitor   | idx_monitor | 5       | myDatabase2.stu1.stuno |      1 |   100.00 | Using index |
  +----+-------------+-------+------------+------+---------------+-------------+---------+------------------------+--------+----------+-------------+
  2 rows in set, 1 warning (0.00 sec)
  ```

- 不推荐

  ```sql
  mysql> EXPLAIN SELECT a.* FROM student a WHERE a.stuno NOT IN (SELECT monitor FROM class b WHERE monitor IS NOT NULL);
  +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+--------------------------+
  | id | select_type | table | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra                    |
  +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+--------------------------+
  |  1 | PRIMARY     | a     | NULL       | ALL   | NULL          | NULL        | NULL    | NULL | 499086 |   100.00 | Using where              |
  |  2 | SUBQUERY    | b     | NULL       | index | idx_monitor   | idx_monitor | 5       | NULL |   9952 |   100.00 | Using where; Using index |
  +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+--------------------------+
  2 rows in set, 1 warning (0.00 sec)
  
  # 使用了 materialize 物化表
  mysql> show warnings;
  ...
  | Note  | 1003 | /* select#1 */ select `myDatabase2`.`a`.`id` AS `id`,`myDatabase2`.`a`.`stuno` AS `stuno`,`myDatabase2`.`a`.`name` AS `name`,`myDatabase2`.`a`.`age` AS `age`,`myDatabase2`.`a`.`classId` AS `classId` from `myDatabase2`.`student` `a` where <in_optimizer>(`myDatabase2`.`a`.`stuno`,`myDatabase2`.`a`.`stuno` in ( <materialize> (/* select#2 */ select `myDatabase2`.`b`.`monitor` from `myDatabase2`.`class` `b` where (`myDatabase2`.`b`.`monitor` is not null) having true ), <primary_index_lookup>(`myDatabase2`.`a`.`stuno` in <temporary table> on <auto_distinct_key> where ((`myDatabase2`.`a`.`stuno` = `<materialized_subquery>`.`monitor`)))) is false) |
  ...
  1 row in set (0.00 sec)
  ```

- 推荐

  ```sql
  mysql> EXPLAIN SELECT a.* FROM student a LEFT OUTER JOIN class b ON a.stuno = b.monitor WHERE b.monitor IS NULL;
  +----+-------------+-------+------------+------+---------------+-------------+---------+---------------------+--------+----------+--------------------------+
  | id | select_type | table | partitions | type | possible_keys | key         | key_len | ref                 | rows   | filtered | Extra                    |
  +----+-------------+-------+------------+------+---------------+-------------+---------+---------------------+--------+----------+--------------------------+
  |  1 | SIMPLE      | a     | NULL       | ALL  | NULL          | NULL        | NULL    | NULL                | 499086 |   100.00 | NULL                     |
  |  1 | SIMPLE      | b     | NULL       | ref  | idx_monitor   | idx_monitor | 5       | myDatabase2.a.stuno |      1 |   100.00 | Using where; Using index |
  +----+-------------+-------+------------+------+---------------+-------------+---------+---------------------+--------+----------+--------------------------+
  2 rows in set, 1 warning (0.00 sec)
  ```

> 结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用`LEFT JOIN xxx ON xx WHERE xx IS NULL`替代
>
> <img src="img\image-20220217215625662.png" alt="image-20220217215625662" style="zoom:67%;" />

## 5.排序优化

### 5.1 排序优化

**问题：**在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？

**回答：**

在 MySQL 中，支持两种排序方式，分别是`FileSort`和`Index`排序

- Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高
- FileSort 排序则一般在`内存中`进行排序，占用`CPU较多`，如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低

**优化建议：**

- SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中`避免全表扫描`，在 ORDER BY 子句`避免使用 FileSort 排序`。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率
- 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引
- 无法使用 Index 时，需要对 FileSort 方式进行调优

### 5.2 测试

删除 student 表和 class 表中已创建的非主键索引

```sql
call proc_drop_index('myDatase2', 'student');
call proc_drop_index('myDatase2', 'class');
```

以下是否能用到索引，能否去掉`using filesort`

**过程一**

```sql
mysql> EXPLAIN SELECT * FROM student ORDER BY age,classid;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.01 sec)
```

```sql
mysql> EXPLAIN SELECT * FROM student ORDER BY age,classid LIMIT 10;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

**过程二：order by 时不 limit，索引失效**

```sql
#创建索引
CREATE INDEX idx_age_classid_name ON student(age, classid, name);

#不限制，索引失效
mysql> EXPLAIN SELECT * FROM student ORDER BY age, classid;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.01 sec)
```

因为这里`SELECT`的时`*`，索引如果使用索引，则每次都需要回表再查询全部数据（几万条），优化器发现还不如直接使用`filesort`。

```sql
#增加 limit 过滤条件，使用到了索引
mysql> EXPLAIN SELECT * FROM student ORDER BY age, classid LIMIT 10;
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key                  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | idx_age_classid_name | 73      | NULL |   10 |   100.00 | NULL  |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

**过程三：order by 时顺序不一致，索引失效**

```sql
#创建索引 age、classid、stuno
CREATE INDEX idx_age_classid_stuno ON student(age, classid, stuno);

#以下哪些索引失效
EXPLAIN SELECT * FROM student ORDER BY classid LIMIT 10; ×
EXPLAIN SELECT * FROM student ORDER BY classid,name LIMIT 10; ×
EXPLAIN SELECT * FROM student ORDER BY age,classid,stuno LIMIT 10; ○
EXPLAIN SELECT * FROM student ORDER BY age,classid LIMIT 10; ○
EXPLAIN SELECT * FROM student ORDER BY age LIMIT 10; ○
```

 **过程四：order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）**

```sql
EXPLAIN SELECT * FROM student ORDER BY age DESC, classid ASC LIMIT 10; ×
EXPLAIN SELECT * FROM student ORDER BY classid DESC, NAME DESC LIMIT 10; ×
EXPLAIN SELECT * FROM student ORDER BY age ASC, classid DESC LIMIT 10; ×
#方向都反时可以使用索引
mysql> EXPLAIN SELECT * FROM student ORDER BY age DESC, classid DESC LIMIT 10;
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+---------------------+
| id | select_type | table   | partitions | type  | possible_keys | key                  | key_len | ref  | rows | filtered | Extra               |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+---------------------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | idx_age_classid_name | 73      | NULL |   10 |   100.00 | Backward index scan |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+---------------------+
1 row in set, 1 warning (0.00 sec)
```

**过程五：无过滤，不索引**

```sql
# 仅使用了 age 上的索引：经过了 age = 45 的过滤后数据已经很小了，不会再使用 classid 上的索引
EXPLAIN SELECT * FROM student WHERE age = 45 ORDER BY classid; ○
EXPLAIN SELECT * FROM student WHERE age = 45 ORDER BY classid, name; ○

# 没有以 classid 开始的索引，age 上虽然有索引，但 order by 后没有 limit
EXPLAIN SELECT * FROM student WHERE classid = 45 ORDER BY age; ×
# 加上 limit 后可以使用到联合索引（ORDER BY 语句先于 WHERE 执行！）
mysql> EXPLAIN SELECT * FROM student WHERE classid = 45 ORDER BY age limit 10;
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key                  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | idx_age_classid_name | 73      | NULL |   10 |    10.00 | Using where |
+----+-------------+---------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

**小结：**

```sql
INDEX a_b_c(a,b,c)

order by #能使用索引最左前缀
- ORDER BY a
- ORDER BY a,b
- ORDER BY a,b,c
- ORDER BY a DESC,b DESC,c DESC

#如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引
- WHERE a = const ORDER BY b,c
- WHERE a = const AND b = const ORDER BY c
- WHERE a = const ORDER BY b,c
- WHERE a = const AND b > const ORDER BY b,c

#不能使用索引进行排序
- ORDER BY a ASC,b DESC,c DESC  /* 排序不一致 */
- WHERE g = const ORDER BY b,c  /*丢失a索引*/
- WHERE a = const ORDER BY c   /*丢失b索引*/
- WHERE a = const ORDER BY a,d  /*d不是索引的一部分*/
- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询，范围查询列右边的索引列失效*/
```

### 5.3 案例实战

ORDER BY 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序。
执行案例前先清除 student 上的索引，只留主键：

```sql
call proc_drop_index('atguigudb2','student');
```

**场景：查询年龄为 30岁 的，且学生编号小于 101000 的学生，按用户名称排序**

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY NAME;
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |     3.33 | Using where; Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+
1 row in set, 2 warnings (0.00 sec)
```

> 结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort，也是最坏的情况。优化是必须的。

优化思路：
**方案一：为了去掉filesort我们可以把建立索引**

```sql
#创建新索引
CREATE INDEX idx_age_name ON student(age,NAME);
```

```sql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY NAME;
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age_name  | idx_age_name | 5       | const | 18966 |    33.33 | Using where |
+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)
```

**方案二：尽量让 where 的过滤条件和排序使用上索引**

建一个三个字段的组合索引：

```sql
DROP INDEX idx_age_name ON student;
CREATE INDEX idx_age_stuno_name ON student (age,stuno,NAME);

# stuno 是一个范围查询，所以 name 上的索引失效了
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY NAME;
+----+-------------+---------+------------+-------+--------------------+--------------------+---------+------+------+----------+---------------------------------------+
| id | select_type | table   | partitions | type  | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+---------+------------+-------+--------------------+--------------------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | student | NULL       | range | idx_age_stuno_name | idx_age_stuno_name | 9       | NULL |   21 |   100.00 | Using index condition; Using filesort |
+----+-------------+---------+------------+-------+--------------------+--------------------+---------+------+------+----------+---------------------------------------+
1 row in set, 2 warnings (0.00 sec)
```

```sql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno < 101000 ORDER BY NAME;
+-----+--------+--------+------+---------+
| id | stuno | name  | age | classId |
+-----+--------+--------+------+---------+
| 167 | 100168 | AClxEF |  30 |   319 |
| 323 | 100324 | bwbTpQ |  30 |   654 |
| 651 | 100652 | DRwIac |  30 |   997 |
| 517 | 100518 | HNSYqJ |  30 |   256 |
| 344 | 100345 | JuepiX |  30 |   329 |
| 905 | 100906 | JuWALd |  30 |   892 |
| 574 | 100575 | kbyqjX |  30 |   260 |
| 703 | 100704 | KJbprS |  30 |   594 |
| 723 | 100724 | OTdJkY |  30 |   236 |
| 656 | 100657 | Pfgqmj |  30 |   600 |
| 982 | 100983 | qywLqw |  30 |   837 |
| 468 | 100469 | sLEKQW |  30 |   346 |
| 988 | 100989 | UBYqJl |  30 |   457 |
| 173 | 100174 | UltkTN |  30 |   830 |
| 332 | 100333 | YjWiZw |  30 |   824 |
+-----+--------+--------+------+---------+
15 rows in set, 1 warning (0.00 sec)
```

结果竟然有 filesort 的 sql 运行速度， 超过了已经优化掉 filesort 的 sql，而且快了很多，几乎一瞬间就出现了结果。

原因：

​    所有的排序都是在条件过滤之后才执行的。所以，如果条件滤掉大部分数据的话，剩下的数据进行排序其实不是很消耗性能，即使索引优化了排序，但提升性能很有限。相对的 stuno<101000 这个条件如果没有用到索引的话，要对几万条数据进行扫描非常消耗性能，所以索引放在这个字段上性价比最高。

> 结论：
>
> - 两个索引同时存在，mysql 自动选择最优的方案（对于这个例子，mysql选择 idx_age_stuno_name）。但是，`随着数据量的变化，选择的索引也会随之变化的`
> - **当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上，反之亦然**

思考：这里我们使用如下索引，是否可行？

可行！

```sql
DROP INDEX idx_age_stuno_name ON student;
CREATE INDEX idx_age_stuno ON student(age,stuno);
```

### 5.4 filesort算法：双路排序和单路排序

排序的字段如果不在索引列上，则 filesort 会有两种算法：`双路排序`和`单路排序`

**双路排序 （慢）**

​    `MySQL 4.1之前是使用双路排序`，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by 列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。即先从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段

​    取一批数据，要对磁盘进行两次扫描，众所周知，IO 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序。
**单路排序 （快）**
​    从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。
**结论及引申出的问题**

- 由于单路是后出的，总体而言好过双路
- 但是用单路有问题
  - 在 sort_buffer 中，单路比多路要`多占用很多空间`，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了`sort_buffer`的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多路合并），排完再取 sort_buffer 容量大小，再次排序......从而多次 I/O。
  - 结果单路本来想节省一次 I/O 操作，`反而导致了大量的 I/O 操作`

**优化策略**

1. 尝试提高 sort_buffer_size

   不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程的 1M-8M 之间调整。MySQL5.7 中 InnoDB 默认值是 1MB。

   ```sql
   mysql> SHOW VARIABLES LIKE '%sort_buffer_size%';
   +-------------------------+---------+
   | Variable_name           | Value   |
   +-------------------------+---------+
   | innodb_sort_buffer_size | 1048576 |
   | myisam_sort_buffer_size | 8388608 |
   | sort_buffer_size        | 262144  |
   +-------------------------+---------+
   3 rows in set (0.00 sec)
   ```

2. 尝试提高 max_length_for_sort_data==（8.0.20后不再推荐）==

   提高这个参数会增加用改进算法的概率：

   ```sql
   mysql> SHOW VARIABLES LIKE '%max_length_for_sort_data%';
   +--------------------------+-------+
   | Variable_name            | Value |
   +--------------------------+-------+
   | max_length_for_sort_data | 4096  |
   +--------------------------+-------+
   1 row in set (0.00 sec)
   ```

   ​    但是如果设置太高，一直使用单路排序，数据总容量超出 sort_buffer_size 的概率就增大了，明显症状是高的磁盘 I/O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。可以在 1024-8192 字节之间调整。

3. Order by 时select * 是一个大忌，最好只 Query 需要的字段

   - 如果需要返回的列的总大小小于`max_length_for_sort_data`，而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序，否则用多路排序
   - 两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险更大一些，所以要`提高sort_buffer_size`

## 6.GROUP BY优化

- group by 使用索引的原则几乎跟 order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引
- group by 先排序再分组，遵照索引建的最佳左前缀法则
- 当无法使用索引列，增大`max_length_for_sort_data`和`sort_buffer_size`参数的设置
- `where`效率高于`having`，能写在`where`限定的条件就不要写在`having`中了
- 减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、groupby、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的
- 包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢

## 7.优化分页查询

​    一般分页查询时，通过创建覆盖索引能够比较好的提高性能，一个常见的问题就是 limit 2000000,10，此时需要 MySQL 排序所有记录，读取所有字段，然后找到第 2000000 条记录，再返回 10 条记录，丢弃其他记录，查询排序的代价非常大。

```sql
mysql> EXPLAIN SELECT * FROM student ORDER BY id LIMIT 2000000, 10;
+----+-------------+---------+------------+-------+---------------+---------+---------+------+--------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+--------+----------+-------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | PRIMARY | 4       | NULL | 499086 |   100.00 | NULL  |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+--------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> SELECT * FROM student ORDER BY id LIMIT 2000000, 10;
Empty set (0.17 sec)
```

**优化思路一**

在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。`此时 MySQL 做 limit 前只需读取 id 即可`。

```sql
mysql> EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 499086 |   100.00 | NULL        |
|  1 | PRIMARY     | t          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | a.id |      1 |   100.00 | NULL        |
|  2 | DERIVED     | student    | NULL       | index  | NULL          | PRIMARY | 4       | NULL | 499086 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)

mysql> SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;
Empty set (0.09 sec)
```

**优化思路二**
该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询。

```sql
mysql> EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |   100.00 | Using where |
+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> SELECT * FROM student WHERE id > 2000000 LIMIT 10;
Empty set (0.00 sec)
```

## 8.优先考虑覆盖索引

### 8.1 什么是覆盖索引？

**理解方式一：**索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。`一个索引包含了满足查询结果的数据就叫做覆盖索引`。
**理解方式二：**非聚簇复合索引的一种形式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。简单说就是，`索引列+主键`包含`SELECT到FROM之间查询的列`。

**举例一：**

```sql
# 删除之前的索引
call proc_drop_index('atguigudb2','student');
CREATE INDEX idx_age_name ON student(age, name);

# 等值索引时有效
mysql> EXPLAIN SELECT * FROM student WHERE age = 20;
+----+-------------+---------+------------+------+---------------------------------+--------------+---------+-------+-------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys                   | key          | key_len | ref   | rows  | filtered | Extra |
+----+-------------+---------+------------+------+---------------------------------+--------------+---------+-------+-------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | idx_age_stuno_name,idx_age_name | idx_age_name | 5       | const | 18236 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------------------------+--------------+---------+-------+-------+----------+-------+
1 row in set, 1 warning (0.02 sec)

# 使用 <> 时索引失效，因为此时要回表，优化器觉得成本比不使用索引时还要高
mysql> EXPLAIN SELECT * FROM student WHERE age <> 20;
+----+-------------+---------+------------+------+---------------------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys                   | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | idx_age_stuno_name,idx_age_name | NULL | NULL    | NULL | 499086 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------------------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.05 sec)
```

```sql
# 有索引覆盖时，<>依然会使用到索引，因为可以省去回表的成本
mysql> EXPLAIN SELECT id,age,name FROM student WHERE age <> 20;
+----+-------------+---------+------------+-------+---------------------------------+--------------+---------+------+--------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys                   | key          | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------------------------+--------------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | student | NULL       | index | idx_age_stuno_name,idx_age_name | idx_age_name | 68      | NULL | 499086 |   100.00 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------------------------+--------------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

**举例二：**

```sql
CREATE INDEX idx_age_name ON student(age,name);

mysql> EXPLAIN SELECT * FROM student WHERE name LIKE '%abc';
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

```sql
mysql> EXPLAIN SELECT id,age,name FROM student WHERE name LIKE '%abc';
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | student | NULL       | index | NULL          | idx_age_name | 68      | NULL | 499086 |    11.11 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

### 8.2 覆盖索引的利弊

**好处：**

1. 避免Innodb表进行索引的二次查询（回表）

   ​    Innodb 是以聚簇索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果使用二级索引查询数据，在查到相应的键值后，还需通过主键进行二次查询才能获取到我们所需要的数据。

   ​    在索引覆盖中，二级索引的键值中可以获取所需要的数据，`避免了对主键的二次查询，减少了 IO 操作`，提升了查询效率。

2. 可以把随机IO变成顺序IO加快查询效率

  ​    由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，比`随机IO`（回表后数据页可能不在同一个区，变成随机IO）消耗更多资源，因此利用覆盖索引在访问时也可以把磁盘的`随机读取的IO`转变成索引查找的`顺序IO`。

> 由于索引覆盖可以减少树的搜索次数，限制提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

**弊端：**
`索引字段的维护`总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。

## 9.如何给字符串添加索引

有一张教师表，表定义如下：

```sql
create table teacher(
ID bigint unsigned primary key,
email varchar(64),
...
)engine=innodb;
```

讲师要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：

```sql
mysql> select col1, col2 from teacher where email='xxx';
```

如果 email 这个字段上没有索引，那么这个语句就只能做`全表扫描`。

### 9.1 前缀索引

MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

```sql
mysql> alter table teacher add index index1(email);
#或
mysql> alter table teacher add index index2(email(6));
```

这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图：

<img src="img\image-20220216214659346.png" alt="image-20220216214659346" style="zoom:67%;" />

以及：

<img src="img\image-20220216214715800.png" alt="image-20220216214715800" style="zoom: 50%;" />

如果使用的是 index1（即 email 整个字符串的索引结构），执行顺序是这样的：

- 从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值
- 到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集

- 取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email='zhangssxyz@xxx.com’ 的条件了，循环结束。这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行

如果使用的是 index2（即 email(6) 索引结构），执行顺序是这样的：

- 从 index2 索引树找到满足索引值是 ’zhangs’ 的记录，找到的第一个是ID1
- 到主键上查到主键值是 ID1 的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃
- 取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集
- 重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束

​    在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。但是，对于这个查询语句来说，如果你定义的 index2 不是 email(6) 而是 email(7），也就是说取 email 字段的前 7 个字节来构建索引的话，即满足前缀 ’zhangss’ 的记录只有一个，也能够直接查到 ID2，只扫描一行就结束了。也就是说使用前缀索引，定义好长度，就可以做到`既节省空间，又不用额外增加太多的查询成本`。

**如何确定字符串创建前缀索引的长度？**
    实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：

```sql
mysql> select count(distinct email) as L from SUser;
```

然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：

```sql
mysql> select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

​    当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。

### 9.2 前缀索引对覆盖索引的影响

使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。
你先来看看这个SQL语句：

```sql
select id,email from SUser where email='zhangssxyz@xxx.com';
```

与前面例子中的SQL语句

```sql
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

​    相比，这个语句只要求返回id和email字段。

​    所以，如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用`覆盖索引`，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为`系统并不确定前缀索引的定义是否截断了完整信息`。也就是说，`使用前缀索引就用不上覆盖索引对查询性能的优化`了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。

### 9.3 其他方式

如果我们能够确定业务需求里面只有按照`身份证`进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。
第一种方式是使用`倒序存储`。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：

```sql
mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然了，实践中不要忘记使用 count(distinct) 方法去做个验证。

第二种方式是使用`hash字段`。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。

```sql
mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);
```

​    然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。

```sql
mysql> select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_card=‘input_id_card_string’
```

这样，索引的长度变成了4个字节，比原来小了很多。

**使用倒序存储和使用hash字段这两种方法的异同点**

- 相同点：

  都`不支持范围查询`。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在 [ID_X, ID_Y] 的所有市民了。同样地，hash 字段的方式也只能支持等值查询。

- 不同点：
  - 从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而`hash`字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了
  - 在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些
  - 从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数

> **扩展**——`CRC32的基本特征`：
>
> - CRC32 函数返回值的范围是 0-4294967296(2的32次方减1)
> - 相比 MD5，CRC32 函数很容易碰撞
>
> 由上述两个基本特性可知，MySQL CRC32 生成整型结果使用用 bigint 存储，而 MD5 需要 varchar 来存储。但是 CRC32 很容易碰撞，可以`配合前缀搜索使用`

## 10.索引下推

### 10.1 使用前后对比

​    Index Condition Pushdown(ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式，可以减少存储引擎访问基表的次数以及 MySQL 服务器访问存储引擎的次数。

- 如果没有 ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL 服务器。由 MySQL 服务器评估`WHERE`后面的条件是否保留
- 启动 ICP 后，如果部分`WHERE`条件可以仅使用索引中的列进行筛选，则 MySQL 服务器会把这部分`WHERE`条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行
  - 好处：ICP 可以减少存储引擎必须访问基表的次数和 MySQL 服务器必须访问存储引擎的次数
  - 但是，ICP的`加速效果`取决于在存储引擎内通过`ICP筛选`掉的数据的比例

**在不使用 ICP 索引扫描的过程：**

storage 层：只将满足 index key 条件的索引记录对应的整行记录取出，返回给 server 层。

server 层：对返回的数据，使用后面的 where 条件过滤，直至返回最后一行。

**使用 ICP 扫描的过程：**

storage 层：

​    首先将 index key 条件满足的索引记录区间确定，然后在索引上使用 index filter 进行过滤。将满足的 index filter 条件的索引记录才去回表取出整行记录返回 server 层。不满足 index filter 条件的索引记录丢弃，不回表、也不会返回 server 层。

server 层：

​    对返回的数据，使用 table filter 条件做最后的过滤。

**使用前后的成本差别**

​    使用前，存储层多返回了需要被 index filter 过滤掉的整行记录，使用ICP后，直接就去掉了不满足 index filter 条件的记录，省去了他们回表和传递到 server 层的成本。ICP的`加速效果`取决于在存储引擎内通过`ICP筛选`掉的数据的比例。

### 10.2 ICP的开启/关闭

- 默认情况下启用索引条件下推。可以通过设置系统变量`optimizer_switch`控制：

  ```sql
  SET optimizer_switch = 'index_condition_pushdown=off';
  SET optimizer_switch = 'index_condition_pushdown=on';
  ```

- 当使用条件下推时，`EXPLAIN`语句输出结果中`Extra`列内容显示为`Using index conditon`

### 10.3 ICP 使用案例

建表

```sql
CREATE TABLE `people` (
	`id` INT NOT NULL AUTO_INCREMENT,
    `zipcode` varchar(20) COLLATE utf8_bin DEFAULT NULL,
    `firstname` varchar(20) DEFAULT NULL,
    `lastname` varchar(20) DEFAULT NULL,
    `address` varchar(50) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `zip_last_first` (`zipcode`,`lastname`,`firstname`)
);
```

> zipcode 为 utf8mb3, 其余为 utf8mb4

插入数据

```sql
INSERT INTO `people` VALUES
('1', '000001', '三', '张', '北京市'),
('2', '000002', '四', '赵', '洛阳市'),
('3', '000003', '五', '李', '南京市'),
('4', '000004', '六', '王', '长安市');
```

为该表定义联合索引`zip_last_first (zipcode,lastname,firstname)`，如果知道了一个人的邮编，查询该姓氏：

```sql
mysql> EXPLAIN SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '%张%' AND address LIKE '%北京市%';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra                              |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
|  1 | SIMPLE      | people | NULL       | ref  | zip_last_first | zip_last_first | 63      | const |    1 |    25.00 | Using index condition; Using where |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+
1 row in set, 1 warning (0.00 sec)

# 即使where中联合索引的列不相邻也可以
mysql> EXPLAIN SELECT * FROM people WHERE zipcode = '000001' AND firstname LIKE '三%';
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+
| id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | people | NULL       | ref  | zip_last_first | zip_last_first | 63      | const |    1 |    25.00 | Using index condition |
+----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

​    执行查看 SQL 执行计划，`Extra`中显示了`Using index condition`，表示使用了索引下推。另外，Using where 表示条件中包含需要过滤的非索引列的数据，即`address LIKE \'%北京市%\'`这个条件并不是索引列，需要用 WHERE 过滤。

​    并且此时`key_len`仅为`63`，说明`仅使用了 zipcode 的索引`，因为 lastname 使用了全模糊查询，所以不会使用该列的索引，但是会利用索引条件下推，`在联合索引中直接判断 lastname 的条件`，减少了回表操作和随机 IO。

​    当 lastname 和 firstname 使用的前缀匹配时会使用到索引，此时`key_len`为`229`，说明联合索引的三个列上的索引都使用到了，此时虽然显示使用了联合索引，但是因为`默认都会去查询联合字段上的索引索引的值`，体现不出索引下推的思想：

```sql
mysql> EXPLAIN SELECT * FROM people WHERE zipcode = '000001' AND lastname LIKE '张%' AND firstname LIKE '三%';
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
| id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | people | NULL       | range | zip_last_first | zip_last_first | 229     | NULL |    1 |    25.00 | Using index condition |
+----+-------------+--------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
```

> 索引下推主要应用在`使用了联合索引，但索引并没有全部生效时`

### 10.4 开启和关闭 ICP 的性能对比

创建存储过程，主要目的就是插入很多 000001 的数据，这样查询的时候为了在存储引擎层做过滤，减少 IO，也为了减少缓冲池（缓存数据页，没有 IO）的作用。

```sql
DELIMITER //
CREATE PROCEDURE insert_people(max_num INT)
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
		SET i = i + 1;
		INSERT INTO people(zipcode,firstname,lastname,address)
		VALUES ('0000001', '六', '赵', '洛阳市');
		UNTIL i = max_num
    END REPEAT;
END //
DELIMITER ;
```

调用存储过程

```sql
call insert_people(1000000);
```

首先打开[profiling](./第09章_性能分析工具的使用.md)

```sql
set profiling=1;
```

执行 SQL 语句，此时默认打开索引下推

```sql
SELECT * FROM people WHERE zipcode = '0000001' AND lastname LIKE '%王%';
```

再次执行 SQL 语句，不使用索引下推

```sql
SELECT /*+ no_icp (people) */ * FROM people WHERE zipcode = '0000001' AND lastname LIKE '%王%';
```

查看当前会话所产生的所有 profile

```sql
mysql> show profiles\g;
+----------+-------------+-------------------------------------------------------------------------------------------------+
| Query_ID | Duration    | Query                                                                                           |
|        1 |  0.74251350 | SELECT * FROM people WHERE zipcode = '0000001' AND lastname LIKE '%王%'                         |
|        2 | 24.38177100 | SELECT /*+ no_icp (people) */ * FROM people WHERE zipcode = '0000001' AND lastname LIKE '%王%'  |
+----------+-------------+-------------------------------------------------------------------------------------------------+
```

### 10.5 ICP的使用条件

- 对于`InnoDB`表，`ICP`只能用于`二级索引`，ICP 的目标是减少回表操作，从而减少 I/O
- explain 显示的执行计划中 type 值为 range 、ref、eq_ref 或者 ref_or_null
- 并非全部 where 条件都可以用 ICP 筛选，如果 where 条件的字段不在索引列中，还是要读取整表的记录到 server 端做 where 过滤
- `相关子查询`不能使用 ICP
- ICP 可以用于`MyISAM`和`InnnoDB`存储引擎
  ⑤ MySQL 5.6 版本的不支持分区表的 ICP 功能，5.7 版本的开始支持
  ⑥ 当 SQL 使用`覆盖索引`时，不支持 ICP 优化方法，因为这种情况下使用 ICP 不会减少 I/O

## 11.普通索引 vs 唯一索引

从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。
这个表的建表语句是：

```sql
mysql> create table test(
id int primary key,
k int not null,
name varchar(16),
index (k)
)engine=InnoDB;
```

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)。

### 11.1 查询过程

​    假设，执行查询的语句是`select id from test where k=5`。对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
​    那么，这个不同带来的性能差距会有多少呢？答案是，`微乎其微`。

​    你知道的，`InnoDB 的数据是按数据页为单位来读写的`。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。

​    因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。但是，我们之前计算过，`对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低`。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。

### 11.2 更新过程

​    为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下`change buffer`。当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，`InnoDB 会将这些更新操作缓存在 change buffer 中`，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

​    需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

​    显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。

**那么，什么条件下可以使用 change buffer 呢？**

​    `对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束`。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。此时就直接更新内存会更快，就没必要使用 change buffer 了。因此，`唯一索引的更新就不能使用 change buffer`，实际上也只有普通索引可以使用。

​    change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数`innodb_change_buffer_max_size`来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。现在，你已经理解了 change buffer 的机制，那么我们再一起来看看如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。

​    **第一种情况**是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束
- 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束

​    这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。但，这不是我们关注的重点。

​    **第二种情况**是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了

​    将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。`change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的`。

> 之前我就碰到过一件事儿，有个 DBA 的同学跟我反馈说，他负责的某个业务的库内存命中率突然从 99% 降低到了 75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。

### 11.3 change buffer的使用场景

​    通过上面的分析，你已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：`普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？`

​    因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

​    因此，对于==写多读少==的业务来说，`页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好`。这种业务模型常见的就是`账单类`、`日志类`的系统。

​    反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

**索引选择和实践**

​    普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你`尽量选择普通索引`。如果所有的`更新后面，都马上伴随着对这个记录的查询`，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。

​    在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量`使用普通索引，然后把 change buffer 尽量开大`，以确保这个“历史数据”表的数据写入速度。

**change buffer 和 redo log**
    理解了 change buffer 的原理，你可能会联想到我在前面文章中和你介绍过的 redo log 和 WAL。在前面文章的评论中，我发现有同学混淆了 redo log 和 change buffer。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。

​    现在，我们要在表上执行这个插入语句：

```sql
mysql> insert into t(id,k) values(id1,k1),(id2,k2);
```

​    这里，我们假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。如下图所示是带 change buffer 的更新状态图：

<img src="img\image-20220219191542869.png" alt="image-20220219191542869" style="zoom:67%;" />

​    分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。

​    这条更新语句做了如下的操作（按照图中的数字顺序）：

- Page 1 在内存中，直接更新内存
- Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息

- 将上述两个动作记入 redo log 中（图中 3 和 4）

​    做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。那在这之后的读请求，要怎么处理呢？比如，我们现在要执行`select * from t where k in (k1, k2)`。这里，我画了这两个读请求的流程图。如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。

<img src="img\image-20220219191703483.png" alt="image-20220219191703483" style="zoom:67%;" />

​    从图中可以看到：

- 读 Page 1 的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。
- 要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存

​    所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。

**总结**
用普通索引就行

##  12.其它查询优化策略

### 12.1 EXISTS 和 IN 的区分

**问题：**
不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？

**答案：**

索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为`小表驱动大表`。在这种方式下效率是最高的。

比如下面这样：

```sql
 SELECT * FROM A WHERE cc IN (SELECT cc FROM B);
 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc);
```

当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：

```text
 for i in A
     for j in B
         if j.cc == i.cc then ...
```

当 B 小于 A 时用 IN，因为实现的逻辑类似于：

```text
 for i in B
     for j in A
         if j.cc == i.cc then ...
```

哪个表小就用哪个表来驱动，`A 表小就用 EXISTS，B 表小就用 IN`。

### 12.2 COUNT(*)与COUNT(具体字段)效率

问：在 MySQL 中统计数据表的行数，可以使用三种方式：`SELECT COUNT()` 、`SELECT COUNT(1)` 和`SELECT COUNT(具体字段)`，使用这三者之间的查询效率是怎样的？

答：

前提：如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。

**环节1：**`COUNT(*)`和`COUNT(1)`都是对所有结果进行`COUNT`，`COUNT(*)`和`COUNT(1)`本质上并没有区别（二者执行时间可能略有差别，不过可以把它俩的执行效率堪称是相等的）。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计，如果没有 WHERE 子句，则是对数据表的数据行数进行统计。

**环节2：**如果时 MyISAM 存储引擎，统计数据表的行数只需要`O(1)`的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了`row_count`值，而一致性则由`表级锁`来保证。

​    如果是 InnoDB 存储引擎，因为 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用`全表扫描`，复杂度为`O(n)`，进行循环 + 计数的方式来完成统计。

**环节3：**在 InnoDB 引擎中，如果采用`COUNT(具体字段)`来统计数据行数，要尽量采用二级索引，因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引，对于`COUNT(*)`和`COUNT(1)`来说，他们不需要查找具体的行，只是统计行数，系统会`自动采用占用空间最小的二级索引`来进行统计。

​    如果有多个二级索引，会使用`key_len`小的二级索引进行扫描，当没有二级索引的时候，才会采用主键索引进行统计。

### 12.3 关于SELECT *

在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因：

- MySQL 在解析的过程中，会通过`查询数据字典`将"*"按序转换成所有列名，这会大大的耗费资源和时间
- 无法使用`覆盖索引`

### 12.4 LIMIT 1 对优化的影响

​    针对的是会扫描全表的 SQL 语句，如果你可以`确定结果集只有一条`，那么加上`LIMIT 1`的时候，当找到一条结果的时候就`不会继续扫描`了，这样会加快查询速度。如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上`LIMIT 1`了。

### 12.5 多使用COMMIT

只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。
COMMIT 所释放的资源：

- 回滚段上用于恢复数据的信息
- 被程序语句获得的锁
- redo / undo log buffer 中的空间
- 管理上述 3 种资源中的内部花费

## 13.淘宝数据库，主键如何设计的？

**聊一个实际问题：淘宝的数据库，主键是如何设计的？**
    某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的 MySQL 军规。其中，一个最明显的错误就是关于 MySQL 的主键设计。大部分人的回答如此自信：用 8 字节的 BIGINT 做主键，而不要用 INT。`错！`这样的回答，只站在了数据库这一层，而没有`从业务的角度`思考主键。主键就是一个自增 ID 吗？站在 2022 年的新年档口，用自增做主键，架构设计上可能`连及格都拿不到`。

### 13.1 自增ID的问题

自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：

1. 可靠性不高

  存在自增 ID 回溯的问题，这个问题直到最新版本的 MySQL 8.0 才修复。

2. 安全性不高

  对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/ 这样的接口，可以非常容易猜测用户 ID 的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。

3. 性能差

  自增 ID 的性能较差，需要在数据库服务器端生成。

4. 交互多

  业务还需要额外执行一次类似`last_insert_id()`的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多 1 条 SQL，就多一次性能上的开销。

5. 局部唯一性

  最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。

### 13.2 业务字段做主键

为了能够唯一地标识一个会员的信息，需要为`会员信息表`设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。
表数据如下：

<img src="img\image-20220216215042961.png" alt="image-20220216215042961" style="zoom: 50%;" />

在这个表里，哪个字段比较合适呢？

- 选择卡号（cardno）

  会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。

  ```sql
  mysql> CREATE TABLE demo.membermaster
  -> (
  -> cardno CHAR(8) PRIMARY KEY, -- 会员卡号为主键
  -> membername TEXT,
  -> memberphone TEXT,
  -> memberpid TEXT,
  -> memberaddress TEXT,
  -> sex TEXT,
  -> birthday DATETIME
  -> );
  Query OK, 0 rows affected (0.06 sec)
  ```

  ​    不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。
  ​    但实际情况是，`会员卡号可能存在重复使用`的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号是“10000001”的会员卡发给了王五。
  ​    从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息，而导致系统内部数据不一致”的情况。因此，从信息系统层面上看是没问题的。
  ​    但是从使用`系统的业务层面`来看，就有很大的问题了，会对商家造成影响。
  ​    比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：

  <img src="img\image-20220216215114801.png" alt="image-20220216215114801" style="zoom:50%;" />

  接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：

  ```sql
  mysql> SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate
  -> FROM demo.trans AS a
  -> JOIN demo.membermaster AS b
  -> JOIN demo.goodsmaster AS c
  -> ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);
  +------------+-----------+----------+------------+---------------------+
  | membername | goodsname | quantity | salesvalue | transdate      |
  +------------+-----------+----------+------------+---------------------+
  | 张三    | 书    | 1.000  | 89.00   | 2020-12-01 00:00:00 |
  +------------+-----------+----------+------------+---------------------+
  1 row in set (0.00 sec)
  ```

  如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：

  ```sql
  mysql> SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate
  -> FROM demo.trans AS a
  -> JOIN demo.membermaster AS b
  -> JOIN demo.goodsmaster AS c
  -> ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);
  +------------+-----------+----------+------------+---------------------+
  | membername | goodsname | quantity | salesvalue | transdate      |
  +------------+-----------+----------+------------+---------------------+
  | 王五    | 书    | 1.000  | 89.00   | 2020-12-01 00:00:00 |
  +------------+-----------+----------+------------+---------------------+
  1 row in set (0.01 sec)
  ```

  这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万不能把会员卡号当做主键。

- 选择会员电话或身份证号
      会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情况。
      那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于`个人隐私`，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。
      所以，`建议尽量不要用跟业务有关的字段做主键`。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。

  > 经验：
  >     刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。

### 13.3 淘宝的主键设计

在淘宝的电商业务中，订单服务是一个核心业务。请问，`订单表的主键`淘宝是如何设计的呢？是自增ID吗？
打开淘宝，看一下订单信息：

<img src="img\image-20220216215210098.png" alt="image-20220216215210098" style="zoom:67%;" />

从上图可以发现，订单号不是自增 ID！我们详细看下上述 4 个订单号：

```text
1550672064762308113
1481195847180308113
1431156171142308113
1431146631521308113
```

订单号是 19 位的长度，且订单的最后 5 位都是一样的，都是 08113。且订单号的前面 14 位部分是单调递增的。
大胆猜测，淘宝的订单 ID 设计应该是：

```text
订单ID = 时间 + 去重字段 + 用户ID后6位尾号
```

这样的设计能做到全局唯一，且对分布式系统查询及其友好。

### 13.4 推荐的主键设计

`非核心业务`：对应表的主键自增 ID，如告警、日志、监控等信息。
`核心业务`：主键设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。
这里推荐最简单的一种主键设计：`UUID`。
**UUID的特点：**
全局唯一，占用 36 字节，数据无序，插入性能差。

**认识UUID：**

- 为什么UUID是全局唯一的？
- 为什么UUID占用 36 个字节？
- 为什么UUID是无序的？

MySQL 数据库的 UUID 组成如下所示：

```text
UUID = 时间 + UUID版本（16字节）- 时钟序列（4字节）- MAC地址（12字节）
```

我们以 UUID 值 e0ea12d4-6473-11eb-943c-00155dbaa39d 举例：

<img src="img\image-20220216215944439.png" alt="image-20220216215944439" style="zoom:50%;" />

**为什么UUID是全局唯一的？**
    在 UUID 中时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从 1582-10-15 00：00：00.00 到现在的 100ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMPE 更高，时间维度发生重复的概率降低到 1/100ns。
    时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。
**为什么UUID占用 36 个字节？**
UUID 根据`字符串`进行存储，设计时还带有无用"-"字符串，因此总共需要 36 个字节。
**为什么UUID是随机无序的呢？**
因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。
**改造UUID**
    若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的 UUID 了。MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的"-"字符串，并且将字符串`用二进制类型保存`，这样存储空间降低为了`16`字节。

> 一个字节由 8 位组成，转为 2 进制后可以由 4 位来表示一个字符

​    可以通过 MySQL8.0 提供的`uuid_to_bin`函数实现上述功能，同样的，MySQL 也提供了`bin_to_uuid`函数进行转化：

```sql
SET @uuid = UUID();

mysql> SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);
+--------------------------------------+----------------------------------------+--------------------------------------------------+
| @uuid                                | uuid_to_bin(@uuid)                     | uuid_to_bin(@uuid,TRUE)                          |
+--------------------------------------+----------------------------------------+--------------------------------------------------+
| a09a07eb-9174-11ec-92f8-000c29070cde | 0xA09A07EB917411EC92F8000C29070CDE     | 0x11EC9174A09A07EB92F8000C29070CDE               |
+--------------------------------------+----------------------------------------+--------------------------------------------------+
1 row in set (0.00 sec)
```

通过函数`uuid_to_bin(@uuid,true)`将 UUID 转化为有序 UUID 了。全局唯一 + 单调递增，这不就是我们想要的主键！

**有序 UUID 性能测试**

16 字节的有序 UUID，相比之前 8 字节的自增 ID，性能和存储空间对比究竟如何呢？
我们来做一个测试，插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：

<img src="img\image-20220216220014260.png" alt="image-20220216220014260" style="zoom:50%;" />

从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在`业务端就可以生成`。还可以进一步减少 SQL 的交互次数。
另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但实际只增大了 3G 的存储空间，还可以接受。

> 在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。
> 另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。

**如果不是MySQL8.0肿么办？**
`手动赋值字段做主键！`
    比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。
    门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进 行操作，就解决了各门店添加会员时会员编号冲突的问题。

## 扩展：雪花算法

​    SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的，后面的代码中有详细的注解。

​     这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

 ```text
 0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000
 ```

​    给大家举个例子吧，比如下面那个 64 bit 的 long 型数字：

- 第一个部分，是 1 个 bit：0，这个是无意义的
- 第二个部分是 41 个 bit：表示的是时间戳
- 第三个部分是 5 个 bit：表示的是机房 id，10001
- 第四个部分是 5 个 bit：表示的是机器 id，1 1001
- 第五个部分是 12 个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000

 **1 bit：是不用的，为啥呢？**

 因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。

 **41 bit：表示的是时间戳，单位是毫秒**

 41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值，换算成年就是表示 69 年的时间。

 **10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器**

​     但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2 ^ 5 个机房（32 个机房），每个机房里可以代表 2 ^ 5 个机器（32 台机器），也可以根据自己公司的实际情况确定。

 **12 bit：这个是用来记录同一个毫秒内产生的不同 id**

​     12 bit 可以代表的最大正整数是 2 ^ 12 - 1 = 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。

​     简单来说，你的某个服务假设要生成一个全局唯一 id，那么就可以发送一个请求给部署了 SnowFlake 算法的系统，由这个 SnowFlake 算法系统来生成唯一 id。这个 SnowFlake 算法系统首先肯定是知道自己所在的机房和机器的，比如机房 id = 17，机器 id = 12。

​    接着 SnowFlake 算法系统接收到这个请求之后，首先就会用二进制位运算的方式生成一个 64 bit 的 long 型 id，64 个 bit 中的第一个 bit 是无意义的。接着 41 个 bit，就可以用当前时间戳（单位到毫秒），然后接着 5 个 bit 设置上这个机房 id，还有 5 个 bit 设置上机器 id。

​    最后再判断一下，当前这台机房的这台机器上这一毫秒内，这是第几个请求，给这次生成 id 的请求累加一个序号，作为最后的 12 个 bit。

​     最终一个 64 个 bit 的 id 就出来了，类似于：

 ```text
 0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000
 ```

​    这个算法可以保证说，一个机房的一台机器上，在同一毫秒内，生成了一个唯一的 id。可能一个毫秒内会生成多个 id，但是有最后 12 个 bit 的序号来区分开来。下面我们简单看看这个 SnowFlake 算法的一个代码实现，这就是个示例，大家如果理解了这个意思之后，以后可以自己尝试改造这个算法。总之就是用一个 64 bit 的数字中各个 bit 位来设置不同的标志位，区分每一个 id。

**SnowFlake算法的优点：**

- 高性能高可用：生成时不依赖于数据库，完全在内存中生成
- 容量大：每秒中能生成数百万的自增ID
- ID自增：存入数据库中，索引效率高

**SnowFlake算法的缺点：**

- 依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成id冲突或者重复
- 实际中我们的机房并没有那么多，我们可以改进改算法，将10bit的机器id优化，成业务表或者和我们系统相关的业务

**SnowFlake 算法的实现代码如下：**

```java
public class IdWorker {
 
	//因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
 
	//机器ID 2进制5位 32位减掉1位 31个
	private long workerId;
	//机房ID 2进制5位 32位减掉1位 31个
	private long datacenterId;
	//代表一毫秒内生成的多个id的最新序号 12位 4096 -1 = 4095 个
	private long sequence;
	//设置一个时间初始值 2^41 - 1 差不多可以用69年
	private long twepoch = 1585644268888L;
	//5位的机器id
	private long workerIdBits = 5L;
	//5位的机房id
	private long datacenterIdBits = 5L;
	//每毫秒内产生的id数 2 的 12次方
	private long sequenceBits = 12L;
	// 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内
	private long maxWorkerId = -1L ^ (-1L << workerIdBits);
	// 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内
	private long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);
 
	private long workerIdShift = sequenceBits;
	private long datacenterIdShift = sequenceBits + workerIdBits;
	private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
	private long sequenceMask = -1L ^ (-1L << sequenceBits);
	//记录产生时间毫秒数，判断是否是同1毫秒
	private long lastTimestamp = -1L;
	public long getWorkerId(){
		return workerId;
	}
	public long getDatacenterId() {
		return datacenterId;
	}
	public long getTimestamp() {
		return System.currentTimeMillis();
	}
 
	public IdWorker(long workerId, long datacenterId, long sequence) {
 
		// 检查机房id和机器id是否超过31 不能小于0
		if (workerId > maxWorkerId || workerId < 0) {
			throw new IllegalArgumentException(
					String.format("worker Id can't be greater than %d or less than 0",maxWorkerId));
		}
 
		if (datacenterId > maxDatacenterId || datacenterId < 0) {
			throw new IllegalArgumentException(
					String.format("datacenter Id can't be greater than %d or less than 0",maxDatacenterId));
		}
		this.workerId = workerId;
		this.datacenterId = datacenterId;
		this.sequence = sequence;
	}
 
	// 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id
	public synchronized long nextId() {
		// 这儿就是获取当前时间戳，单位是毫秒
		long timestamp = timeGen();
		if (timestamp < lastTimestamp) {
			System.err.printf(
					"clock is moving backwards. Rejecting requests until %d.", lastTimestamp);
			throw new RuntimeException(
					String.format("Clock moved backwards. Refusing to generate id for %d milliseconds",
							lastTimestamp - timestamp));
		}
 
		// 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id
		// 这个时候就得把seqence序号给递增1，最多就是4096
		if (lastTimestamp == timestamp) {
			// 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，
			//这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围
			sequence = (sequence + 1) & sequenceMask;
			//当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
			if (sequence == 0) {
				timestamp = tilNextMillis(lastTimestamp);
			}
 
		} else {
			sequence = 0;
		}
		// 这儿记录一下最近一次生成id的时间戳，单位是毫秒
		lastTimestamp = timestamp;
		// 这儿就是最核心的二进制位运算操作，生成一个64bit的id
		// 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit
		// 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型
		return ((timestamp - twepoch) << timestampLeftShift) |
				(datacenterId << datacenterIdShift) |
				(workerId << workerIdShift) | sequence;
	}
 
	/**
	 * 当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
	 * @param lastTimestamp
	 * @return
	 */
	private long tilNextMillis(long lastTimestamp) {
 
		long timestamp = timeGen();
 
		while (timestamp <= lastTimestamp) {
			timestamp = timeGen();
		}
		return timestamp;
	}
	//获取当前时间戳
	private long timeGen(){
		return System.currentTimeMillis();
	}
 
	/**
	 *  main 测试类
	 * @param args
	 */
	public static void main(String[] args) {
		System.out.println(1&4596);
		System.out.println(2&4596);
		System.out.println(6&4596);
		System.out.println(6&4596);
		System.out.println(6&4596);
		System.out.println(6&4596);
//		IdWorker worker = new IdWorker(1,1,1);
//		for (int i = 0; i < 22; i++) {
//			System.out.println(worker.nextId());
//		}
	}
}
```
