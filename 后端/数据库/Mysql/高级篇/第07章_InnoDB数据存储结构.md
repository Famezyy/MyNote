# 第07章_InnoDB数据存储结构

## 1.数据库的存储结构：页

​    索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，`MySQL`服务器上的**存储引擎**负责对表中数据的读取和写入工作。不同存储引擎中**存放的格式**一般不同，甚至有的存储引擎比如`Memory`都不用磁盘来存储数据。

​    由于`InnoDB`是`MySQL`的默认存储引擎，所以本章剖析`InnoDB`存储引擎的数据存储结构。

### 1.1 磁盘与内存交互基本单位：页

​    `InnoDB`将数据划分为若干个页，`InnoDB`中页的大小默认为`16KB`。

​    以**页**作为磁盘和内存之间交互的**基本单位**，也就是一次最少从磁盘中读取`16kb`的内容到内存中，一次最少把内存中的`16kb`内容刷新到磁盘中。也就是说，**在数据库中，不会读多少行，都是将这些行所在的页进行加载，数据库管理存储空间的基本单位是页，数据库`IO`操作的最小单位是页**。一个页中可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（IO操作）只能处理一行数据，效率会非常低

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213012558504-83f1c66c9120851d4d13ebbe67bee578-fd1bd3.png" alt="image-20220213012558504" style="zoom:67%;" />

### 1.2 页结构概述

​    页a、页b、页c... 页n 这些页可以不在物理结构上连续，只要通过**双向链表**相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个**单向链表**，每个数据也都会为存储在它里面的记录生成一个**页目录**，在通过主键查找某条记录可以在页目录中**使用二分法**快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

### 1.3 页的大小

​    不同的数据库管理系统（DBMS）的页大小不同。比如在`MySQL`的`InnoDB`存储引擎中，默认页的大小是`16kb`，我们可以通过下面的命令查看：

```sql
SHOW VARIABLES LIKE '%innodb_page_size%';
```

​    `SQL Server`中页的大小为`8kb`，而在`Oracle`中我们用术语"块"（block）来代表页，`Oracle`支持的块大小为2kb，4kb，8kb，32kb，64kb。

### 1.4 页的上层结构

​    另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213013124200-61f0cb6737e548093de4c4655dd28aae-a94440.png" alt="image-20220213013124200" style="zoom:67%;" />

​    区（Extent）是比页大一级的存储结构，在`InnoDB`存储引擎中，一个区会分配**64个连续的页**，因为`InnoDB`中的页默认大小是16kb，所以一个区的大小是64*16kb=**1MB**。

​    段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在`InnoDB`中是连续的`64`个页），不过在段中不要求区与区之间是相邻的。**段是数据库中的分配单位**，**不同类型的数据库对象以不同的段形式存在**。当我们创建数据表、索引的时候，就会创建相应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

​    表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为**系统表空间**、**用户表空间**、**撤销表空间**、**临时表空间**等。

## 2.页的内部结构

​    页如果按照类型划分的话，常见的有数据页（保存`B+`树节点）、系统页、`Undo`页和事务数据页等。数据页是我们最常用的页。

​    数据页的`16kb`大小的存储空间被划分为七个部分。分别是头文件（File Header）、页头（Page Header）、最大最小记录（Infimum+supremum）、用户记录（User Records）。空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Trailer）。

​    页结构的示意图如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213141316276-e749637b64f1def4c9d11961cf33aa24-977aec.png" alt="image-20220213141316276" style="zoom:67%;" />

​    这七个部分作用分别如下：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213141452123-9f245cf11c39474bb49b5c95c31ca88c-bb80a4.png" alt="image-20220213141452123" style="zoom: 67%;" />

具体见：[参考](./第07章_InnoDB数据存储结构.mmap)

### 从数据页的角度看B+树如何查询

​    一颗 B+ 树按照节点类型可以分成两部分：

- 叶子节点，B+ 树最底层的节点，节点高度为0，存储行记录
- 非叶子节点，节点高度大于0，存储索引键和页面指针，并不存储行记录本身

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213152658171-a963267a6db3d70c2cc0205da1dd7647-28b51c.png" alt="image-20220213152658171" style="zoom:67%;" />

​    当我们从页结构来理解 B+ 树的结构时，可以帮我们理解一些通过索引进行检索的原理：

#### **1.B+ 树是如何进行记录检索的**

​    如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用**二分查找**的方式先找到一个粗略的记录分组，然后再在分组中通过**链表遍历**的方式查找记录。

#### **2.普通索引和唯一索引在查询效率上有什么不同**

​    我们创建索引的时候可以是普通索引，也可以是唯一索引。唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，**找到了关键字就停止检索**。而普通索引可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16kb，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的，所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。

## 3.InnoDB 行格式（或记录格式）

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20221216001102735-ac901a48091e595d17b7844ac4951e54-f2312d.png" alt="image-20221216001102735" style="zoom: 50%;" />

- 每行大小不能超过数据页 16KB 的一半，即 8KB，超过的会存储在**溢出页**（BLOB - Binary Large Object 页）中；`Compressed`和`Dynamic`这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页，而实际的数据都存储在溢出页中；对于`Compact`和`Redundant`行存储格式存放的数据，采用的是部分行溢出存储，前 768 字节还是会存放在当前数据页中的

- 对于 text 和 blob 类型，在遇到使用临时表的情况时，无法使用内存临时表，只能在磁盘上创建临时表。对于行溢出数据，InnoDB 一次只会为一个列分配一页的空间，但是当该列超过 32 个页后会一次性分配 64 个页面，存储空间有一定的浪费。行溢出数据禁用了自适应哈希索引，只能使用部分前缀进行排序，默认是 1024 字节，可以通过`max_sort_length`进行设置

- 针对不定长类型，如`varchar`，一般首先收到限制的是 MySQL 本身 65535B 的限制，受不到存储引擎限制是因为，不定长类型如果长度超过 8126B，会采用页外存储；针对定长类型，如`char`，首先会受到存储引擎 8126B 限制

- NULL 值列表最少占用 1 字节，用来表示值为 NULL 的列，若 NULL 列数量超过 255 则会增加 1 字节

- 行格式中「变长字段长度列表」的每个元素有时候是占用 1 字节，有时候是占用 2 字节：

  - 如果变成字段允许存储的最大字节数小于等于 255 字节，「变长字段长度列表」就占用 1 个字节；

  - 如果变成字段允许存储的最大字节数大于 255 字节，「变长字段长度列表」就占用 2 个字节；

  可以看到，「变长字段长度列表」占用的字节数最大不会不超过 2 字节，2 个字节的最大值是 65535，从这里可以得出一个变长字段最大能存储 65535 字节的数据。如果有多个字段的话，要保证除了 TEXT 和 BLOB 外的`所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535`。

具体见：[参考](./第07章_InnoDB数据存储结构.mmap)

## 4.区、段与碎片区

### 4.1 为什么要有区？

​    `B+`树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能里的非常远。我们介绍`B+`树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置里的非常远，就是所谓的**随机IO**。随机IO是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的**顺序IO**。

​    引入**区**的概念，一个区就是在物理位置上连续的`64`个页。因为`InnoDB`中的页的大小默认是`16kb`，所以一个区的大小是`64*16kb=1MB`，在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点空间的浪费（数据不足以填充整个区），但是从性能角度看，可以消除很多的**随机IO**。

### 4.2 为什么要有段？

​    对于范围查询，其实是对`B+`树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了，所以`InnoDB`对`B+`树的**叶子节点**和**非叶子节点**进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成 2 个段，一个**叶子节点段**，一个**非叶子节点段**。

​    除了索引的叶子节点段和非叶子节点段之外，`InnoDB`中还有为存储一些特殊的数据而定义的段，比如回滚段。所以常见的段有**数据段**、**索引段**、**回滚段**，数据段即为`B+`树的叶子节点，索引段即为`B+`树的非叶子节点。

​    在`InnoDB`存储引擎中，对段的管理都是由引擎自身完成的，`DBA`不能也没有必要对其进行控制，在一定程度上简化了`DBA`对于段的管理。

​    段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。

### 4.3 为什么要有碎片区？

​    默认情况下，一个使用`InnoDB`存储引擎的表只有一个聚簇索引，一个索引会生成 2 个段，而段是以区为单位申请存储空间的，一个区默认占用 1M（64*16kb=1024kb）的存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表相当浪费。

​    为了解决以完整的区为单位分配给某个段对于**数据量较小**的表太浪费存储空间的情况，`InnoDB`提出了一个**碎片区**（fregment）的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些用于段B，有些甚至不属于任何段。**碎片区直属于表空间**，并不属于任何一个段。

​    所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据时，段是从某个碎片区以单个页面为单位来分配存储空间的
- 在某个段已经占用了 **32 个碎片区**页面之后，就会申请以完整的区为单位来分配存储空间

​    所以现在段不能仅定义为是某些区的集合，更精确的应该是**某些零散的页面**以及**一些完整的区**的集合

### 4.4 区的分类

​    区大体上可以分为 4 种类型：

- **空闲的区（FREE）**：现在还没有用到这个区中的任何页面
- **有剩余空间的碎片区（FREE_FRAG）**：表示碎片区中还有可用的页面
- **没有剩余空间的碎片区（FULL_FRAG）**：表示碎片区中的所有页面都被使用，没有空闲页面
- **附属于某个段的区（FSEG）**：每一个索引都可以分为叶子节点段和非叶子节点段

​    处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，直属于表空间，而处于`FSEG`状态的区是附属于某个段的。

## 5.表空间

​    表空间可以看作是`InnoDB`存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。

​    表空间是一个**逻辑容器**，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为**系统表空间**（System tablespace）、**独立表空间**（File-per-talbe tablespace）、**撤销表空间**（Undo Tablespace）和**临时表空间**（Temporary Tablespace）等。

### 5.1 独立表空间

​    独立表空间，即每张表都有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即单表）可以在不同的数据库之间进行迁移。

​    空间可以回收（DROP TABLE 操作可自动回收表空间，其他情况表空间不能自己回收）。如果对于统计分析或是日志表，删除大量数据后可以通过：`alter table tableName engine=innodb;`回收不同的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理

#### **独立表空间结构**

​    独立表空间由段、区、页组成。

#### **真实表空间对应的文件大小**

​    我们到数据目录里看，会发现一个新建的表对应的`.ibd`文件只占用了 96k，才 6 个页面大小（5.7中），这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这是 .ibd 文件是**自扩展**的，随着表中数据的增多，表空间对应的文件也逐渐增大。

#### **查看 InnoDB 的表空间类型：**

```sql
SHOW VARIABLES LIKE 'innodb_file_per_talbe';
```

​    你会发现该值为`ON`，意味着每张表都会单独保存为一个`.ibd`文件。

### 5.2 系统表空间

​    系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。

#### **InnoDB 数据字典**

​    每当我们向一个表中插入一条记录的时候，MySQL 校验过程如下：

​    先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，例如：

- 某个表属于哪个表空间，表里面有多少列
- 表对应的每一个列的类型是什么
- 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面是在哪个表空间的哪个页面
- 该表有哪些外键，外键对应哪个表的哪些列
- 某个表空间对应文件系统上的文件路径
- ... ...

​    上述这些数据并不是我们使用`INSERT`语句插入的用户数据，实际上是为了更好地管理我们这些用户数据而不得不引入的一些额外数据，这些数据也被称为**元数据**，InnoDB 存储引擎特意定义了一些列的**内部系统表**（Internal System Table）来记录这些元数据：

|       表名       |                             描述                             |
| :--------------: | :----------------------------------------------------------: |
|    SYS_TABLES    |             整个 InnoDB 存储引擎中所有的表的信息             |
|   SYS_COLUMNS    |             整个 InnoDB 存储引擎中所有的列的信息             |
|   SYS_INDEXES    |            整个 InnoDB 存储引擎中所有的索引的信息            |
|    SYS_FIELDS    |        整个 InnoDB 存储引擎中所有的索引对应的列的信息        |
|   SYS_FOREIGN    |            整个 InnoDB 存储引擎中所有的外键的信息            |
| SYS_FOREIGN_COLS |         整个 InnoDB 存储引擎中所有的外键对应列的信息         |
| SYS_TABLESPACES  |            整个 InnoDB 存储引擎中所有的表空间信息            |
|  SYS_DATAFILES   | 整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息 |
|   SYS_VIRTUAL    |         整个 InnoDB 存储引擎中所有的虚拟生成列的信息         |

​    这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中`SYST_ABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS`这四个表尤其重要，称之为基本系统表（Basic System Tables）。

#### **SYS_TABLES 表结构**

|    列名    |                         描述                         |
| :--------: | :--------------------------------------------------: |
|    NAME    |                    表的名称，主键                    |
|     ID     | InnoDB 存储引擎中每个表都有一个唯一的 ID（二级索引） |
|  N_COLS·   |                  该表拥有的列的个数                  |
|    TYPE    |   表的类型，记录了一些文件格式、行格式、压缩等信息   |
|   MIX_ID   |                     已过时，忽略                     |
|  MIX_LEN   |                  表的一些额外的属性                  |
| CLUSTER_ID |                     未使用，忽略                     |
|   SPACE    |                 该表所属表空间的 ID                  |

#### **SYS_COLUMNS 表结构**

|   列名   |                             描述                             |
| :------: | :----------------------------------------------------------: |
| TALBE_ID |        该列所属表对应的 ID（与 POS 一起构成联合主键）        |
|   POS    |                      该列在表中是第几列                      |
|   NAME   |                          该列的名称                          |
|  MTYPE   |     main data type，主数据类型（INT、CHAR、VARCHAR 等）      |
|  PRTYPE  | precise type，精确数据类型，就是修饰主数据类型的，比如是否允许 null 值等 |
|   LEN    |                 该列最多占用存储空间的字节数                 |
|   PREC   |                    该列的精度，默认值为0                     |

#### **SYS_INDEXES 表结构**

|      列名       |                             描述                             |
| :-------------: | :----------------------------------------------------------: |
|    TABLE_ID     |       该索引所属表对应的 ID（与 ID 一起构成联合主键）        |
|       ID        |          InnoDB 存储引擎中每个索引都有一个唯一的 ID          |
|      NAME       |                         该索引的名称                         |
|    N_FIELDS     |                       该索引包含的列数                       |
|      TYPE       | 该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型 |
|      SPACE      |                 该索引跟页面所在的表空间 ID                  |
|     PAGE_NO     |                   该索引根页面所在的页面号                   |
| MERGE_THRESHOLD | 如果页面中的纪录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例 |

#### **SYS_FIELDS 表结构**

|   列名   |                        描述                        |
| :------: | :------------------------------------------------: |
| INDEX_ID | 该索引列所属的索引的 ID（与 POS 一起构成联合主键） |
|   POS    |            该索引列在某个索引中是第几列            |
| COL_NAME |                   该索引列的名称                   |

> 注意：
>
> ​    用户是**不能直接访问** InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容有助于大家分析问题，所以在系统数据库`information_schema`中提供了一些以`innodb`开头的表：
>
> ```sql
> mysql> use information_schema;
> Database changed
> mysql> show tables;
> +---------------------------------------+
> | Tables_in_information_schema          |
> +---------------------------------------+
> ...
> | INNODB_COLUMNS                        |
> | INNODB_DATAFILES                      |
> | INNODB_FIELDS                         |
> | INNODB_FOREIGN                        |
> | INNODB_FOREIGN_COLS                   |
> | INNODB_INDEXES                        |
> | INNODB_TABLES                         |
> | INNODB_TABLESPACES                    |
> | INNODB_TABLESTATS                     |
> | INNODB_VIRTUAL                        |
> ...
> +---------------------------------------+
> 73 rows in set (0.00 sec)
> ```
>
> ​    在`informationschema`数据库中的这些表并不是真正的内部系统表（内部系统表就是上面以`SYS`开头的表），而是在存储引擎启动时读取这些以`SYS`开头的系统表，然后填充到这些`INNODB`开头的表中，且**字段并不完全一样**。

## **附录：数据页加载的三种方式**

​    `InnoDB`从磁盘中读取数据的**最小单位**是数据页。而如果想得到`id=xxx`的数据，就是这个数据页众多行中的一行。对于`MySQL`存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按**数据页**形式存放数据的，当期加载到`MySQL`中我们称之为**缓存页**。

​    如果缓冲池中没有该页数据，那么缓冲池中有以下三种读取数据的方式，每种方式的读取效率都不相同：

1. 内存读取

   ​    如果该数据存在于内存中，基本上执行时间在`1ms`左右，效率还是很高的。

   <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213182644877-70e5a2dce5d2ba2f3dcae64849afa3e1-2461aa.png" alt="image-20220213182644877" style="zoom:67%;" />

2. 随机读取

   ​    如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在`10ms`左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间（包括了**寻道**和**半圈旋转时间**），有 3ms 是对可能发生的排队时间的估计值，还有 1ms 的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说已经非常长了，因为这还只是一个页的读取时间。

   <img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220213183148970-f86a2ebb6a8ae2afc40977e57538597d-74b960.png" alt="image-20220213183148970" style="zoom:67%;" />

3. 顺序读取

   ​    顺序读取其实是一种批量读取的方式，因为我们请求的**数据在磁盘上往往都是相邻存储的**，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其它页面单独进行磁盘IO操作了。如果一个磁盘的吞吐量是 40MB/S，那么对于一个 16kb 大小的页来说，一次可以顺序读取 2560（40mb/16kb）个页，相当于一个页的读取时间为 9.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。