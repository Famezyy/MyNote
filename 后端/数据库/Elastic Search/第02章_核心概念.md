# 第02章_核心概念

## 1.节点

一个节点就是一个 Elasticsearch 的实例，可以理解为一个 ES 的进程，但是一个节点 ≠ 一台服务器。

## 2.角色

### 2.1 常见的角色

#### 1.主节点（active master）

集群中只允许有一个活跃的主节点（下面简称主节点），我们称之为 active master 节点。一般为了避免主节点宕机造成集群无主，所以需要配置候选节点以便在主节点宕机时选举出新的主节点。

通常在口语中所说的主节点（或者 master 节点）指的都是 active master 节点，而不是严格意义上的配置了 master 角色的节点，换句话说，配置了 master 的节点应该叫做候选节点，其不一定是主节点，只有在 master 选举中胜出的节点，才是主节点，即 active master 节点。

主节点必须遵循以下分配原则：

- **避免重负载任务**：主节点负责轻量级集群范围的操作，例如创建或删除索引、跟踪哪些节点是集群的一部分以及决定将哪些分片分配给哪些节点。拥有一个稳定的主节点对于集群健康很重要。如果所选的主节点承载了其他任务，比如数据的增删改查等资源密集型人物，会对集群的稳定运行造成较大影响。避免主节点负载过重的最可靠方法是把所有配置了 master 角色的节点配置为专用主节点（或者称之为专用候选节点），使它们能够专注于管理集群
- **负载均衡器**：专用 master 节点仍将充当协调节点，也就是集群中的负载均衡器，将请求从客户端路由到集群中的其他节点，但是不要以负载均衡器的目的而设置候选节点
- 任何不是 `voting-only` 的 `master-eligible` 节点都可以被选举为 `active master`
- 主节点必须有一个 `path.data` 目录，其内容在重启后仍然存在，就像数据节点一样，因为这是存储集群元数据的地方。集群元数据描述了如何读取存储在数据节点上的数据，因此如果丢失，则无法读取存储在数据节点上的数据
- 高可用性（HA）集群需要至少三个候选节点，其中至少两个不是仅投票节点。这样即使其中一个节点发生故障，也可以保证剩下的节点能够选举出一个主节点

#### 2.候选节点（master-eligible）

候选节点即 master-eligible node，经常也称之为 master node 。默认情况下候选节点默认也是有效的投票节点，即配置了 master 角色的节点默认具备选举权和被选举权，可以参与选举，也可以为其他节点投票。

活跃的主节点一定是配置了 master 角色的节点，即一定是候选节点，但是候选节点不一定是主节点，一个集群中只可能有一个主节点，而可以同时存在多个候选节点，候选节点的作用主要在于当主节点宕机或发生故障脱离集群时，参与选举成为新的主节点，从而避免集群无主。

任何不是仅投票节点的主合格节点都可以通过主选举过程选举成为主节点。

#### 3.专用主节点（dedicated master-eligible node）

一般指仅配置了 master 角色的节点，其设计初衷为尽可能的让主节点职责单一，避免重负载任务给集群管理带来压力。

```bash
node.roles: [ master ]
```

#### 4.仅投票节点（voting_only node）

值仅具备选举权可以为其他候选节点投票，而没有被选举权无法参与竞选的节点。

为了避免让主节点执行重负载任务，遵循职责单一原则，我们一般不为其分配 data 角色，从而避免让主节点执行数据的增删改查这种重负载任务。但是这无形中造成很大的资源浪费，尤其是小规模集群，本身服务器节点就少。以一个五节点的集群为例，如果我们为了遵循职责单一法则，让其中 3 个 master 节点都作为专用候选节点（仅配置 master 角色），那么真正执行增删改查的节点就只有两个了。一个很好的办法就是“二加一部署”，即两个专用主节点 **＋** 一个仅投票节点：

| **节点** | **角色**                  | **是否主节点** | **选举权** | **被选举权** | **备注**                                                     |
| -------- | ------------------------- | -------------- | ---------- | ------------ | ------------------------------------------------------------ |
| node-1   | master                    | ★              | ✔          | ✔            | 活跃的主节点，同时也是一个负载均衡器                         |
| node-2   | master                    | 否             | ✔          | ✔            | 候选节点，主要作用是当 node-1 故障时替代 node-1 成为主节点，次要作用是充当负载均衡器 |
| node-3   | master、voting_only、data | 不可能         | ✔          | **X**        | 虽然配置了 master 角色，但是只能投票。其永远不可能成为主节点，因此可为其分配 data 角色，避免了 node-3 空置，降低了资源浪费 |
| node-4   | data                      | 不可能         | 无效       | **X**        | 主要承担数据的读写任务，不具备有效的选举权和被选举权         |
| node-5   | data                      | 不可能         | 无效       | **X**        | 主要承担数据的读写任务，不具备有效的选举权和被选举权         |

**配置**

一般情况下，voting_only 和 master 角色是一起配置的，单独配置 voting_only 角色是没有意义的。

配置 master 角色的节点拥有被选举权和选举权，而 voting_only 的作用就是阉割掉候选节点的被选举权，让其只能投票，而不能参与选举。所以如果没有 master 角色，配置 voting_only 也是没有意义的。

```bash
node.roles: [ data, master, voting_only ]
```

#### 5.数据节点（data node）

数据节点保存包含已编入索引的文档的分片。数据节点处理数据相关操作，如 CRUD、搜索和聚合。这些操作是 I/O 密集型、内存密集型和 CPU 密集型的。监控这些资源并在它们过载时添加更多数据节点非常重要。

```bash
node.roles: [ data, xxx ]
```

#### 6.预处理节点（ingest node）

预处理节点有点类似于 logstash 的消息管道，所以也叫 ingest pipeline，常用于一些数据写入之前的预处理操作，比如去除空格、`split` 等操作。

```bash
node.roles: [ ingest, xxx ]
```

#### **7.远程节点（remote_cluster_client client）**

具有 `remote_cluster_client` 角色的节点，使其有资格充当远程客户端。当需要通过远程访问节点时，该角色必须配置，比如通过 `publish_host` 配置的地址访问服务节点时，该角色必须启用。

```bash
node.roles: [ remote_cluster_client, xxx ]
```

#### 8.小规模集群推荐高可用配置

专用主节点存在的意义和集群规模是正相关的，也就是说，集群规模越大，配置专用主节点的意义也就越大。对于上面提到的五节点的集群，两个专用主节点的设计，对于当前集群规模来说，仍然是存在很大的浪费的，对于小规模集群，master 也可以分配 data 的角色来充分利用资源。

| **节点** | **角色**      | **是否主节点** | **选举权** | **被选举权** |
| -------- | ------------- | -------------- | ---------- | ------------ |
| node-1   | master、data  | ★              | ✔          | ✔            |
| node-2   | master 、data | 否             | ✔          | ✔            |
| node-3   | master 、data | 否             | ✔          | ✔            |
| node-4   | data          | 不可能         | 无效       | **X**        |
| node-5   | data          | 不可能         | 无效       | **X**        |

### 2.2 配置方法

```bash
node.roles: [ 角色1, 角色2, xxx ]
```

如果 `node.roles` 为缺省配置，那么当前节点具备所有角色。

## 3.索引

索引在 ES 中所表述的含义和 MySQL 中的索引完全不同，在 MySQL 中索引指的是加速数据查询的一种特殊的数据结构。而在 ES 中，索引表述的含义等价于 MySQL 中的表（仅针对 ES 7.x 以后版本），注意这里只是类比去理解，索引并不等于表。

在 ES 中，索引在不同的特定条件下可以表示三种不同的意思：

- **表示源文件数据**：当做数据的载体，即类比为数据表，通常称作 index 。例如：通常说集群中有 product 索引，即表述当前 ES 的服务中存储了 product 这样一张“表”
- **表示索引文件**：以加速查询检索为目的而设计和创建的数据文件，通常承载于某些特定的数据结构，如哈希、FST 等。例如：通常所说的**正排索引**和**倒排索引**（也叫正向索引和反向索引）就是当前这个表述，索引文件和源数据是完全独立的，索引文件存在的目的仅仅是为了加快数据的检索，不会对源数据造成任何影响
- **表示创建数据的动作**：通常说创建或添加一条数据，在 ES 的表述为索引一条数据或索引一条文档，或者 index 一个 doc 进去。此时索引一条文档的含义为向索引中添加数据

**索引命名规范**

- 字母全部小写
- 多个单词使用下划线连接

**索引的组成部分**

- `alias`：即 索引别名，参考 [ES 中索引别名](http://www.elastic.org.cn/archives/alias)
- `settings`：索引设置，常见设置如分片和副本的数量等
- `mapping`：即映射，定义了索引中包含哪些字段，以及字段的类型、长度、分词器等

## 4.类型（ES 7.x 之后版本已删除此概念）

### 4.1 类型的基本概念

从 Elasticsearch 的第一个版本开始，每个文档都存储在一个索引中并分配一个映射类型。映射类型用于表示被索引的文档或实体的类型，例如 product 索引可能具有 user 类型和 order 类型。每个映射类型都可以有自己的字段，因此该 user 类型可能有一个 user_name 字段、一个 title 字段和一个 email 字段，而该 order 类型可以有一个 content 字段、一个 title 字段，并且和 user 类型一样，也有一个 user_name 字段。

每个文档都有一个 `_type` 包含类型名称的元数据字段，通过在 URL 中指定类型名称，可以将搜索限制为一种或多种类型：

```json
GET product/user,order/_search
{
  "query": {
    "match": {
      "user_name": "吕小布"
    }
  }
}
```

### 4.2 为什么要删除

最初，“索引”类似于 SQL 数据库中的“数据库”，“类型”相当于“表”：

| 元字段   | ES 6.x 及早期版本 | ES 7.x 及之后版本 |
| :------- | :---------------- | :---------------- |
| `_index` | DataBase          | Table             |
| `_type`  | Table             | 固定为 `_doc`     |
| `_doc`   | Row               | Row               |

- **逻辑不合理**

  然而这是错误的类比，官方后来也意识到了这是个错误。在 SQL 数据库中，表是相互独立的，一个表中的列与另一个表中的同名列无关，然而对于**映射类型**中的字段情况并非如此。

- **数据结构混乱**

  在 Elasticsearch 索引中，不同映射类型中具有相同名称的字段在内部由相同的 Lucene 字段支持。换句话说，使用上面的示例，类型中的 user_name 字段与 user 和 order 类型中的字段存储在**完全相同**的 user_name 字段中 ，并且两个 user_name 字段在两种类型中必须具有相同的映射（定义）。

- **影响性能**

  最重要的是，在同一索引中存储具有很少或没有共同字段的不同实体会导致数据稀疏并干扰 Lucene 有效压缩文档的能力。

### 4.3 替代方案

第一种选择是为每个文档类型设置一个索引，而不是把 user 和 order 存储在单个索引中。这样索引彼此完全独立，因此索引之间不会存在字段类型冲突。

这种方法有以下好处：

- 避免了稀疏字段，数据更密集，有利于 Lucene 中对索引的压缩效率
- 在全文搜索中用于评分的术语统计信息更可能准确，因为同一索引中的所有文档都表示单个实体
- 索引粒度更小，方便动态优化每个索引的性能。比如可以分别为两个索引单独设置不同的分片数量

### 4.4 不同版本中的变化

**ES 5.6.0**

- 在索引上设置 `index.mapping.single_type: true` 将启用将在 6.0 中强制执行的单类型索引行为
- parent-child 的 [join 字段](https://www.elastic.co/guide/en/elasticsearch/reference/7.17/parent-join.html) 替换可用于 5.6 中创建的索引

**ES 6.x**

- 在 5.x 中创建的索引将在 6.x 中继续发挥作用，就像在 5.x 中一样
- 在 6.x 中创建的索引仅允许每个索引使用单一类型。该类型可以使用任何名称，但只能有一个。首选类型名称是 `_doc`，以便索引 API 具有与 7.0 中相同的路径：

```bash
PUT {index}/_doc/{id} 和 POST {index}/_doc
```

- `_type` 名称不能再与 组合 形成 `_id` 字段 `_uid`。该 `_uid` 字段已成为该 `_id` 字段的别名
- 新索引不再支持旧式的父/子，而应使用该 [join 字段](https://www.elastic.co/guide/en/elasticsearch/reference/7.17/parent-join.html)
- 不推荐使用 `_default_` 映射类型
- 在 6.8 中，索引创建、索引模板和映射 API 支持查询字符串参数 ( include_type_name)，该参数指示请求和响应是否应包含类型名称。它默认为 true，并且应该设置为一个明确的值以准备升级到 7.0。不设置 include_type_name 将导致弃用警告。没有显式类型的索引将使用虚拟类型名称 `_doc`

**ES 7.x**

- **不推荐**在请求中指定类型。例如，索引文档不再需要文档 `type`。新的索引 API 适用 `PUT {index}/_doc/{id}` 于显式 ID 和 `POST {index}/_doc` 自动生成的 ID。请注意在 7.0 中，`_doc` 是路径的永久部分，表示端点名称而不是文档类型
- 索引创建、索引模板和映射 API 中的 `include_type_name` 参数将默认为 false。完全设置参数将导致弃用警告
- _`default_` 映射类型被删除 

**ES 8.x**

- **不再支持**在请求中指定类型
- 该 `include_type_name` 参数被删除

## 5.文档

### 5.1 文档的基本结构

```json
{
   	/* metadata fields */
    "_index": "product",
    "_id": "1",
    "_version": 1,
    "_seq_no": 0,
    "_primary_item": 1,
    "found": true, /* found 不是 metadata */
    "_scourse": {
        /* source data */
    	"name": "phone",
    	"desc": "description",
        ...
	}
}
```

### 5.2 mata data

所有的元字段均已下划线开头，为系统字段。

- `_index`：索引名称
- `_id`：文档 id
- `_version`：版本号
- `_seq_no`：索引级别的版本号，索引中所有文档共享一个 `_seq_no`
- `_primary_term`：`_primary_term` 是一个整数，每当 Primary Shard 发生重新分配时，比如节点重启，Primary 选举或重新分配等，`_primary_term` 会递增 1。主要作用是用来恢复数据时处理当多个文档的 `_seq_no` 一样时的冲突，避免 Primary Shard 上的数据写入被覆盖

### 5.3 source data

源数据，指业务数据，即最终写入的用户数据。

## 6.集群

ES 搭建集群是自动发现的，无需任何网络配置，Elasticsearch 将绑定到可用的环回地址并扫描本地端口 9300 到 9305 连接同一服务器上运行的其他节点，自动形成集群。此行为无需进行任何配置即可提供自动集群服务。

### 6.1 核心配置

- `network.host`：即提供服务的 IP 地址，一般配置为本节点所在服务器的**内网地址**，此配置会导致节点由开发模式转为生产模式，从而触发引导检查
- `network.publish_host`：即提供服务的 IP 地址，一般配置为本节点所在服务器的**公网地址**
- `http.port`：服务端口号，默认 9200，通常范围为 9200~9299
- `transport.port`：节点通信端口，默认 9300，通常范围为 9300~9399
- `discovery.seed_hosts`：此设置提供集群中其他候选节点的列表，并且可能处于活动状态且可联系以播种[发现过程](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-hosts-providers.html)。每个地址可以是 IP 地址，也可以是通过 DNS 解析为一个或多个 IP 地址的主机名
- `cluster.initial_master_nodes`：指定集群初次选举中用到的候选节点，称为集群引导，只在第一次形成集群时需要，如过配置了 `network.host`，则此配置项必须配置。重新启动节点或将新节点添加到现有集群时不要使用此设置

### 6.2 健康检查

#### 1. 健康状态

- <span style="color:green">绿色</span>：所有分片都可用
- <span style="color:orange">黄色</span>：至少有一个副本不可用，但是所有主分片都可用，此时集群能提供完整的读写服务，但是可用性较低
- <span style="color:red">红色</span>：至少有一个主分片不可用，数据不完整，此时集群无法提供完整的读写服务，集群不可用

> **注意**
>
> 集群不可用指的是集群状态为红色，无法提供完整读写服务，而不代表无法通过客户端远程连接和调用服务。

#### 2.健康值检查

**方法一：_cat API**

```bash
GET _cat/health
```

返回结果如下：

```json
[
  {
    "epoch": "1710248303",
    "timestamp": "12:58:23",
    "cluster": "elasticsearch",
    "status": "green",
    "node.total": "2",
    "node.data": "2",
    "shards": "0",
    "pri": "0",
    "relo": "0",
    "init": "0",
    "unassign": "0",
    "pending_tasks": "0",
    "max_task_wait_time": "-",
    "active_shards_percent": "100.0%"
  }
]
```

**方法二：_cluster API**

```bash
GET _cluster/health
```

返回结果如下：

```json
{
  "cluster_name": "elasticsearch",
  "status": "green",
  "timed_out": false,
  "number_of_nodes": 2,
  "number_of_data_nodes": 2,
  "active_primary_shards": 0,
  "active_shards": 0,
  "relocating_shards": 0,
  "initializing_shards": 0,
  "unassigned_shards": 0,
  "delayed_unassigned_shards": 0,
  "number_of_pending_tasks": 0,
  "number_of_in_flight_fetch": 0,
  "task_max_waiting_in_queue_millis": 0,
  "active_shards_percent_as_number": 100
}
```

#### 3.集群的故障诊断

集群常见故障诊断手段通常为：通过检查集群的健康状态，是否有节点未加入或者脱离集群，以及是否有异常状态的分片。可采取以下 API 完成对集群的故障诊断。

**（1）Cat APIs**

- `_cat/indices?health=yellow&v=true`：查看当前集群中的所有索引
- `_cat/health?v=true`：查看健康状态
- `_cat/nodeattrs`：查看节点属性
- `_cat/nodes?v`：查看集群中的节点
- `_cat/shards`：查看集群中所有分片的分配情况

**（2）Cluster APIs**

- `_cluster/allocation/explain`：可用于诊断分片未分配原因
- `_cluster/health/` ：检查集群状态

**索引未分配的原因**

- `ALLOCATION_FAILED`：由于分片分配失败而未分配
- `CLUSTER_RECOVERED`：由于完整集群未恢复而未分配
- `DANGLING_INDEX_IMPORTED`：由于导入悬空索引而未分配
- `EXISTING_INDEX_RESTORED`：由于还原到闭合索引而未分配
- `INDEX_CREATED`：由于 API 创建索引而未分配
- `INDEX_REOPENED`：由于打开闭合索引而未分配
- `NEW_INDEX_RESTORED`：由于还原到新索引而未分配
- `NODE_LEFT`：由于承载它的节点离开集群而取消分配
- `REALLOCATED_REPLICA`：确定更好的副本位置并取消现有副本分配
- `REINITIALIZED`：当碎片从“开始”移回“初始化”时
- `REPLICA_ADDED`：由于显式添加了复制副本而未分配
- `REROUTE_CANCELLED`：由于显式取消重新路由命令而取消分配

## 7.分片