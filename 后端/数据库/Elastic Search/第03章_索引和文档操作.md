# 第03章_索引和文档操作

## 1.Kibana简介

**优点**

- 官方支持，兼容性好
- 图形化界面，众多操作均可基于图形化操作完成，而无序任何代码
- 功能强大，不仅有有丰富的可视化报表，还提供了非常强大的开发者工具
- 快捷键丰富
- 开发者工具
- 样例数据

**缺点**

- 对于 Dev 环境，每次使用都需要启动
- 重负载，占用系统资源较大
- 基于 Java 环境，启动慢

在 kibana 的配置文件中，`i18n.locale` 配置项默认为 `en`，修改为如下配置即可修改为中文：

```json
i18n.locale: "zh-CN"
```

## 2.Search API

**基本语法**

```bash
GET <index_name>/_search?<param=value>
# 不指定 index_name 则从头开始查询所有文档
GET _search?<param=value>
# 只指定 index_name 表示查询索引组成部分：aliases、mappings、settings
GET index_name
```

**可选参数**

- `size`：单次查询多少条文档，默认为 10
- `from`：起始文档偏移量，需要为非负数，默认为 0
- `timeout`：指定等待每个分片响应的时间段，如果在超时到期之前未收到响应，则请求失败并返回错误，默认无超时

## 3.Index API

ES 的索引在创建成功后以下属性将**不可修改**：

- 索引名称
- 主分片数量
- 字段类型

### 3.1 settings

#### 1.设置settings

**语法**

```bash
PUT <index_name>
{
  "settings": {}
}
```

例如创建索引 `test_setting`，指定其主分片数量为 3，每个主分片的副本数量为 2：

```json
PUT test_setting
{
  "settings": {
    "number_of_shards": 3,  //主分片数量为 3，默认为 1
    "number_of_replicas": 2 //每个主分片分配 2 个副本
  }
}
```

此时一共有 9 个分片。

#### 2.修改settings

使用 `_setting` 只能修改允许动态修改的配置项。

**语法**

```bash
PUT /<index_name>/_settings
```

例如修改索引 `test_setting` 索引，把每个主分片的副本数量（可动态修改）修改为 0。

```json
PUT test_setting/_settings
{
  "number_of_replicas": 0
}
```

#### 3.静态索引设置

对于静态索引，如 `index.number_of_shards`，只能在创建索引时或在关闭状态的索引上设置。

每个索引的分片的数量上限为 1024，这是一个安全限制，以防止意外创建索引，这些索引可能因资源分配而破坏集群的稳定性。`export ES_JAVA_OPTS=“-Des.index.max_number_of_shards=128”` 可以通过在属于集群的每个节点上指定系统属性来修改限制。

#### 4.动态索引设置

可以使用 `_setting` API 在实时修改的配置项。

- `index.number_of_replicas`：每个主分片的副本数。默认为 1，允许配置为 0
- `index.refresh_interval`：执行刷新操作的频率。默认为 1s，可以设置 -1 为禁用刷新
- `index.max_result_window`：from + size 搜索索引的最大值。默认为 10000，即 from + size <= 10000，超出则返回错误，因为过大的数值可能会造成 OOM，[解释](https://es-cn.blog.csdn.net/article/details/120800632)。参阅 [Scroll](https://www.elastic.co/guide/en/elasticsearch/reference/8.5/paginate-search-results.html#scroll-search-results) 或 [Search After](https://www.elastic.co/guide/en/elasticsearch/reference/8.5/paginate-search-results.html#search-after) 以获得更有效的替代方法

### 3.2 创建索引

**语法**

```bash
PUT <index_name>
```

**索引命名规范**

- 必须全部**小写**
- 索引名称中不能包含以下符号：`\`、`/`、`*`、`?`、`"`、`<`、`>`、`|`、` ` 空白符号、`,`、`#`
- 7.0 之前的索引可以包含冒号英文冒号 `:`，但在 7.x 及之后版本中不再受支持
- 不使用中文命名索引
- 可以使用 `-`、`_` 或者 `+` 三种符号，但是不能以这三种符号开头
- 不能是 `.` 或者 `..`
- 不能超过 255 个字节长度
- 业务索引不能以 `.` 开头，因为这些索引是给内部索引（如数据流中的后备索引）和隐藏索引使用的

### 3.3 删除索引

**语法**

```bash
DELETE /<index_name>
```

**判断索引是否存在**

```bash
HEAD <index_name>
```

### 3.4 reindex

用于从一个索引中复制文档到新的索引。

**语法**

```bash
POST _reindex {
	# 目标索引
	"source": {
		"index": "test_index"
	},
	# 源索引
	"dest": {
		"index": "test_index_new"
	}
}
```

## 4.Document API

### 4.1 文档操作类型

```java
enum OpType {
   INDEX(0),
   CREATE(1)
}
```

- `index`：索引（动词），可以是创建，也可以是全量替换
- `create`：不存在则创建，存在则报错

> **注意**
>
> - 以上操作均为写操作
> - ES中的数据写入均发生在主分片
> - 当操作对象为数据流时，`op_type` 必须为 `create`

#### 1.Create

如果在 `PUT` 数据的时候当前数据已经存在，则数据会被覆盖，如果在 `PUT` 的时候指定操作类型 `create`，此时如果数据已存在则会返回失败，因为已经强制指定了操作类型为 `create`，ES就不会再去执行 `update` 操作。

**语法**

```bash
PUT <index_name>/_doc/<_id>?op_type=create
{
	"field": "value"
}
# 可简化为下面的写法
# 旧版本语法：PUT /<index_name>/_doc/<_id>/_create
PUT <index_name>/_create/<_id>
{
	"field": "value"
}
```

**案例**

创建一条 _id 为 1 的文档，并为其添加 name 和 content 两个字段。

```bash
PUT goods/_doc/1?op_type=create
{
  "name":"傻妞手机",
  "content":"华人牌2060款手机傻妞"
}
```

或执行

```bash
PUT goods/_create/1
{
  "name":"傻妞手机",
  "content":"华人牌2060款手机傻妞"
}
```

当文档不存在的时候，返回 created

```json
{
  "_index": "goods",
  "_id": "1",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 0,
  "_primary_term": 1
}
```

当文档已存在的时候

```json
{
  "error": {
    "root_cause": [
      {
        "type": "version_conflict_engine_exception",
        "reason": "[1]: version conflict, document already exists (current version [1])",
        "index_uuid": "p_2BvtuOTDeqikl4JXPmgQ",
        "shard": "0",
        "index": "goods"
      }
    ],
    "type": "version_conflict_engine_exception",
    "reason": "[1]: version conflict, document already exists (current version [1])",
    "index_uuid": "p_2BvtuOTDeqikl4JXPmgQ",
    "shard": "0",
    "index": "goods"
  },
  "status": 409
}
```

#### 2.Index（默认行为）

在 ES 中，写入操作被称为 Index，这里 Index 为动词，即索引数据为将数据创建在 ES 中的索引，写入数据亦可称之为“索引数据”。可以是**创建**，也可以是**全量替换**（所有字段都会被覆盖，如果新的为空则会删除该字段）。

**语法**

```bash
PUT /<index_name>/_doc/<_id>?op_type=index
{
  ...
}
# 上述代码，可简化为
PUT /<index_name>/_doc/<_id>
{
  ...
}
```

**案例**

向 goods 索引中索引一条 _id 为 1 的文档，并为其添加 name 和 content 两个字段。

```bash
PUT goods/_doc/1?op_type=index
{
  "name":"傻妞手机",
  "content":"华人牌2060款手机傻妞"
}
```

或执行

```bash
PUT goods/_doc/1
{
  "name":"傻妞手机",
  "content":"华人牌2060款手机傻妞"
}
```

当文档不存在的时候，返回 created

```json
{
    "_index": "goods",
    "_id": "1",
    "_version": 1,
    "result": "created",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 0,
    "_primary_term": 1
}
```

当文档存在的时候，返回 updated

```json
{
    "_index": "goods",
    "_id": "1",
    "_version": 3,
    "result": "updated",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 2,
    "_primary_term": 1
}
```

#### 3.自动生成ID

使用 `POST` 并且不指定 ID 时则会随机生成一个文档 ID。

```bash
POST /<target>/_doc/
```

**示例：创建一个文档，并随机生成文档 id**

```bash
POST test_index/_doc
{
  "test_field":"test",
  "test_title":"title"
}
```

### 4.2 文档的CRUD

#### 1.Document Index API

将 JSON 文档添加到指定的数据流或索引并使其可被检索。如果目标是索引并且文档已经存在，则请求更新文档并增加其版本号。

**语法**

```bash
PUT /<target>/_doc/<_id> {
	...
}

PUT /<target>/_create/<_id>{
	...
}

# 可以指定 ID 也可以不指定随机生成
POST /<target>/_create/<_id>{
	...
}
```

#### 2.Get API

**（1）查询指定 id 的文档**

```bash
GET <index>/_doc/<_id>
```

**（2）判断指定 id 的文档是否存在**

```bash
HEAD  <index>/_doc/<_id>
```

如过存在，返回 200

```bash
200 - OK
```

如过不存在，返回 404

```bash
{
  "statusCode": 404,
  "error": "Not Found",
  "message": "404 - Not Found"
}
```

通过 `HEAD` 判断文档是否存在的使用场景很局限，因为其完全可以被 `GET` 所取代，比如下列查询，当 id 为 1 的文档不存在的时候，返回 `found：false`

```bash
GET goods/_doc/1
```

结果

```bash
{
  "_index": "goods",
  "_id": "1",
  "found": false
}
```

**（3）_source API**

使用 `_source` API 可以打开或者关闭源数据字段，true 为打开，false 为关闭，默认为 true。

```bash
GET <index>/_doc/<_id>?_source=false
```

**案例**

正常情况下查看 Doc 的结果如下：

```bash
get my_index/_doc/c13rNY4BWY9dTIwqYgIF
```

```bash
{
  "_index": "my_index",
  "_id": "c13rNY4BWY9dTIwqYgIF",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "found": true,
  "_source": {
    ...
  }
}
```

当添加了 `_source=false` 之后，在结果中仅返回了元数据字段，而没有源数据 `source` 字段

```bash
get my_index/_doc/c13rNY4BWY9dTIwqYgIF?_source=false
```

结果

```bash
{
  "_index": "my_index",
  "_id": "c13rNY4BWY9dTIwqYgIF",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "found": true
}
```

当然也可以只查看 `_source` 字段，而不查看任何 mata data

```bash
get my_index/_source/c13rNY4BWY9dTIwqYgIF
```

```bash
{
  "FlightNum": "9HY9SWR",
  "DestCountry": "AU",
  "OriginWeather": "Sunny",
  "OriginCityName": "Frankfurt am Main",
  "AvgTicketPrice": 841.2656419677076,
  "DistanceMiles": 10247.856675613455,
  "FlightDelay": false,
  "DestWeather": "Rain",
  ...
}
```

#### 3.Delete API

删除索引中指定 id 的文档，Document Delete API 必须指定 id。

```bash
DELETE /<index_name>/_doc/<_id>
```

例如

```bash
DELETE goods/_doc/1
```

#### 4.Update API

用于修改局部字段或者数据，区别于 `PUT /<index_name>/_doc/<_id>?op_type=index`，后者 会**全量替换**原有的字段。

```bash
POST /<index_name>/_update/<_id>
{
  "doc": {
    "<field_name>": "<field_value>"
  }
}
```

> **注意**
>
> 7.x 及之前版本的语法 `POST test/_doc/1/_update` 已不再支持。

#### 5.Multi get API

批量获得数据。

**语法**

```bash
GET /_mget
{
  "docs": [
    {
      "_index": "<index_name>",
      "_id": "<_id>"
    },
    {
      "_index": "<index_name>",
      "_id": "<_id>"
    }
  ]
}
```

支持查询同一个索引的不同 id，也可以查询不同索引的不同 id。

**简化语法**

```json
GET <index_name>/_mget
{
  "docs": [
    {
      "_id": "<_id>"
    },
    {
      "_id": "<_id>"
    }
  ]
}
```

进一步简化

```json
GET /<index_name>/_mget
{
  "ids" : ["<_id_1>", "<_id_2>"]
}
```

#### 6.Bulk API

批量写入数据。

**语法**

```bash
POST /_bulk
# 或者
POST /<index>/_bulk
{"action":{"mata data"}} # 操作行为
{"data1"}                 # 数据
{"action":{"mata data"}}
{"data2"}
```

**（1）Create Document**

使用普通方式 create 一条文档

```json
PUT goods/_create/1
{
  "name": "傻妞手机",
  "content": "华人牌2060款手机傻妞",
  "price": 12999,
  "type": "手机",
  "level": "超级手机",
  "createtime": "2060-10-01T08:00:00Z",
  "tags": [
    "时光穿梭",
    "真人模式",
    "手机模式"
  ]
}
```

如果使用 bulk API 写入，代码如下

```bash
POST /_bulk 
{"create":{"_index":"goods","_id":"1"}}
{"name":"傻妞手机","content":"华人牌2060款手机傻妞","price":12999,"type":"手机","level":"超级手机","createtime":"2060-10-01T08:00:00Z","tags":["时光穿梭","真人模式","手机模式"]}
```

或者

```bash
POST goods/_bulk
{"create":{"_id":"1"}}
{"name":"傻妞手机","content":"华人牌2060款手机傻妞","price":12999,"type":"手机","level":"超级手机","createtime":"2060-10-01T08:00:00Z","tags":["时光穿梭","真人模式","手机模式"]}
```

**（2）Index Document**

使用普通方式索引一条文档

```json
PUT goods/_doc/2
{
  "name": "太子手机",
  "content": "太子手机是傻妞手机的克隆机",
  "price": 8999,
  "type": "手机",
  "level": "超级手机",
  "createtime": "2060-10-01T08:00:00Z",
  "tags": [
    "时光穿梭",
    "真人模式",
    "手机模式"
  ]
}
```

如过使用 bulk API 写入，代码如下

```json
POST /_bulk
{"index":{"_index":"goods","_id":"2"}}
{"name":"太子手机","content":"太子手机是傻妞手机的克隆机","price":8999,"type":"手机","level":"超级手机","createtime":"2060-10-01T08:00:00Z","tags":["时光穿梭","手机模式"]}
```

或者

```bash
POST goods/_bulk
{"index":{"_id":"2"}}
{"name":"太子手机","content":"太子手机是傻妞手机的克隆机","price":8999,"type":"手机","level":"超级手机","createtime":"2060-10-01T08:00:00Z","tags":["时光穿梭","手机模式"]}
```

**（3）Update Document**

id 为 2 的文档商品价格由 8999 修改为 6999

```json
POST goods/_update/2
{
  "doc": {
    "price": 6999
  }
}
```

使用 bulk API 修改，代码如下

```json
POST goods/_bulk
{ "update": {"_id": "2"} }
{ "doc" : {"price" : 6999} }
```

**（4）Delete Ducoment**

```json
POST /_bulk
{ "delete": { "_index": "goods",  "_id": "1" }}
```

**使用场景**

大数据量的批量操作，比如数据从 MySQL 中一次性写入 ES，批量写入减少了对 ES 的请求次数，从而降低内存开销以及对线程的占用。

**注意**：

- bulk API 对 JSON 的语法有严格的要求，除了 `delete` 外，每一个操作都要两个 JSON 串（`mata data` 和 `source field data`），且每个 JSON 串内不能换行，非同一个 JSON 串必须换行，否则会报错
- bulk 操作中，任意一个操作失败，是不会影响其他的操作的，但是在返回结果里，会告诉你异常日志

**优缺点**

- 优点：相较于普通的 JSON 格式的数据操作，不会产生额外的内存消耗，性能更好，常用于大数据量的批量写入
- 缺点：可读性差，可能会没有智能提示

#### 7.DeleteByQuery

```bash
POST /my_index/_delete_by_query
{
  "query": {
    "term": {
      "FlightNum": "test"
    }
  }
}
```

#### 8.UpdateByQuery

`update_by_query` 通常和 `Script` 以及 `Pipeline` 结合使用。
