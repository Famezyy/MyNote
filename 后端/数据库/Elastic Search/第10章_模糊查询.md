# 第10章_模糊查询

## 1.前缀搜索-prefix

以搜索词开头的搜索，不计算相关度评分。

注意：

- 前缀搜索性能很差
- 前缀搜索没有缓存
- 前缀搜索时尽可能使用较长的前缀

由于前缀搜索匹配的是分词后的词项，需要全长匹配，即给定的匹配词必须完全匹配上，因此默认情况下直接使用不会得到想要的结果。

**示例**

插入以下数据

```json
POST test_prefix/_bulk
{"index": {"_id": "1"}}
{"text": "今天我是一个苹果"}
{"index": {"_id": "2"}}
{"text": "今天我是一个香蕉"}
{"index": {"_id": "3"}}
{"text": "今天我是一个梨"}
```

尝试用 `今天` 来进行前缀查询

```json
GET test_prefix/_search
{
    "query": {
        "prefix": {
            "text": {
                "value": "今天"
            }
        }
    }
}
```

可以发现并没有任何命中，因为默认中文分词后会拆分成一个一个的词项。查询 `今` 时就可以匹配上。

因此在创建索引时我们需要主动指定中文分词器。

```json
PUT test_prefix
{
    "mappings": {
        "properties": {
            "text": {
                "analyzer": "ik_max_word",
                "type": "text",
                // 为每个倒排索引的词项再创建多个前缀索引（从 min_chars 到 max_chars）
                // 可以指定前缀的最小长度和最大长度，会占用内存，但会加快前缀匹配速度（不推荐）
                "index_prefixes": {
                    "min_chars": 2,
                    "max_chars": 3
                }
                "fields": {
                    "keyword": {
                        "type": "keyword",
                        "ignore_above": 256
                    }
                }
            }
        }
    }
}
```

此时插入数据后再次前缀查询即可查到数据。

## 2.通配符搜索-wildcard

匹配一个或多个字符的占位符。例如 `*` 会匹配 0 个或多个字符。通配符匹配的也是**分词后的词项**，需要全长匹配。

**示例**

插入以下数据

```json
POST test_prefix/_bulk
{"index": {"_id": "1"}}
{"text": "today I'm an apple"}
{"index": {"_id": "2"}}
{"text": "today I'm a banana"}
{"index": {"_id": "3"}}
{"text": "today I'm a pear"}
```

使用通配符匹配 `to*ay`

```json
get test_prefix/_search
{
    "query": {
        "wildcard": {
            "text": {
                "value": "to*ay"
            }
        }
    }
}
```

发现可以匹配上所有数据。

## 3.正则搜索-regex

正则搜索也是匹配的分词后的词项。

**语法**

```json
GET <index>/_search
{
    "query": {
        "regexp": {
            "<field>": {
                "value": "<regex>",
                "flags": "ALL"
            }
        }
    }
}
```

`flags`（基本不用）的可选值如下：

- `ALL`

  启用所有可选操作符。

- `COMPLEMENT`

  启动 `~` 操作符。可以使用 `~` 对后面紧跟着的字符进行否定。例如：`a~bc` 表示匹配除了 `abc` 以外的字符。

- `INTERVAL`

  启用 `<>` 操作符。可以使用 `<>` 匹配数值范围。例如：`foo<1-100>` 表示匹配 `foo1` 直到 `foo100`；`foo<01-100>` 表示匹配 `foo01` 直到 `foo100`。

- `INTERSECTION`

  启用 `&` 操作符。表示 `AND`，当且仅当左右两侧都匹配成功才匹配成功。例如：`aaa.+&.+bbb`。

- `ANYSTRING`

  启用 `@` 操作符。可以使用 `@` 匹配任何字符串。

不使用 `flag` 则可以简写如下：

```json
GET <index>/_search
{
    "query": {
        "regexp": {
            "<field>": "<regex>"
        }
    }
}
```

## 4.模糊查询-fuzzy

模糊查询有以下几种场景：

- 替换字符：`box` => `fox`
- 缺少字符：`black` => `lack`
- 添加字符：`sic` => `sick`
- 颠倒字符：`act` => `cat`

**语法**

```json
GET <index>/_search
{
    "query": {
        "fuzzy": {
            "<field>": {
                "value": "<keyword>",
                "fuzziness": <0 or 1 or 2 or AUTO>,
                "transpositions": <boolean>
            }
        }
    }
}
```

- `fuzziness`（可选）：编辑距离，默认 `AUTO`，表示根据字符长度动态设置 `0~2`；并非越大越好，它表示使一个字符串与另一个字符串匹配所需的插入、删除、替换和调换的次数

  > **补充**
  >
  > 在 ES 中当两个字符发生调换时只消耗 1 次距离，使用的是 `Damerau-Levenshitein` 公式。

- `transpositions`（可选）：表示是否包含两个相邻字符的变为，如 `ab` => `ba`，默认为 true 

此外在使用 `query` 进行 `match` 查询时也可以设置一个 `fuzziness` 参数表示启用模糊查询（默认是精确查询）：

```json
GET <index>/_search
{
    "query": {
        "match": {
            "<field>": {
                "query": "<keyword>",
                "fuzziness": <0 or 1 or 2 or AUTO>
            }
        }
    }
}
```

与 `fuzzy` 的区别是 `match` 会对搜索词 `keyword` 进行分词。

## 5.短语前缀

## 6.搜索优化