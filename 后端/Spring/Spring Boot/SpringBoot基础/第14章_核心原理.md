# 第14章_核心原理

## 1.事件和监听器

### 1.1 生命周期监听

  springboot 在 spring-boot.jar 中配置了默认的 Listener，如下：

```properties
# Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener
```

#### 1.SpringApplicationRunListener

自定义 `SpringApplicationRunListener` 来监听事件：

1. 编写 `SpringApplicationRunListener` 实现类
2. 在 `META-INF/spring.factories` 中配置 `org.springframework.boot.SpringApplicationRunListener=自己的Listener`，还可以指定一个**有参构造器**，接受两个参数 `(SpringApplication application, String[] args)`

```java
public class MySpringApplicationRunListener implements SpringApplicationRunListener {

    private SpringApplication springApplication;
    private String[] args;

    public MySpringApplicationRunListener(SpringApplication springApplication, String[] args) {
        this.springApplication = springApplication;
        this.args = args;
    }

    @Override
    public void starting(ConfigurableBootstrapContext bootstrapContext) {
        System.out.println("服务正在启动");
    }

    @Override
    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) {
        System.out.println("环境准备完成");
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println("IOC 容器准备完成");
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println("IOC 容器加载完成");
    }

    @Override
    public void started(ConfigurableApplicationContext context, Duration timeTaken) {
        System.out.println("启动完成");
    }

    @Override
    public void ready(ConfigurableApplicationContext context, Duration timeTaken) {
        System.out.println("准备就绪");
    }

    @Override
    public void failed(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println("启动失败");
    }
}
```

之后在 resources 下新建 `META-INF/spring.factories` 文件并声明以下配置：

```properties
org.springframework.boot.SpringApplicationRunListener=com.example.demo.MySpringApplicationRunListener
```

#### 2.流程

主要流程定义在 `SpringApplication` 的 `run()` 方法中。

<img src="img/第14章_核心原理/image-20240303211414591.png" alt="image-20240303211414591" style="zoom:67%;" />

1. 引导： 利用 `BootstrapContext` 引导整个项目启动

   - `starting`：`SpringApplication` 的 `run` 方法调用后会先创建 `bootstrapContext`，从 `spring.factories` 中读取并加载 `SpringApplicationRunListeners`，然后发布【开始】事件

    * `environmentPrepared`：环境准备好后（把启动参数等绑定到环境变量中）会发布【环境准备完成事件】，此时 IOC 还没有创建

2. 启动：

    * `contextPrepared`：IOC 容器创建并准备好，但是 `sources`（主配置类）还没加载时发布【IOC 容器准备完成事件】；发布后会关闭 `bootstrapContext`，此时组件都还没创建（调用 IOC 容器的 `refresh` 方法之前）

    * `contextLoaded`：【IOC 容器加载完成事件】，IOC 容器依然还没刷新

    * `started`：IOC 容器刷新了（加载了所有 `Bean`），但是 `runner` 还没调用

    * `ready`：IOC 容器刷新了并且所有 `runner` 调用完成

3. 运行：以上所有步骤都正确执行，代表容器处于 `running`

### 1.2 事件触发时机

#### 1.回调监听器

##### 1.1 BootstrapRegistryInitializer

在构造 `SpringApplication` 时加载所有初始化器，在创建 `bootstrapContext` 时执行该实现方法。

**加载方式**

- 通过 `META-INF/spring.factories` 加载

- ```java
  SpringApplication springApplication = new SpringApplication(MainApplication.class);
  springApplication.addBootstrapRegistryInitializer(...);
  ```

场景：进行密钥校对授权。

##### 1.2 ApplicationContextInitializer

在构造 `SpringApplication` 时加载所有初始化器。

**加载方式**

- 通过 `META-INF/spring.factories` 加载

- ```java
  SpringApplication springApplication = new SpringApplication(MainApplication.class);
  springApplication.addInitializers(...);
  ```

##### 1.3 ApplicationListener

基于事件机制感知事件，只要容器中有相关事件（启动时发布的和运行时发布的事件）的发布，就能监听到该事件。在构造 `SpringApplication` 时加载监听器。

**加载方式**

- `@Bean`

  ```java
  @Component
  public class MyApplicationListener implements ApplicationListener {
      @Override
      public void onApplicationEvent(ApplicationEvent event) {
          System.out.println("reveived event:" + event.getSource());
      }
  }
  ```

- `@EventListener`

  底层调用【`SmartInitializingSingleton` 的 `afterSingletonsInstantiated()`】时，由 `EventListenerMethodProcessor` 来解析方法并创建 `applicationListener` 对象。

  ```java
  @Service
  public class UserService {
      
      @EventListener(classes = {ApplicationEvent.class})
      public void listen(ApplicationEvent event) {
          System.out.println("userService 监听：" + event);
      }
      
  }
  ```

- ```java
  SpringApplication springApplication = new SpringApplication(MainApplication.class);
  springApplication.addListeners(...);
  ```

- `META-INF/spring.factories`

**常见的默认事件**

- `ContextRefreshedEvent`：容器刷新完成（所有 Bean 都完全创建）会发布这个事件
- `ContextClosedEvent`：关闭容器会发布这个事件

##### 1.4 SpringApplicationRunListener

感知全阶段生命周期 + 各种阶段都能自定义操作；通过 `META-INF/spring.factories` 指定加载。

##### 1.5 ApplicationRunner

通过 `@Bean` 加载。

```java
@Order(2)
@Component
public class MyApplicationRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) {
        System.out.println("ApplicationArguments");
    }

}
```

##### 1.6 CommandLineRunner

通过 `@Bean` 加载。

```java
@Order(2) // 数字越大优先级越高
@Component
public class MyCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("String");
    }
}
```

最佳实战：

- 如果项目启动前做事： `BootstrapRegistryInitializer` 和 `ApplicationContextInitializer`
- 如果想要在项目启动完成后做事：`ApplicationRunner` 和 `CommandLineRunner`
- 如果要干涉生命周期做事：`SpringApplicationRunListener`
- 如果想要用事件机制：`ApplicationListener`

#### 2.触发流程

<img src="img/第14章_核心原理/image-20240303222457134.png" alt="image-20240303222457134" style="zoom:67%;" />

9 大事件触发顺序和时机：

1. `ApplicationStartingEvent`：应用启动但未做任何事情
2. `ApplicationEnvironmentPreparedEvent`：Environment 准备好，但 context 未创建
3. `ApplicationContextInitializedEvent`：ApplicationContext 准备好，ApplicationContextInitializers 调用，但是任何 bean 未加载
4. `ApplicationPreparedEvent`： 容器刷新之前，bean 定义信息加载
5. `ApplicationStartedEvent`： 容器刷新完成， runner 未调用

之后就开始插入了探针机制配合 K8S：

6. `AvailabilityChangeEvent`： `LivenessState.CORRECT` 应用存活， **存活探针**
7. `ApplicationReadyEvent`: 任何 runner 被调用
8. `AvailabilityChangeEvent`：`ReadinessState.ACCEPTING_TRAFFIC` **就绪探针**，可以接请求
9. `ApplicationFailedEvent `：启动出错

#### 3.事件驱动开发

可以感知应用启动过程生命周期事件（9 大事件）和应用运行中事件（无数种）。

- 事件发布：`ApplicationEventPublisherAware` 或注入 `ApplicationEventMulticaster`
- 事件监听：组件 + `@EventListener`

**事件发布者**

```java
@Service
public class EventPublisher implements ApplicationEventPublisherAware {

    /**
     * 底层发送事件用的组件
     */
    ApplicationEventPublisher applicationEventPublisher;

    /**
     * 所有事件都可以发
     * @param event
     */
    public void sendEvent(ApplicationEvent event) {
        //调用底层 API 发送事件
        applicationEventPublisher.publishEvent(event);
    }

    /**
     * SpringBoot 会通过 ApplicationContextAwareProcessor 接口自动注入给我们
     */
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }
}
```

**事件订阅者**

两种写法：

**（1）实现 ApplicationListener 接口**

```java
@Service
public class CouponService implements ApplicationListener<LoginSuccessEvent> {
    @Override
    public void onApplicationEvent(LoginSuccessEvent event) {
        System.out.println("===== CouponService ====感知到事件"+loginSuccessEvent);
        UserEntity source = (UserEntity) loginSuccessEvent.getSource();
        sendCoupon(source.getUsername());
    }
    
    public void sendCoupon(String username){
        System.out.println(username + " 随机得到了一张优惠券");
    }
}
```

**（2）使用 @EventListener 注解**

```java
@Service
public class CouponService {

    @Order(1)
    @EventListener
    public void onEvent(LoginSuccessEvent loginSuccessEvent){
        System.out.println("===== CouponService ====感知到事件"+loginSuccessEvent);
        UserEntity source = (UserEntity) loginSuccessEvent.getSource();
        sendCoupon(source.getUsername());
    }

    public void sendCoupon(String username){
        System.out.println(username + " 随机得到了一张优惠券");
    }
}
```