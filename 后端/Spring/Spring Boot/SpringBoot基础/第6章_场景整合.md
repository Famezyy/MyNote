# 第6章_场景整合

## 1.SQL

### 1.1 数据源的自动配置

导入JDBC场景

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
```

导入数据库驱动

```xml
<dependency>
	<groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

修改配置项

```yaml
spring:
	datasource:
		driver-class-name: com.mysql.cj.jdbc.Driver
		url: jdbc:mysql//localhost:3306/db_name
		username: root
		password: 123456
```

测试

```java
jdbcTemplate.queryForObject("select * from account");
Long aLong = jdbcTemplate.queryForObject("select count(*) from account", Long.class);
```

原理

`DataSourceAutoConfiguration`：数据源的自动配置

- 修改数据源相关的配置：`spring.datasource`

- 底层配置好的连接池：`HikariDataSource`，只有当容器中没有连接池时才会注册

  ```java
  @Configuration(proxyBeanMethods = false)
  @EnableConfigurationProperties(DataSourceProperties.class)
  public class DataSourceAutoConfiguration {
      @Configuration(proxyBeanMethods = false)
  	@Conditional(PooledDataSourceCondition.class)
  	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
  	@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
  			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,
  			DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })
  	protected static class PooledDataSourceConfiguration {
  
  	}
  }
  ```

`DataSourceTransactionManagerAutoConfiguration`：事务管理器的自动配置

`JdbcTemplateAutoConfiguration`：JdbcTemplate 的自动配置，通过导入 JdbcTemplateConfiguration 注册了 JdbcTemplate 组件

- 修改 JdbcTemplate 的相关配置：`spring.jdbc`（设置 queryTimeout 等）

`JndiDataSourceAutoConfiguration`：jndi 的自动配置

`XADataSourceAutoConfiguration`：分布式事务相关的自动配置

### 1.2 使用Druid数据源

#### 1.自定义整合

导入 alibaba 的 druid 数据源

```xml
<dependency>
	<groupId>com.alibaba</groupId>
    <aritifactId>druid</aritifactId>
</dependency>
```

配置数据源

```yaml
spring:
	datasource:
		url: jdbc:mysql//localhost:3306/db_name
		username: root
		password: 123456
```

注册数据源

```java
@ConfigurationProperties("spring.datasource")
public DataSource dataSource() {
    return new DruidDataSource();
}
```

**StatViewServlet**

提供监控信息展示的 html 页面，提供监控信息的 JSON API。

导入组件

```java
@Configuration
public class MyDataSourceConfig {
    @Bean
    public ServletRegistrationBean<StatViewServlet> statViewServlet() {
        StatViewServlet statViewServlet = new StatViewServlet();
        ServletRegistrationBean<StatViewServlet> servletRegistrationBean = new ServletRegistrationBean<>(statViewServlet, "/druid/*");
        servletRegistrationBean.addInitParameter("loginUsername", "admin");
        servletRegistrationBean.addInitParameter("loginPassword", "123456");
        // 是否允许清空统计数据
        servletRegistrationBean.addInitParameter("resetEnable", true);
        return servletRegistrationBean;
    }
}
```

**StatFilter**

用于统计监控信息，如 SQL 监控，URI 监控。

导入组件

```java
@Bean
public DataSource dataSource() {
    DruidDataSource druidDataSource = new DruidDataSource();
    // 可以设置多个 filter
    druidDataSource.setFilters("stat,slf4j");
    return druidDataSource;
}
```

> **所有的Filter**
>
> | 别名          | Filter类名                                              |
> | ------------- | ------------------------------------------------------- |
> | default       | com.alibaba.druid.filter.stat.StatFilter                |
> | stat          | com.alibaba.druid.filter.stat.StatFilter                |
> | mergeStat     | com.alibaba.druid.filter.stat.MergeStatFilter           |
> | encoding      | com.alibaba.druid.filter.encoding.EncodingConvertFilter |
> | log4j         | com.alibaba.druid.filter.logging.Log4jFilter            |
> | log4j2        | com.alibaba.druid.filter.logging.Log4j2Filter           |
> | slf4j         | com.alibaba.druid.filter.logging.Slf4jLogFilter         |
> | commonlogging | com.alibaba.druid.filter.logging.CommonsLogFilter       |
>
> **慢SQL记录配置**
>
> ```java
> @Bean
> public StatFilter statFilter() {
>     StatFilter statFilter = new StatFilter();
>     statFilter.setSlowSqlMillis(10000);
>     statFilter.setLogSlowSql(true);
> }
> ```

#### 2.使用官方starter

导入依赖

```xml
<dependency>
	<groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
</dependency>
```

配置

- 配置项：`spring.datasource.druid`
- `DruidSpringAopConfiguration`：监控 SpringBean 的配置项，`spring.datasource.druid.aop-petterns`
- `DruidStatViewServletConfiguration`：监控页的配置，`spring.datasource.druid.stat-view-servlet`
- `DruidWebStatFilterConfiguration`：web 监控配置，`spring.datasource.druid.web-stat-filter`
- `DruidFilterConfiguration`：Druid 的 filter 的配置

例：

```yaml
spring:
	datasource:
		url: jdbc:mysql://localhost:3306/db_name
		username: root
		password: 123456
		driver-class-name: com.mysql.jdbc.Driver
	druid:
		aop-patterns: com.youyi.zhao.*
		filters: stat, wall # stat: sql 监控；wall：防火墙
		
		stat-view-servlet: # 配置监控页
			enabled: true
			login-username: admin
			login-password: admin
			resetEnable: false
		
		web-stat-filter: # 监控 web
			enabled: true
            urlPattern: /*
            exclusions: '*.js,*.gif,*.jpg,*.css,*.ico,/druid/*'
            
        filter:
        	stat:
        		slow-sql-millis: 1000
        		logSlowSql: true
        		enabled: true
        	wall:
        		enabled: true
        		config:
        			drop-table-allow: false
```

### 1.3 整合MyBatis操作

#### 1.实践

**引入依赖**

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```

**配置数据源**

```properties
spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=123456
```

**配置MyBatis**

```properties
# 指定 mapper 映射文件位置
mybatis.mapper-locations=classpath:/mapper/*.xml
# 打开驼峰命名规则
mybatis.configuration.map-underscore-to-camel-case=true
# 全局配置文件
# mybatis.config-location: classpath:mybatis/mybatis-config.xml
```

**全局配置文件（不推荐）**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<settings>
        <!-- 开启驼峰命名规则 -->
    	<setting name="mapUnderscoreToCamelCase", value="true" />
    </settings>
</configuration>
```

**编写 mapper 接口**

可以标注 `@Mapper` 注解或者在配置类上使用 `@MapperScan(basePackages="com.youy.zhao")` 指定 Mapper 类的存放包名。

```java
@Mapper
public interface AccountMapper {
    public Account getAccount(@Param("id") Long id);
}
```

**编写 sql 映射文件**

安装 `MyBatisX` 插件，可以帮我们生成 `Mapper` 接口的 xml 文件。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youyi.zhao.mapper.AccountMapper">
	<select id="getAccount" resultType="com.youyi.zhao.bean.Account">
    	select * from account_tbl where id = #{id}
    </select>
</mapper>
```

#### 2.SQL注入方式

**（1）注解方式（不推荐）**

```java
@Mapper
public interface AccountMapper {
    @Select("select * from account_tbl where id = #{id}")
    public Account getAccount(Long id);
}
```

**（2）混合模式**

```java
@Mapper
public interface AccountMapper {
    @Select("select * from account_tbl where id = #{id}")
    public Account getAccount(Long id);
    // @Insert("insert into city(name, state, country) values(#{name}, #{state}, #{country})")
    // Options(useGeneratedKeys=true keyProperty="id")
    public void insert(City city);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youyi.zhao.mapper.AccountMapper">
	<select id="insert" useGeneratedKeys="true" keyProperty="id">
    	insert into city(name, state, country) values(#{name}, #{state}, #{country})
    </select>
</mapper>
```

#### 3.自动配置原理

- `mybatis-spring-boot-starter` 后会自动导入 `spring-boot-starter-jdbc`，用来操作数据库

  会通过自动配置文件导入以下配置类：

  - `org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`

    数据源的自动配置，所有和数据源有关的配置都绑定在 `DataSourceProperties` 中，默认使用 `hikari` 的数据源。

  - `org.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfiguration`

    给容器中放入了 `JdbcClient` 用来操作数据库。

  - `org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration`

    给容器中放入了 `JdbcTemplate` 用来操作数据库。

  - `org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration`

  - `org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration`

    支持基于 XA 二阶段提交的分布式事务，需要导入事务场景依赖。

  - `org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration`

    支持事务。

- `mybatis-spring-boot-starter` 还会导入 `mybatis-spring-boot-autoConfigure`

  会通过自动配置文件导入以下配置类：

  - `org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration`

  - `org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration`

    ```java
    @Configuration
    @ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})
    @ConditionalOnSingleCandidate(DataSource.class)
    @EnableConfigurationProperties({MybatisProperties.class})
    @AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class})
    public class MybatisAutoConfiguration implements InitializingBean {
    ```

    - mybatis 的所有配置绑定在 `MybatisProperties`，在数据源配置好后才开始配置

    - 会给容器中放入 `SqlSessionFactory` 用来创建会话、`SqlSessionTemplate` 用来操作数据库

### 1.4 动态配置多数据源

**添加依赖**

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.3</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>2.7.5</version>
</dependency>
```

底层核心组件是抽象类`AbstractRoutingDataSource`，他有一个成员 map 变量`resolvedDataSources`，根据不同的 key，配置不同的数据源。所以我们要做的就是实现这个类，重写`determineCurrentLookupKey()`方法。

```java
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getKey();
    }
}

/**
 * 辅助类，用于存储上下文信息，线程安全
 */
public class DataSourceContextHolder {

    public static ThreadLocal<String> key = new ThreadLocal<>();

    public static void setKey(String key) {
        key.set(key);
    }

    public static String getKey() {
        return key.get();
    }

    public static void clearKey() {
        key.remove();
    }
}
```

**配置类**

```java
@Configuration
public class DataSourceConfig {

    /**
     *配置数据源1
     */
    @ConfigurationProperties("datasource1")
    @Bean
    public DataSource dataSource1() {
        return DataSourceBuilder.create().build();
    }

    /**
     *配置数据源2
     */
    @ConfigurationProperties("datasource2")
    @Bean
    public DataSource dataSource2() {
        return DataSourceBuilder.create().build();
    }

    /**
     *配置 dynamicDataSource，设置数据源的 key 和 value，以及默认的数据源
     */
    @Bean
    public DynamicDataSource dynamicDataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("datasource1", dataSource1());
        targetDataSources.put("datasource2", dataSource2());

        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(targetDataSources);
        dynamicDataSource.setDefaultTargetDataSource(dataSource1());
        return dynamicDataSource;
    }

    /**
     * 配置 sqlSessionFactoryBean 的数据源
     */
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();

        /** 设置 mybatis configuration 扫描路径，同时必须在配置类上添加@MapperScan注解 */
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath:mapper/*.xml"));

        /** 设置数据源 */
        sqlSessionFactoryBean.setDataSource(dynamicDataSource());

        return sqlSessionFactoryBean;
    }

    /**
     * 配置事务下的数据源
     */
    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dynamicDataSource());
    }
}
```

**注解**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface UsingDataSource {

    String value() default "";
}
```

**切面类**

```java
@Aspect
@Component
public class DataSourceAspect {

    @Pointcut("@annotation(com.example.demo.config.UsingDataSource)")
    public void checkPointCut(){}

    @Before("checkPointCut()")
    public void checkBefore(JoinPoint joinPoint) {
        UsingDataSource usingDataSource = ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(UsingDataSource.class);
        String dataSourceKey = usingDataSource.value();
        DataSourceContextHolder.setKey(dataSourceKey);
    }

    @After("checkPointCut()")
    public void checkAfter() {
        DataSourceContextHolder.clearKey();
    }
}
```

**mapper**

```java
@Mapper
public interface UserMapper {
    @UsingDataSource("datasource1")
    public User getById(int id);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.demo.dao.UserMapper">
    <select id="getById" resultType="com.example.demo.model.User">
        select * from user where userId = #{id}
    </select>
</mapper>
```

**配置文件**

```properties
datasource1.username=root
datasource1.password=root
datasource1.jdbcUrl=jdbc:mysql://localhost:3306/datasource1?allowPublicKeyRetrieval=true
datasource1.driverClassName=com.mysql.jdbc.Driver

datasource2.username=root
datasource2.password=root
datasource2.jdbcUrl=jdbc:mysql://localhost:3306/datasource2?allowPublicKeyRetrieval=true
datasource2.driverClassName=com.mysql.jdbc.Driver
```

**入口类**

```java
/** 配出数据源的自动配置类 */
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
/** 手动指定 mapper.class 路径 */
@MapperScan(basePackages = "com.example.demo.dao")
/** 开启 aspectJ */
@EnableAspectJAutoProxy
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
```

## 2.NoSQL

- springboot 2.x 后 ，原来默认使用的 Jedis 被 lettuce 替换，配置文件中的配置注意使用 lettuce
- jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用 jedis pool 连接池！更像 BIO 模式
- lettuce：采用 netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式

### 2.1 入门

引入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

**配置**

```yaml
spring:
	data:
		redis:
            host: 150.158.27.170
            port: 6379 # 默认 6379
            database: 0 # 数据库索引，默认为 0
            connect-timeout: 100000 # 连接超时时间（毫秒）
            lettuce:
              pool:
                max-active: 20 # 连接池最大连接数，使用负值表示没有限制
                max-wait: -1 # 最大阻塞时间，负数表示没有限制
                max-idle: 5 # 连接池中最大空闲连接
                min-idle: 0 # 最小空闲连接
            password: #
```

**切换至 Jedis**

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<dependency>
	<groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
```

```yaml
spring:
	redis:
		host:
		port: 6379
		password:
		client-type: jedis
		jedis:
			pool:
				max-act: 10
```

**例子**

```java
// 这就是之前 RedisAutoConfiguration 源码中的 Bean
@Autowired
private RedisTemplate redisTemplate;
@Test
void testRedis() {
    /** redisTemplate 操作不同的数据类型，API 和 Redis 中的是一样的
         * opsForValue 类似于 Redis 中的 String
         * opsForList 类似于 Redis 中的 List
         * opsForSet 类似于 Redis 中的 Set
         * opsForHash 类似于 Redis 中的 Hash
         * opsForZSet 类似于 Redis 中的 ZSet
         * opsForGeo 类似于 Redis 中的 Geospatial
         * opsForHyperLogLog 类似于 Redis 中的 HyperLogLog
     */
    // 除了基本的操作，常用的命令都可以直接通过 redisTemplate.xxxx 操作，比如事务、基本的CRUD……

    // 和数据库相关的操作都需要通过连接操作
    //获取Redis的连接对象
    //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
    //connection.flushDb();

    redisTemplate.opsForValue().set("key", "key");
    System.out.println(redisTemplate.opsForValue().get("key"));
}
```

> **补充**
>
> `redisTemplate` 提供了 `multiXXX` 方法用于一次执行多个相同的任务。对于一次执行不同的任务的需求则可以使用 `pipeline`：
>
> ```java
> List<Object> result = redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
>              Boolean set = connection.stringCommands().set("a".getBytes(), "b".getBytes());
>              byte[] get = connection.stringCommands().get("c".getBytes());
>              Long incr = connection.stringCommands().incr("d".getBytes());
>              return Arrays.asList(set, get, incr);
>          });
> ```

### 2.2 Cacheable

也可以使用 `@Cacheable` 注解，需要开启 `@EnableCaching`：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!-- 缓存依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

**编写配置类**

```java
@Configuration
@EnableCaching
public class RedisCacheConfig extends CachingConfigurerSupport {

    // 自定义key生成器
    @Bean
    public KeyGenerator keyGenerator(){
        return (o, method, params) ->{
            StringBuilder sb = new StringBuilder();
            sb.append(o.getClass().getName()); // 类
            sb.append(method.getName()); // 方法名
            sb.append("(");
            for(Object param: params){
                sb.append(param.toString()).append(","); // 参数名
            }
            sb.append(")");
            return sb.toString();
        };
    }

    // 配置缓存管理器
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(60000000)) // 60s 缓存失效
                // 设置 key 的序列化方式
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))
                // 设置 value 的序列化方式
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))
                // 不缓存 null 值
                .disableCachingNullValues();
        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .transactionAware()
                .build();
        return redisCacheManager;
    }


    // key键序列化方式
    private RedisSerializer<String> keySerializer() {
        return new StringRedisSerializer();
    }

    // value值序列化方式
    private GenericJackson2JsonRedisSerializer valueSerializer(){
        return new GenericJackson2JsonRedisSerializer();
    }
}
```

使用

```java
@Override
@Cacheable(cacheNames = "user" ,key="#id")
public User selectByPrimaryKey(Integer id){
    return  usermapper.selectByPrimaryKey(id);
}

@Override
@Cacheable(cacheNames = "users")
public List<User> getAll(){
    return usermapper.getAll();
}
```

> **注意**
>
> `RedisTemplate` 用于自己调用缓存处理，`CacheManager` 用于交给 springcache 管理缓存处理。

### 2.3 Repository

在实体类中添加 `@RedisHash` 注解，并在主键上添加 `@Id` 注解。

```java
@Data
@NoArgsConstructor
@RedisHash("Student")
public class Student implements Serializable {
    
    @Id
    private String id;
    private String name;
}
```

继承 `CrudRepository` 接口

```java
public interface StudentRepository extends CrudRepository<Student, String> {}
```

使用

```java
Student student = new Student("1", "zhang3");
studentRepository.save(student);
Student student = studentRepository.findById("1").get();
studentRepository.deleteById("1");
```

需要自定义操作逻辑时可以**按照规定的命名规则**定义方法：

```java
public interface StudentRepository extends CrudRepository<Student, String>  {
    // 表示按照 name 进行查找
    List<Student> findByName(String name);
}
```

或者可以继承 `QueryByExampleExecutor` 自定义条件生成器。

### 2.4 自定义RedisTemplate模板

#### 1.为什么要序列化？

**测试一，使用 JSON 序列化 value**

- 新建User类，先不要序列化

  ```java
  @Component
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  public class User{
      private String name;
      private int age;
  }
  ```

- Redis 中存入 user 对象

  ```java
  @Test
  void testRedis() {
      // 使用 JSON 序列化
    	// 或者可以直接让 User 类继承 Serializable 接口，可以不用 mapper 序列化，此时使用 JDK 默认的序列化方式
      String user = new ObjectMapper().writeValueAsString(new User("zhao", 123));
      redisTemplate.opsForValue().set("user", user);
      System.out.println(redisTemplate.opsForValue().get("user"));
  }
  ```

- 结果

  - idea 控制台输出：User(name=zhao, age=123)
  - Linux 中 redis 控制台显示乱码："\xac\xed\x00\x05t\x00\x04user"

**测试二，redis直接存储对象**（对象没有实现 Serializable 接口）

```java
@Test
public void test() {
    User user = new User("zhao", 123);
    redisTemplate.opsForValue().set("user",user);
    System.out.println(redisTemplate.opsForValue().get("user"));
}
```

测试结果报错。

#### 2.如何序列化

- 自定义 RedisTemplate，在定义的 redisTemplate 设置序列化

  ```java
  @Configuration
  public class RedisConfig extends CachingConfigurerSupport {
      /**
       * 配置Jackson2JsonRedisSerializer序列化策略
       * */
      private Jackson2JsonRedisSerializer<Object> jsonSerializer() {
          ObjectMapper objectMapper = new ObjectMapper();
  
          // 指定要序列化的域，field、get 和 set 及修饰符范围，ANY是都有包括 private 和 public
          objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
  
          // 不序列化 null 值
          objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
  
          // 指定序列化输入的类型，类必须是非 final 修饰的，final 修饰的类，比如 String, Integer 等会抛出异常，不指定则可以序列化 final 类型
          // 且不做任何验证，允许所有子类型
          // 不添加该语句则会反序列化为 LinkedHashMap
          objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
  
          return new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);
      }
  
      public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
          RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
          redisTemplate.setConnectionFactory(redisConnectionFactory);
          StringRedisSerializer stringSerializer = new StringRedisSerializer();
          // 这次使用 GenericJackson2JsonRedisSerializer
          GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();
          redisTemplate.setKeySerializer(stringSerializer);
          redisTemplate.setHashKeySerializer(stringSerializer);
          redisTemplate.setValueSerializer(jsonSerializer);
          redisTemplate.setHashValueSerializer(jsonSerializer);
          // 初始化所有其他属性
          redisTemplate.afterPropertiesSet();
          return redisTemplate;
      }
  }
  ```

  > **注意**
  >
  > RedisTemplate 默认的系列化类是 `JdkSerializationRedisSerializer`，但是被序列化的对象必须实现 `Serializable` 接口。在存储内容时，除了属性的内容外还存了其它内容在里面，总长度长，且不容易阅读。`Jackson2JsonRedisSerializer` 和 `GenericJackson2JsonRedisSerializer` 两者都会序列化成 json，但是后者会在 json 中加入 `@class` 属性，类的全路径包名，支持反序列化，前者必须添加 `defaultTyping`。

- 继续测试

  ```java
  @Test
  void testRedis() {
      redisTemplate.opsForValue().set("user", new User("zhao", 123));
      System.out.println(redisTemplate.opsForValue().get("user")); // User(name=zhao, age=123)
  }
  ```

  ```
  127.0.0.1:6379> keys *
  "user"
  127.0.0.1:6379> get user
  "[\"com.example.redis_springboot.entity.User\",{\"name\":\"zhao\",\"age\":123}]"
  ```

### 3.自动配置分析

```java
/**
* spring-boot-autoconfigure-2.6.2.jar -> spring.factories 中定义了所有需要加载的 autoconfiguration
**/
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({RedisOperations.class})
@EnableConfigurationProperties({RedisProperties.class})
@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})
public class RedisAutoConfiguration {
    public RedisAutoConfiguration() {
    }

    @Bean
    @ConditionalOnMissingBean(name = {"redisTemplate"}) // 可以定制 redisTemplate
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        // 默认的 redisTemplate 没有过多的设置，两个类型都是 object，可以定制 String 类型
        RedisTemplate<Object, Object> template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    // String 是最常使用的类型，所以单独提出来了
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        return new StringRedisTemplate(redisConnectionFactory);
    }
}
```

1. `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 中导入了`RedisAutoConfiguration`、`RedisReactiveAutoConfiguration` 和 `RedisRepositoriesAutoConfiguration`。所有属性绑定在 `RedisProperties` 中
2. `RedisReactiveAutoConfiguration` 属于响应式编程，RedisRepositoriesAutoConfiguration` 属于 JPA 操作
3. `RedisAutoConfiguration` 配置了以下组件：
   - `LettuceConnectionConfiguration`： 给容器中注入了连接工厂 `LettuceConnectionFactory`，和操作 redis 的客户端 `DefaultClientResources`
   - `RedisTemplate<Object, Object>`： 可给 redis 中存储任意对象，会使用 jdk 默认序列化方式
   - `StringRedisTemplate`： 给 redis 中存储字符串，如果要存对象，需要开发人员自己进行序列化。key-value都是字符串进行操作

## 3.Swagger

### 3.1 简介

Swagger 可以快速生成**实时接口**文档，方便前后开发人员进行协调沟通。遵循 **OpenAPI** 规范。

### 3.2 SpringBoot 集成 Swagger

**导入依赖**

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.1.0</version>
</dependency>
```

访问 http://localhost:8080/swagger-ui.html

### 3.3 配置 Swagger

配置分组筛选条件，可以在页面上筛选出【查询】和【插入】的所有 API。

```java
@Bean
public GroupedOpenApi searchApi() {
    return GroupedOpenApi.builder()
        .group("查询")
        .pathsToMatch("/search/**")
        .build();
}
@Bean
public GroupedOpenApi insertApi() {
    return GroupedOpenApi.builder()
        .group("插入")
        .pathsToMatch("/insert/**", "/inserts/**")
        .addOpenApiMethodFilter(method -> method.isAnnotationPresent(PostMapping.class))
        .build();
}
```

配置页面显示信息

```java
@Bean
public OpenAPI myOpenAPI() {
    return new OpenAPI()
        .info(new Info().title("my API")
              .description("sample application")
              .version("v0.0.1")
              .license(new License().name("Apache 2.0").url("http://youyi.zhao.com")))
        .externalDocs(new ExternalDocumentation()
                      .description("SpringShop Wiki Documentation")
                      .url("https://org.youyi.zhao"));
}
```

### 3.4 接口注释

| 注解           | 标注位置            | 作用                   |
| -------------- | ------------------- | ---------------------- |
| `@Tag`         | `Controller` 类     | 标识 `Controller` 作用 |
| `@Parameter`   | 参数                | 标识参数作用           |
| `@Parameters`  | 参数                | 参数多重说明           |
| `@Schema`      | model 层的 JavaBean | 描述模型作用及每个属性 |
| `@Operation`   | 方法                | 描述方法作用           |
| `@ApiResponse` | 方法                | 描述响应状态码等       |

```java
@RestController
@Tag(name="访问", description = "访问次数管理")
public class RedisTestController {

    @Autowired
    StringRedisTemplate redisTemplate;

    @GetMapping("/count")
    @Operation(summary = "查询", description = "返回访问次数")
    public Model count(@Parameter(description = "model") Model model) {
        final Long hello = redisTemplate.opsForValue().increment("hello");
        return new Model(hello);
    }
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Schema(title = "model")
public class Model {
    @Schema(title = "次数")
    private long count;

    @Override
    public String toString() {
        return "访问了" + count + "次";
    }
}
```

### 3.5 根据Swagger生成Model

导入以下依赖和 plugin

```xml
<dependencies>
	<dependency>
        <groupId>io.swagger.core.v3</groupId>
        <artifactId>swagger-annotations</artifactId>
        <version>2.2.19</version>
    </dependency>
    <dependency>
        <groupId>org.openapitools</groupId>
        <artifactId>jackson-databind-nullable</artifactId>
        <version>0.2.6</version>
    </dependency>
    <dependency>
        <groupId>javax.validation</groupId>
        <artifactId>validation-api</artifactId>
        <version>2.0.1.Final</version>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.openapitools</groupId>
            <artifactId>openapi-generator-maven-plugin</artifactId>
            <version>7.2.0</version>
            <executions>
                <execution>
                    <id>api-call-jal-jmbSwagger</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <inputSpec>${basedir}/src/main/resources/swagger.yaml</inputSpec>
                        <generatorName>spring</generatorName>
                        <addCompileSourceRoot>false</addCompileSourceRoot>
                        <configOptions>
                            <sourceFolder>src/main/java</sourceFolder>
                            <!-- java 版本 -->
                            <dateLibrary>java17</dateLibrary>
                            <hideGenerationTimestamp>true</hideGenerationTimestamp>
                            <recursiveBeanValidation>true</recursiveBeanValidation>
                            <useBeanValidation>true</useBeanValidation>
                            <serializableModel>true</serializableModel>
                            <delegatePattern>true</delegatePattern>
                            <interfaceOnly>true</interfaceOnly>
                            <objectMapper />
                        </configOptions>
                        <output>${project.basedir}</output>
                        <!-- 生成的 model 路径 -->
                        <modelPackage>jp.co.jal.jmb.performance.info.model.jmb</modelPackage>
                        <additionalProperties>
                            <java17>true</java17>
                            <additionalProperty>jackson=true</additionalProperty>
                        </additionalProperties>
                        <generateApis>false</generateApis>
                        <generateApiDocumentation>false</generateApiDocumentation>
                        <generateApiTests>false</generateApiTests>
                        <generateModelDocumentation>false</generateModelDocumentation>
                        <generateSupportingFiles>false</generateSupportingFiles>
                        <generateModelDocumentation>false</generateModelDocumentation>
                        <!-- 是否跳过 -->
                        <skip>false</skip>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

## 4.远程调用

### 4.1 RestTemplate

#### 1.exchange

```java
@EnableConfigurationProperties(NasToolsApiProperties.class)
@Configuration
public class NasToolsApiConfig {

    @Bean
    public ObjectMapper objectMapper() {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
        builder.modules(new JavaTimeModule())
                .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, SerializationFeature.WRITE_DATES_WITH_CONTEXT_TIME_ZONE, SerializationFeature.FAIL_ON_EMPTY_BEANS)
                .serializationInclusion(JsonInclude.Include.NON_NULL);
        return builder.build();
    }

    @Bean
    public RestTemplate restTemplate() {
        RestTemplateBuilder restTemplateBuilder = new RestTemplateBuilder();
        // 将 ObjectMapper 注入进 restTemplate
        restTemplateBuilder.messageConverters(new MappingJackson2HttpMessageConverter(objectMapper()));
        return restTemplateBuilder.build();
    }
}
```

```java
@Autowired
NasToolsApiProperties nasToolsApiProperties;

@Autowired
// 只是组合了 ObjectMapper 并捕获 JsonParse 异常
NasToolsMapper nasToolsMapper;

public <T> T getNasToolsResponse(String endpoint, MultiValueMap<String, String> queryMap, Object requestBody, HttpHeaders httpHeaders, HttpMethod httpMethod, Class<T> responseClass) throws NasToolsException {
    RestTemplate restTemplate = new RestTemplate();
    HttpEntity<?> requestWithHeaders = new HttpEntity<>(null, httpHeaders);

    UriComponentsBuilder builder = UriComponentsBuilder.newInstance()
            .scheme(nasToolsApiProperties.getScheme())
            .host(nasToolsApiProperties.getHost())
            .port(nasToolsApiProperties.getPort()).path(endpoint);
    
    if (HttpMethod.GET.equals(httpMethod)) {
        builder.queryParams(queryMap);
    }
    try {
        if (HttpMethod.POST.equals(httpMethod)) {
            requestWithHeaders = new HttpEntity<>(nasToolsMapper.writeValueAsString(requestBody), httpHeaders);
            // 如果是 application/x-www-form-urlencoded 形式
            // requestWithHeaders = new HttpEntity<>(queryMap, httpHeaders);
        }
        RI uri = builder.build().toUri();
        // 会调用注入的 ObjectMapper
        ResponseEntity<T> response = restTemplate.exchange(uri, httpMethod, requestWithHeaders, responseClass);
        return response.getBody();
    } catch (HttpClientErrorException e) {
        // 返回错误代码时进入 HttpClientErrorException 这里
        NasToolsException.ErrorCode externalCallErrorResponse = NasToolsException.ErrorCode.EXTERNAL_CALL_ERROR_RESPONSE;
        // 会调用注入的 ObjectMapper
        externalCallErrorResponse.setErrorObject(e.getResponseBodyAs(ErrorMessage.class));
        throw new NasToolsException(externalCallErrorResponse, e);
    } catch (Exception e) {
        throw new NasToolsException(NasToolsException.ErrorCode.EXTERNAL_CALL_ERROR_RESPONSE, e);
    }
}
```

设置超时时间

```java
HttpCpmponentsClientHttpRequestFactory requestFactory = new HttpCpmponentsClientHttpRequestFactory();
requestFactory.setReadTimeOut(READ_TIME_OUT);
requestFactory.setConnectTimeOut(CONNECTION_TIME_OUT);
RestTemplate restTemplate = new RestTemplate(requestFactory);
```

> 观察实现方法对比`HttpCpmponentsClientHttpRequestFactory`和`SimpleClientHttpRequestFactory`，前者是用连接池管理数据库的链接，后者是每次调用`restTemplate`时都要打开一个链接，然后关闭，性能稍差一些。

#### 2.postForObject

```java
Map<String, Integer> map = new HashMap<>();
map.put("productId", order.getProductId());
String s = restTemplate.postForObject("http://localhost:8081/stock?productId={productId}", null, String.class, map);
```

#### 3.实现SSL访问

```java
KeyStore keyStore = KeyStore.getInstance("jks");
keyStore.load(getClass().getResourceAsStream(env.getProperties("证书地址")), env.getProperties("密码").toCharArray());
TrustManagerFactory tmf = TrustManagerFactory.getInstance("sunx509");
tmf.init(keyStore);
SSLContext context = SSLContext.getInstance("TLS");
context.init(null, tmf.getTrustManagers(), null);
SSLConnectionSlcketFactory factory = new SSLConnectionSocketFactory(context, new DefaultHostnameVerifier());
restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create().setSSLSocketFactory(factory).build()));
```

如果你有 PEM（Privacy Enhanced Mail）格式的证书文件，可以使用 `openssl` 工具来进行转换，将 PEM 格式的证书和私钥合并为 PKCS#12 文件，然后再将其转换为 JKS 文件。

以下是从 PEM 到 JKS 的大致步骤：

**步骤 1: 合并证书和私钥到 PKCS#12 文件**

使用`openssl`工具将 PEM 格式的证书和私钥合并为 PKCS#12 文件（`.p12`或`.pfx`格式）。

```bash
bashCopy code
openssl pkcs12 -export -out keystore.p12 -inkey private-key.pem -in certificate.pem
```

这将把名为`private-key.pem`的私钥和`certificate.pem`的证书合并到`keystore.p12`文件中。根据实际情况，你可能需要提供口令（密码）来保护 PKCS#12 文件。

**步骤 2: 从 PKCS#12 转换为 JKS**

使用`keytool`工具从 PKCS#12 文件转换为 JKS 格式。

```bash
bashCopy code
keytool -importkeystore -srckeystore keystore.p12 -srcstoretype PKCS12 -destkeystore keystore.jks -deststoretype JKS
```

这个命令会要求你提供 PKCS#12 文件的密码（口令），然后为 JKS 文件设置一个密码。

这样就可以将 PEM 格式的证书和私钥转换为 Java KeyStore (JKS) 格式，使其可以在 Java 应用中使用。

### 4.2 WebClient

#### 1.入门

非阻塞、响应式客户端，需要 `webflux` 场景才可。

创建 `WebClient` 非常简单：

- `WebClient.create()`
- `WebClient.create(String baseUrl)`

还可以使用 `WebClient.builder()` 配置更多参数项：

- `uriBuilderFactory`：自定义 `UriBuilderFactory`，定义 baseurl
- `defaultUriVariables`：默认 uri 变量
- `defaultHeader`：每个请求默认头
- `defaultCookie`：每个请求默认 cookie
- `defaultRequest`：Consumer 自定义每个请求
- `filter`：过滤 client 发送的每个请求
- `exchangeStrategies`：HTTP 消息 reader/writer 自定义
- `clientConnector`：HTTP client 库设置

```java
// 创建 WebClient
WebClient client = WebClient.create("https://example.org");
// 获取 ResponseEntity 类型
Mono<ResponseEntity<Person>> result = client
    .get()
    .uri("/persons/{id}", id)
    .accept(MediaType.APPLICATION_JSON)
    .header("Authorization", "xxx")
    .retrieve()
    .toEntity(Person.class);

// 只获取 body
Mono<Person> result = client.get()
    .uri("/persons/{id}", id)
    .accept(MediaType.APPLICATION_JSON)
    .retrieve()
    .bodyToMono(Person.class);

// stream 数据
Flux<Quote> result = client
    .get()
    .uri("/quotes")
    .accept(MediaType.TEXT_EVENT_STREAM)
    .retrieve()
    .bodyToFlux(Quote.class);

//定义错误处理
Mono<Person> result = client
    .get()
    .uri("/persons/{id}", id)
    .accept(MediaType.APPLICATION_JSON)
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError, response -> ...)
    .onStatus(HttpStatus::is5xxServerError, response -> ...)
    .bodyToMono(Person.class);
```

**定义请求体**

```java
//1、响应式-单个数据
Mono<Person> personMono = ...;
Mono<Void> result = client.post()
    .uri("/persons/{id}", id)
    .contentType(MediaType.APPLICATION_JSON)
    .body(personMono, Person.class)
    .retrieve()
    .bodyToMono(Void.class);

//2、响应式-多个数据
Flux<Person> personFlux = ...;
Mono<Void> result = client.post()
    .uri("/persons/{id}", id)
    .contentType(MediaType.APPLICATION_STREAM_JSON)
    .body(personFlux, Person.class)
    .retrieve()
    .bodyToMono(Void.class);

//3、普通对象
Person person = ... ;
Mono<Void> result = client.post()
    .uri("/persons/{id}", id)
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(person)
    .retrieve()
    .bodyToMono(Void.class);
```

#### 2.HTTP Interface

Spring 允许我们通过定义接口的方式，给任意位置发送 http 请求，实现远程调用，可以用来简化 HTTP 远程访问。需要 `webflux` 场景才可。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```

**（1）定义接口**

```java
public interface BingService {

    @GetExchange(url = "/search")
    String search(@RequestParam("q") String keyword);
}
```

**（2）创建代理&测试**

```java
@SpringBootTest
class Boot05TaskApplicationTests {

    @Test
    void contextLoads() throws InterruptedException {
        //1.创建客户端
        WebClient client = WebClient.builder()
            .baseUrl("https://cn.bing.com")
            .codecs(clientCodecConfigurer -> {
                clientCodecConfigurer
                    .defaultCodecs()
                    .maxInMemorySize(256*1024*1024);
                //响应数据量太大有可能会超出 BufferSize，所以这里设置的大一点
            })
            .build();
        //2.创建工厂
        HttpServiceProxyFactory factory = HttpServiceProxyFactory
            .builder(WebClientAdapter.forClient(client)).build();
        //3.获取代理对象
        BingService bingService = factory.createClient(BingService.class);
        //4.测试调用
        Mono<String> search = bingService.search("test");
        System.out.println("==========");
        search.subscribe(str -> System.out.println(str));
    }

}
```

## 5.消息队列

### 5.1 Kafka

[参考](https://docs.spring.io/spring-kafka/docs/current/reference/html/#preface)

#### 1.导入

**依赖**

```xml
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
```

**基础配置**

```properties
spring.kafka.bootstrap-servers=xxx:9092,xxx:xxx,xxx:xxx
```

#### 2.消息发送

```java
@SpringBootTest
class Boot07KafkaApplicationTests {

    @Autowired
    KafkaTemplate kafkaTemplate;
    
    @Test
    void contextLoads() throws ExecutionException, InterruptedException {
        StopWatch watch = new StopWatch();
        watch.start();
        CompletableFuture[] futures = new CompletableFuture[10000];
        for (int i = 0; i < 10000; i++) {
            // 向 order 主题发送 key/value
            CompletableFuture send = kafkaTemplate.send("order", "order.create." + i, "订单创建了：" + i);
            futures[i]=send;
        }
        CompletableFuture.allOf(futures).join();
        watch.stop();
        System.out.println("总耗时："+watch.getTotalTimeMillis());
    }

}
```

#### 3.消息监听

```java
@Configuration
@EnableKafka
public class OrderMsgListener {

    @KafkaListener(topics = "order", groupId = "order-service")
    public void listen(ConsumerRecord record){
        String topic = record.topic();
        String key record.key();
        String value = record.value();
        System.out.println("收到消息：" + record); // 可以监听到发给 kafka 的新消息，但是无法消费之前发送的消息
    }

    @KafkaListener(
        groupId = "order-service-2",
        // 指定分区
        topicPartitions = {
            @TopicPartition(topic = "order", partitionOffsets = {
                // 指定分区和初始消费偏移量，这里表示从 0 号分区的第 0 个开始消费
                @PartitionOffset(partition = "0", initialOffset = "0")
            })
        })
    public void listenAll(ConsumerRecord record){
        System.out.println("收到partion-0消息：" + record);
    }
}
```

#### 4.参数配置

**消费者**

```properties
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties[spring.json.value.default.type]=com.example.Invoice
spring.kafka.consumer.properties[spring.json.trusted.packages]=com.example.main,com.example.another
```

**生产者**

```properties
# 配置值的序列化器，默认是 StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties[spring.json.add.type.headers]=false
```

#### 5.自动配置原理

kafka 自动配置在 `KafkaAutoConfiguration`

1. 容器中放了 `KafkaTemplate` 可以进行消息收发
2. 容器中放了`KafkaAdmin` 可以进行 Kafka 的管理，比如创建 topic 等
3. kafka 的配置在 `KafkaProperties` 中，以 `spring.kafka` 开始
   - `bootstrapServers`：kafka 集群的所有服务器地址
   - `properties`：参数设置
   - `consumer`：消费者
   - `producer`：生产者
4. 使用 `@EnableKafka` 可以开启基于注解的模式
