# 第12章_异常处理

### 7.1 默认规则

- 默认情况下，Spring Boot 转发到`/error`处理所有错误的映射
- 对于机器客户端，它将生成 JSON 响应，其中包含错误、HTTP 状态和异常消息的详细信息。对于浏览器客户端，响应一个`whitelable`错误页面，以 HTML 格式呈现相同的数据

如果需要**替换默认规则**，可以向容器中添加一个组件实现`ErrorController`（参考`BasicErrorController`组件）。

如果只需要**替换错误页面显示内容**，可以添加一个`ErrorAttributes`类型的组件（参考`DefaultErrorAttributes`组件）。

### 7.2 异常处理器说明

#### 1.NoHandlerFoundException

首先根据请求`Url`查找有没有对应的控制器，若没有则会抛该异常，也就是大家非常熟悉的`404`异常。

#### 2.HttpRequestMethodNotSupportedException

若匹配到了（匹配结果是一个列表，不同的是`http`方法不同，如：Get、Post等），则尝试将请求的`http`方法与列表的控制器做匹配，若没有对应`http`方法的控制器，则抛该异常。

#### 3.HttpMediaTypeNotSupportedException

然后再对请求头与控制器支持的做比较，比如`content-type`请求头，若控制器的参数签名包含注解`@RequestBody`，但是请求的`content-type`请求头的值没有包含`application/json`，那么会抛该异常（当然，不止这种情况会抛这个异常）。

#### 4.MissingPathVariableException

未检测到路径参数。比如 url 为：`/licence/{licenceId}`，参数签名包含`@PathVariable("licenceId")`，当请求的 url 为`/licence`，在没有明确定义 url 为`/licence`的情况下，会被判定为：缺少路径参数。

#### 5.MissingServletRequestParameterException

缺少请求参数。比如定义了参数`@RequestParam("licenceId") String licenceId`，但发起请求时，未携带该参数，则会抛该异常。

#### 6.TypeMismatchException

参数类型匹配失败。比如：接收参数为 Long 型，但传入的值确是一个字符串，那么将会出现类型转换失败的情况，这时会抛该异常。

#### 7.HttpMessageNotReadableException

与上面的`HttpMediaTypeNotSupportedException`举的例子完全相反，即请求头携带了`"content-type: application/json;charset=UTF-8"`，但接收参数却没有添加注解`@RequestBody`，或者请求体携带的 json 串反序列化成 pojo 的过程中失败了，也会抛该异常。

#### 8.HttpMessageNotWritableException

返回的 pojo 在序列化成 json 过程失败了，那么抛该异常。

### 7.3 定制错误处理逻辑

#### 1.自定义错误页

```java
    private ModelAndView resolveResource(String viewName, Map<String, Object> model) {
        for (String location : this.resources.getStaticLocations()) {
            try {
                Resource resource = this.applicationContext.getResource(location);
                resource = resource.createRelative(viewName + ".html");
                if (resource.exists()) {
                    return new ModelAndView(new HtmlResourceView(resource), model);
                }
            }
            catch (Exception ex) {
            }
        }
        return null;
    }
```

可以在`/templates/error`下放入`4xx`、`5xx`页面，会被自动解析（需要视图解析器，例如 Thymeleaf）。有精确的错误状态码页面就精确匹配，没有就找`4xx.html`，如果都没有就响应`whitelable`错误页面。

#### 2.捕获全局异常

方法1

`@ControllerAdvice`+`@ExceptionHandler`，由`HandlerExceptionResolverComposite`中的`ExceptionHandlerExceptionResolver`解析。

```java
@RestControllerAdvice
public class MyErrorHandler {

    @ExceptionHandler
    public String defaultHandler(Exception e) {
        return "error";
    }
}
```

**原理**

在初始化`ExceptionHandlerExceptionResolver`时（调用`initExceptionHandlerAdviceCache()`），会获得所有`@ControllerAdvice`声明的 Bean，并放入到`ExceptionHandlerExceptionResolver`的`exceptionHandlerAdviceCache：Map`中。在解析异常时，会从`exceptionHandlerAdviceCache`中获得对应的方法封装为`ServletInvocableHandlerMethod`。

```java
public class ExceptionHandlerExceptionResolver extends AbstractHandlerMethodExceptionResolver
		implements ApplicationContextAware, InitializingBean {
	private void initExceptionHandlerAdviceCache() {
		List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());
		for (ControllerAdviceBean adviceBean : adviceBeans) {
			Class<?> beanType = adviceBean.getBeanType();
			if (beanType == null) {
				throw new IllegalStateException("Unresolvable type for ControllerAdviceBean: " + adviceBean);
			}
			ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);
			if (resolver.hasExceptionMappings()) {
                // 将 adviceBean 放入 exceptionHandlerAdviceCache
				this.exceptionHandlerAdviceCache.put(adviceBean, resolver);
			}
			if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) {
				this.responseBodyAdvice.add(adviceBean);
			}
		}
	}
    
	protected ServletInvocableHandlerMethod getExceptionHandlerMethod(
			@Nullable HandlerMethod handlerMethod, Exception exception) {

		Class<?> handlerType = null;

		if (handlerMethod != null) {
			// Local exception handler methods on the controller class itself.
			// To be invoked through the proxy, even in case of an interface-based proxy.
			handlerType = handlerMethod.getBeanType();
			ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);
			if (resolver == null) {
				resolver = new ExceptionHandlerMethodResolver(handlerType);
				this.exceptionHandlerCache.put(handlerType, resolver);
			}
			Method method = resolver.resolveMethod(exception);
			if (method != null) {
				return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method, this.applicationContext);
			}
			// For advice applicability check below (involving base packages, assignable types
			// and annotation presence), use target class instead of interface-based proxy.
			if (Proxy.isProxyClass(handlerType)) {
				handlerType = AopUtils.getTargetClass(handlerMethod.getBean());
			}
		}

        // 遍历 exceptionHandlerAdviceCache 找到对应的异常处理方法
		for (Map.Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {
			ControllerAdviceBean advice = entry.getKey();
			if (advice.isApplicableToBeanType(handlerType)) {
				ExceptionHandlerMethodResolver resolver = entry.getValue();
				Method method = resolver.resolveMethod(exception);
				if (method != null) {
                    // 封装为 ServletInvocableHandlerMethod
					return new ServletInvocableHandlerMethod(advice.resolveBean(), method, this.applicationContext);
				}
			}
		}

		return null;
	}
}
```

==方法2==

也可继承`ResponseEntityExceptionHandler`，添加`@RestControllerAdvice`注解，重写各种异常捕获的方法。

当有视图解析时，可以继承`DefaultHandlerExceptionResolver`，但会覆盖原有的`DefaultHandlerExceptionResolver`。

> 也可以继承重写`ExceptionHandlerExceptionResolver`，会覆盖原有的`ExceptionHandlerExceptionResolver`。

#### 3.@ResponseStatus+自定义异常

把`@ResponseStatus`注解的信息调用`response.sendError(statusCode, resolvedReason)`发送`/error`请求。

```java
@ResponseStatus(value= HttpStatus.ACCEPTED, reason="test")
public class MyException extends RuntimeException{
}
```

此时尽管依然跳转到错误页面，但是响应码为`202`，对应`HttpStatus.ACCEPTED`。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220621194753984-d33a4fdcb9fa628a8550450f3fd39787-be3584.png" alt="image-20220621194753984" style="zoom:80%;" />

**原理**

底层由`ResponseStatusExceptionResolver`解析。

```java
public class ResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver implements MessageSourceAware {
    protected ModelAndView doResolveException(
        HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {

        try {
            if (ex instanceof ResponseStatusException) {
                return resolveResponseStatusException((ResponseStatusException) ex, request, response, handler);
            }

            // 是否标注了 @ResponseStatus
            ResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);
            if (status != null) {
                // ↓
                return resolveResponseStatus(status, request, response, handler, ex);
            }

            if (ex.getCause() instanceof Exception) {
                return doResolveException(request, response, handler, (Exception) ex.getCause());
            }
        }
        catch (Exception resolveEx) {
            if (logger.isWarnEnabled()) {
                logger.warn("Failure while trying to resolve exception [" + ex.getClass().getName() + "]", resolveEx);
            }
        }
        return null;
    }
    
    // ↑
    protected ModelAndView resolveResponseStatus(ResponseStatus responseStatus, HttpServletRequest request,
			HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {

		int statusCode = responseStatus.code().value();
		String reason = responseStatus.reason();
        // ↓
		return applyStatusAndReason(statusCode, reason, response);
	}
    
    // ↑
    protected ModelAndView applyStatusAndReason(int statusCode, @Nullable String reason, HttpServletResponse response)
			throws IOException {

		if (!StringUtils.hasLength(reason)) {
			response.sendError(statusCode);
		}
		else {
			String resolvedReason = (this.messageSource != null ?
					this.messageSource.getMessage(reason, null, reason, LocaleContextHolder.getLocale()) :
					reason);
            // 发送 error 请求
			response.sendError(statusCode, resolvedReason);
		}
		return new ModelAndView();
	}
}
```

#### 4.NoHandlerFoundException

当访问地址出错需要返回自定义错误对象时，需要添加以下配置：

```properties
# spring.mvc.static-path-pattern=/static
spring.web.resources.add-mappings=false
spring.mvc.throw-exception-if-no-handler-found=true
```

然后捕获全部异常时，处理`NoHandlerFoundException`。

**原理**

`DispacherServlet`中没有找到对应的 handler 时，默认不返回异常，直接发送`sendError()`，可通过设置`spring.mvc.throw-exception-if-no-handler-found`，使其产生异常。

```java
public class DispatcherServlet extends FrameworkServlet {

    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        mappedHandler = getHandler(processedRequest);
        if (mappedHandler == null) {
            noHandlerFound(processedRequest, response);
            return;
        }    
    }

    protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if (pageNotFoundLogger.isWarnEnabled()) {
            pageNotFoundLogger.warn("No mapping for " + request.getMethod() + " " + getRequestUri(request));
        }
        // 默认false，可通过 spring.mvc.throw-exception-if-no-handler-found 更改
        if (this.throwExceptionIfNoHandlerFound) {
            throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),
                                              new ServletServerHttpRequest(request).getHeaders());
        }
        else {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
}
```

另外还需要修改静态资源匹配规则。

在容器启动时，`WebMvcAutoConfiguration`导入了其内部静态类`WebMvcAutoConfigurationAdapter`，并执行了`addResourceHandlers()`方法。

```java
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 如果 spring.web.resources.add-mappings 设置为 false，则禁用所有静态规则，即无法访问静态资源
        if (!this.resourceProperties.isAddMappings()) {
            logger.debug("Default resource handling disabled");
            return;
        }
        addResourceHandler(registry, "/webjars/**", "classpath:/META-INF/resources/webjars/");
        // 添加静态路径 pattern，通过 spring.mvc.static-path-pattern 设置，默认全匹配，即 /**
        addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
            registration.addResourceLocations(this.resourceProperties.getStaticLocations());
            if (this.servletContext != null) {
                ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);
                registration.addResourceLocations(resource);
            }
        });
    }
}
```

当没有找到匹配 urlpattern 的 handler 时，默认由静态资源处理器`SimpleUrlHandlerMapping`来处理，鉴于次，我们可以通过设置以下两个属性（任选其一）来禁用全局静态匹配：

```properties
spring.mvc.static-path-pattern=/static
spring.web.resources.add-mappings=false
```
