# 第3章_声明式事务

## 1.声明式事务

Spring 中并没有提供事务，只是提供了对数据库事务的一个管理的封装。开发人员不需要关系事务的提交和回滚，更加聚焦在业务开发上。且主要针对单个数据库的多个数据表的操作。没有提供分布式事务的场景支持。

### 1.1 事务传播行为

用来描述这样一个现象：`methodA`开启了一个事务，调用了`methodB`，`methodB`是继续在`methodA`的事务中进行还是开启一个新的事物。

```java
@Transaction(Propagation=REQUIRED)
public void methodA() {
    methodB();
    //doSomething
}

@Transaction(Propagation=REQUIRED_NEW)
public void methodB() {
    //doSomething
}
```

**七种传播行为**

- `REQUIRED`（默认）

  如果当前有事务，则继续在事务中进行， 如果没有则开启一个新的事务

- `REQUIRED_NEW`

  无论是否存在事务，都会开启一个新的事务来执行，新老事务相互独立，一个事务抛出异常不会影响另一个事务的提交

- `NESTED`

  如果当前存在事务，则嵌套在当前事务中执行，如果没有事务则新建一个事务

  外部事务抛出异常会导致嵌套事务回滚，嵌套事务回滚不会影响外部事务

- `SUPPORTS`

  支持当前事务，如果当前不存在事务，就以非事务的方式进行

- `NOT_SUPPORTED`

  以非事务的方式执行，如果当前存在事务，则把当前事务挂起

- `MANDATORY`

  强制的事务执行，如果不存在事务就抛出异常

- `NEVER`

  以非事务的方式执行，如果存在事务则抛出异常

### 1.2 简单环境搭建

1. 导入相关依赖：数据源，数据驱动，Spring-jdbc模块

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>

<!-- 数据源 -->
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
```

2. 配置数据源，JdbcTemplate（Spring 提供简化数据库操作的工具） 操作数据

```java
@Configuration
@ComponentScan("com.youyi.boot.tx")
public class TxConfig {
    @Bean
    public DataSource dataSource() throws PropertyVetoException {
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setUser("root");
        dataSource.setPassword("root");
        dataSource.setDriverClass("com.mysql.jdbc.Driver");
        // 需配置 timezone
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8");

        return dataSource;
    }

    // Spring 对 @Configuration 类会特殊处理，给容器中添加组件的方法，多次调用都只是从容器中找组件而已，不会再次执行方法创建组件
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

3. 创建 UserDao

```java
@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void insert() {
        String sql = "INSERT INTO tbl_user(username, age) VALUES(?, ?)";
        String username = UUID.randomUUID().toString().substring(0, 5);
        jdbcTemplate.update(sql, username, 19);
    }
}
```

4. 创建 UserService

```java
public class UserService {

    @Autowired
    private UserDao userDao;

    public void insertUser() {
        userDao.insert();
        System.out.println("insert finished");
    }
}
```

5. 测试

```java
@Test
public void test01() {
    AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class);
    UserService bean = applicationContext.getBean(UserService.class);
    bean.insertUser();
    applicationContext.close();
}
```

### 1.3 实现事务

1. 标注`@EnableTransactionManagement`开启基于注解的事务管理功能

   ```java
   @Configuration
   @ComponentScan("com.youyi.boot.tx")
   // 开启基于注解的事务管理
   @EnableTransactionManagement
   public class TxConfig {
   ```

2. 给方法上标注`@Transactional`表示当前方法是一个事务

   ```java
   @Transactional
   public void insertUser() {
       userDao.insert();
       System.out.println("insert finished");
   }
   ```

3. 配置事务管理器来管理事务

   ```java
   // 注册事务管理器在容器中
   @Bean
   public PlatformTransactionManager platformTransactionManager() throws PropertyVetoException {
       return new DataSourceTransactionManager(dataSource());
   }
   ```

### 1.4 实现原理

`@EnableTransactionManagement`通过导入`TransactionManagementConfigurationSelector`给容器中导入组件：

1. `ProxyTransactionManagementConfiguration`：给容器中注册事务增强器

   - 添加一个`AnnotationTransactionAttributeSource`用来解析事务注解

   - 添加一个`TransactionInterceptor`，保存事务属性信息，事务管理器，继承了`MethodInterceptor`
   - 添加一个增强器`BeanFactoryTransactionAttributeSourceAdvisor`（Bean 名称：`internalTransactionAdvisor`）用于创建代理类，会将`transactionInterceptor`和`AnnotationTransactionAttributeSource`添加到自身

2. `AutoProxyRegistrar`：给容器中注册`InfrastructureAdvisorAutoProxyCreator`组件

   - `InfrastructureAdvisorAutoProxyCreator`：继承后置处理器，在对象实例创建后利用增强器包装对象，返回一个代理对象（增强器），代理对象执行方法，利用拦截器链执行调用


在目标方法执行时，执行拦截器`TransactionInterceptor`的`invoke()`方法：

1. 先获取事务相关属性
2. 获取`PlatformTransactionManager`，如果事先没有添加指定任何`TransactionManager`，最终会从容器中按照类型获取一个`PlatfromTransactionManager`
3. 目标方法执行
   1. 事务管理器创建数据库连接（替代 jdbcTemplate）
   2. 设置`autoCommit = false`
   3. 如果异常，利用事务管理器回滚操作——最终调用`Connection.rollback()`
   4. 如果正常，利用事务管理器提交事务——最终调用`Connection.commit()`

### 1.5 事务传播机制

```java
@Component
public class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Transactional
    public void test() {
        jdbcTemplate.execute("insert...");
        a();
    }
    
    @Transactional(propogation = Propogation.NEVER) // 若存在事务则抛异常
    public void a() {
        jdbcTemplate.execute("insert");
    }
}
```

上述`test()`方法执行不会抛出异常，因为`a()`方法没有使用代理对象。可以将方法`a()`抽取出来写在一个类中，这样使用该方法时就使用到了代理类。

```java
@Component
public class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private Bservice bservice;
    
    @Transactional
    public void test() {
        jdbcTemplate.execute("insert...");
        bservice.a();
    }
}

@Component 
public class Bservice {
    @Transactional(propogation = Propogation.NEVER) // 抛异常
    public void a() {
        jdbcTemplate.execute("insert");
    }
}
```

或者直接自己注入自己：

```java
@Component
public class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private UserSerivce userService;
    
    @Transactional
    public void test() {
        jdbcTemplate.execute("insert...");
        userService.a();
    }
    
    @Transactional(propogation = Propogation.NEVER) // 抛异常
    public void a() {
        jdbcTemplate.execute("insert");
    }
}
```

###  1.6 失效案例

1. **访问权限**

   如果访问权限不是 public，则会导致事务失败，因为 Spring 要求被代理方法必须是 public。

   ```java
   public abstract class AbstractFallbackCacheOperationSource implements CacheOperationSource {
       private Collection<CacheOperation> computeCacheOperations(Method method, @Nullable Class<?> targetClass) {
           // Don't allow non-public methods, as configured.
           if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
               return null;
           }
           ...
       }
   }
   ```

2. **方法用 final 修饰**

   弱方法被 final 修饰，则无法被代理类重写。

3. **对象没有被 Spring 管理**

4. **数据库不支持事务**

5. 调用`@Transactional`方法然后在内部调用带有`@Transactional`注解的方法

   ```java
   @Service
   public class MyService {
       
       public void update(String s) {
           updateOrder(s);
       }
       
       @Transactional
       public void update(String s) {
           // update
       }
   }
   ```

   解决方法：

   1. 将`update()`方法写在另一个组件中
   2. 使用编程式事务
   3. 使用`AopContext.currentProxy()`获取代理对象（确保 exposeProxy 设置为 true，在`EnableAspectJAutoProxy`设置，默认为 false）

   ```java
   @Service
   public class MyService {
       
       public void update(String s) {
           ((MyService) AopContext.currentProxy()).update(s);
       }
       
       @Transactional
       public void update(String s) {
           // update
       }
   }
   ```

6. 未开启事务

7. 在代码中捕获了异常，代理类无法捕获异常因此认为没有异常

8. 在事务方法中开启了新的线程连接数据库，则该连接不具有事务
