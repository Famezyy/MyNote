# 解决跨域问题

## 1.什么是跨域

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 javascript 施加的安全限制。

例如：a 页面想获取 b 页面资源，如果 a、b 页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。

同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；
<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/202302040324146.png" alt=""/>

## 2.跨域请求的安全问题

 通常，浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 **CSRF**攻击。

**CSRF 攻击**

 CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。

 CSRF 攻击的原理大致描述如下：有两个网站，其中A网站是真实受信任的网站，而B网站是危险网站。在用户登陆了受信任的A网站是，本地会存储A网站相关的 Cookie，并且浏览器也维护这一个 Session 会话。这时，如果用户在没有登出A网站的情况下访问危险网站B，那么危险网站B就可以模拟发出一个对A网站的请求（跨域请求）对 A 网站进行操作，而在A网站的角度来看是并不知道请求是由B网站发出来的（Session 和 Cookie 均为 A 网站的），这时便成功发动一次 CSRF 攻击。

 因而 CSRF 攻击可以简单理解为：攻击者盗用了你的身份，以你的名义发送而已请求。CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

 因此，大多数浏览器都会跨域请求作出限制，这是从浏览器层面上的对 CSRF 攻击的一种防御，但是需要注意的是在复杂的网络环境中借助浏览器来防御 CSRF 攻击并不足够，还需要从服务端或者客户端方面入手防御。

## 3.解决方案

对于 CORS 的跨域请求，主要有以下几种方式可供选择：

1.  返回新的`CorsFilter`
2.  重写`WebMvcConfigurer`
3.  使用注解`@CrossOrigin`
4.  手动设置响应头
5.  自定 web filter 实现跨域

### 3.1 使用CorsFilter

>   注意：
>
>   -   CorFilter / WebMvConfigurer / @CrossOrigin 需要 SpringMVC 4.2 以上版本才支持，对应 springBoot 1.3 版本以上
>   -   上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS 配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过`@CrossOrigin`注解来进行细粒度更高的跨域资源控制
>   -   其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域

在任意配置类，返回一个 CorsFIlter Bean，并添加映射路径和具体的 CORS 配置路径：

```java
@Configuration
public class GlobalCorsConfig {

  @Bean
  public CorsFilter corsFilter() {
    //1. 添加 CORS配置信息
    CorsConfiguration config = new CorsConfiguration();
    //放行哪些原始域
    config.addAllowedOrigin("*");
    //是否发送 Cookie
    config.setAllowCredentials(true);
    //放行哪些请求方式
    config.addAllowedMethod("*");
    //放行哪些原始请求头部信息
    config.addAllowedHeader("*");
    //暴露哪些头部信息
    config.addExposedHeader("*");
    //2. 添加映射路径
    UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();
    corsConfigurationSource.registerCorsConfiguration("/**",config);
    //3. 返回新的CorsFilter
    return new CorsFilter(corsConfigurationSource);
  }
}
```

### 3.2 重写WebMvcConfigurer

```java
// 案例一
@Configuration
public class CorsConfig implements WebMvcConfigurer {

  @Override
  public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/**")
      //是否发送Cookie
      .allowCredentials(true)
      //放行哪些原始域
      .allowedOrigins("*")
      .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"})
      .allowedHeaders("*")
      .exposedHeaders("*");
  }
}

// 案例二 
@Configuration
public class AccessControlAllowOriginFilter implements WebMvcConfigurer {

  @Override
  public void addCorsMappings(CorsRegistry registry){
    registry.addMapping("/*/**")
      .allowedHeaders("*")
      .allowedMethods("*")
      .maxAge(1800)
      .allowedOrigins("*");
  }
}
```

### 3.3 使用注解

在控制器上使用注解`@CrossOrigin`，表示该类的所有方法允许跨域

```java
@RestController
@CrossOrigin(origins = "*")
public class HelloController {
 
    @RequestMapping("/hello")
    public String hello() {
        return "hello world";
    }
}
```

在方法上使用注解`@CrossOrigin`表示只有对应请求允许跨域

```java
@RequestMapping("/hello")
@CrossOrigin(origins = "*")
//@CrossOrigin(value = "http://localhost:8081") //指定具体 ip 允许跨域
public String hello() {
  return "hello world";
}
```

### 3.4 手动设置响应头

使用`HttpServletResponse`对象添加响应头`Access-Control-Allow-Origin`来授权原始域，这里 Origin 的值`*`表示全部放行。

```java
@RequestMapping("/index")
public String index(HttpServletResponse response) {
  response.addHeader("Access-Allow-Control-Origin","*");
  return "index";
}
```

### 3.5 使用自定义filter实现跨域

```java

@Component
public class MyCorsFilter implements Filter {

  public void doFilter(ServletRequest req, ServletResponse res, 
                       FilterChain chain) throws IOException, ServletException {

    HttpServletResponse response = (HttpServletResponse) res;
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
    response.setHeader("Access-Control-Max-Age", "3600");
    response.setHeader("Access-Control-Allow-Headers", "x-requested-with,content-type");
    response.setHeader("Access-Control-Expose-Headers", "content-disposition");
    chain.doFilter(req, res);

  }
  public void init(FilterConfig filterConfig) {}
  public void destroy() {}
}
```

