## Iterable接口

集合不能直接实现 Iterator 接口，而要实现 Iterable 接口，在 Iterable 接口中定义了返回 Iterator 接口的方法。这样每次调用时就可以返回新的迭代器，使`每个迭代器遍历元素时互不影响`。

```java
public interface Iterable<T> {
    Iterator<T> iterator();
}
```

但每次迭代时并不是复制整个集合的元素，这样消耗的资源太大，Java 集合类中常用的做法是在获取迭代器时让迭代器保存一个 int 数值，这个 int 数值是集合的成员属性`modCount`，用来记录集合增删操作的次数。

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
}
```

获取迭代器时，会记录当前的 modCount 的值，且在遍历元素时，会检查 modCount 的值是否等于获取迭代器时的值。如果不一致代表集合在获取迭代器后执行的增删改操作，此时迭代器会`抛出异常`。

```java
private class Itr implements Iterator<E> {
    int expectedModCount = modCount;
    public E next() {
        checkForComodification();
        ...
    }
    final void checkForComodification() {
        if (modCount != expectedModCount) // 检查值是否一致！
            throw new ConcurrentModificationException();
    }
```

在迭代器中删除数据时可以使用迭代器`ListIterator`的`add`、`set`、`remove`方法。

```java
public ListIterator<E> listIterator() {
        return new ListItr(0);
    }
```

