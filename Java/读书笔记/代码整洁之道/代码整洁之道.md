# 代码整洁之道

写函数时不要在意一开始的冗长和复杂，写完后通过打磨代码，分解函数，消除重复，拆散类等方式使代码变得整洁。

## 1.命名

1. 名字要**名副其实，不要怕长**，例如：

   - `elapsedTimeIndays` - 消逝的时间（天）

   - `daysSinceCreation` - 创建后经过的天数

   - `fileAgeInDays` - 文件创建的天数

   - `accountGroup` or `bunchOfAccounts` - 一组账号

2. **不要使用小写字母`l`、大写字母`I`，大写字母`O`**，容易造成歧义
3. **不要试图加入数字**来区分名称，例如：`a1`、`a2`
4. 数字可声明为具有实际的意义的常量，例如：`MAX_CLASSES_PER_STUDENT`
5. 类名和对象名应当是名词或名词短语，方法名应当是动词或动词短语，例如：`postPayment`、`deletePage`
6. 创建对象时，**尽量使用描述了参数的静态工厂方法名**，可将构造器声明为`private`
7. **每个概念只对应一个词**，例如不要同时出现`fetch`、`get`的明明形式

## 2.函数

1. **短小**

   最好压缩到 3~4 行，`if`、`while`语句的代码块应该是一个函数调用，函数的缩进不该多余 2 层，例如：

   ```java
   // 方法长度最好不要超过以下代码
   public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
       boolean isTestPage = pageData.hasAttribute("test");
       if (isTestPage) {
           WikiPage testPage = pageData.geWikiPage();
           StringBuilder newPageContent = new StringBuilder();
           includeSetupPages(testPage, newPageContent, isSuite);
           newPageContent.append(pageData.getContent());
           includeTeardownPages(newPageContent.toString());
           pageData.setContent(newPageContent.toString());
       }
       return pageData.getHtml();
   }
   ```

   最好修改为：

   ```java
   public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
       if (isTestPage(pageData))
           includeSetupAndTeardownPages(pageData, isSuite);
       return pageData.getHtml();
   }
   ```

2. **只做一件事**

   一个方法不能再被拆分出任何方法，例如：

   ```java
   void convertAndValidateParameter(Object parameter) throws Exception {}
   ```

   改为三个方法：

   ```java
   Object handleParameter(Object parameter) throws Exception  {
       Object convertedParameter = convertParameter(parameter);
       validateParameter(convertedParameter);
       return convertedParameter;
   }
   
   ```

3. 对于`switch`语句，尽量**只用于创建多态对象**，例如：

   ```java
   public Money calculatePay(Employee e) throws InvalidEmployeeType {
       switch (e.type) {
           case COMMISSIONED:
               return calculateCommisionedPay(e);
           case HOURLY:
               return calculateHourlyPay(e);
           case SALARIED:
               return calculateSalariedPay(e);
           default:
               throw new InvalidEmployeeType(e.type);
       }
   }
   ```

   上面的方法违反了单一职责原则（判断配型 + 计算工资）和开放封闭原则（每增加一种类型就要修改依次），同时相应的还可能会有其他类似的方法，例如`isPayday()`、`deliverPay()`等都需要用到`switch`。

   解决方法为将`switch`埋到抽象工厂中：

   ```java
   public abstract class Employee {
       public abstract boolean isPayday();
       public abstract Money calculatePay();
       public abstract void deliverPay(Money pay);
   }
   
   public interface EmployeeFacotry {
       public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
   }
   
   public class EmployeeFactoryImpl implements EmployeeFactory {
       public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
           switch (r.type) {
               case COMMISSIONED:
                   return new CommissionedEmployee(r);
               case HOURLY:
                   return new HourlyEmployee(r);
               case SALARIED:
                   return new SalariedEmployee(r);
               default:
                   throw new InvalidEmployeeType(r.type);
           }
       }
   }
   ```

4. **函数参数不要多于 3 个**

   - 一元参数

     传入单个参数有两种普遍的理由：

     1. 将传入的参数转换为其他东西再输出，例如：

        ```java
        boolean fileExists(String fileName) {}
        ```

     2. 根据传入的参数（看作事件）修改系统状态，且传入的参数要明确**事件**的含义，例如：

        ```java
        void posswordAttemptFailedNtimes(int attempts) {}
        ```

     如果函数要对参数进行转换，转换结果就应该体现为返回值。

     ```java
     StringBuffer transform(StringBuffer in) {}
     ```

     ````java
     void transform(StringBuffer out)
     ````

     上面的代码要优于下面的。

   - 标识参数（布尔类型）

     避免传入标识参数，那样则表示方法至少做了两件事：true 则这样做，false 则那样做。例如：

     ```java
     void render(Boolean isSuite) {}
     ```

     改为两个方法：

     ```java
     void renderForSuite() {}
     void renderForSingleTest() {}
     ```

   - 二元参数

     尽管二元参数问题不大，但有时它比一元难懂，例如：

     ```java
     void writeField(String name) {}
     ```

     ```java
     void writeField(OutputStream outputStream, String name) {}
     ```

     第一个方法更易于理解。

     可以将`writeField`写成`outputStream`的成员方法。还可以分离出类似`FieldWriter`的类，在其构造器中传入`outputStream`，并提供一个`writeField(name)`的方法。

   - 三元参数

     三元参数有时就比较难理解，例如：

     ```java
     void assertEquals(String message, Object expected, Object actual) {}
     ```

     上面的方法很容易就搞乱参数的顺序。

   - 三个以上

     如果函数需要 3 个以上参数，就说明其中一些参数应该封装为类了，例如：

     ```java
     Circle makeCircle(double x, double y, double radius);
     ```

     ```java
     Circle makeCircle(Point center, double radius);
     ```

5. **动词与关键词**

   方法名和参数名应当是一种良好的动词/名词对形式，例如：

   ```java
   void assertEqual(Object expected, Object actual) {}
   ```

   改成：

   ```java
   void assertExpectedEqualsActual(Object expected, Object actual) {}
   ```

6. **分隔指令与询问**

   函数要么做什么，要么回答什么，例如：

   ```java
   if(CheckIfExistsAndSet("username", "youyi")) {}
   ```

   改为：

   ```java
   if(attributeExists("username")) {
       setAttribute("username", "youyi");
   }
   ```

7. **使用异常代替返回错误码**

   返回错误码通常暗示某处有个类或者是枚举，其他许多类都得导入和使用它，当枚举类修改时，所有依赖的类都需要重新编译和部署。使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或部署。

8. **抽离`try/catch`代码块**

   ```java
   public void delete(Page page) {
       try {
           deletePageAndAllReferences(page);
       } catch (Exception e) {
           logError(e);
       }
   }
   private void deletePageAndAllReferences(page page) throws Exception {
       deletePage(page);
       registry.deleteReference(page.name);
       configKeys.deleteKey(page.name.makeKey());
   }
   
   private void logError(Exception e) {
       logger.log(e.getMessage());
   }
   ```

## 3.注释

- 唯一真正好的注释是想办法不去写的注释。例如：

  ```java
  // Returns an instance of the Responder being tested.
  protected abstract Responder responderInstance();
  ```

  只需要把函数重命名为`responderBeingTested`，注释就是多余的。

- `TODO`注释有时是必要的
- 可以用于提示信息和警告
- 盲目的让开发者给每个函数都写上注释只会让代码变得散乱
- 最终不要注释代码

## 4.格式

- 被调用的函数应该放在执行调用的函数下面

- 如果`if`或`while`的方法体只有一行，可以不使用`{}`

  ```java
  if (true)
      // do something
      return;
  else
      // do something
  ```

## 5.对象和数据结构

- 不要一股脑全加上`setter`、`getter`，只暴露需要暴露的数据

  迪米特法则：模块不应了解他所操作对象的内部情形，例如：

  ```java
  // 将具体的数据隐藏在抽象之后
  public interface Vehicle {
      // 只暴露剩余百分比，隐藏具体的数据
      public double getPercentFuelRemaining();
  }
  ```

- 合理运用**过程式代码风格**和**面向对象代码风格**

  过程式代码风格

  ```java
  public class Square {
      public Point topLeft;
      public double side;
  }
  
  public class Circle {
      public Point center;
      public double radius;
  }
  
  public class Geometry {
      public final double PI = 3.14159;
      
      public double area(Object share) {
          if (shape instanceof Square) {
              Square s = (Square) share;
              return s.side * s.side;
          }
          else if (share instanceof Circle) {
              Circle c = (Circle) share;
              return PI * c.radius * c.radius;
          }
      }
  }
  ```

  面向对象代码风格

  ```java
  public class Square implements Shape {
      private Point topLeft;
      private double side;
      
      public  double area() {
          return side * side;
      }
  }
  
  public class Circle implements Shape {
      private Point center;
      private double radius;
      public final double PI = 3.14159;
      
      public double area() {
          return PI * radius * radius;
      }
  }
  ```

  可以发现，过程式代码便于在不改动既有数据结构的前提下添加新函数（例如在 Geometry 中添加计算周长的函数）；面向对象代码便于在不改动既有函数的前提下添加新类（例如添加一个三角形的类）。

- 区分**数据结构**（只包含成员变量和相应的`getter`、`setter`方法）和**对象**（包含业务逻辑）

## 6.错误处理