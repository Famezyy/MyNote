| 实例          | 描述                              |
| ------------- | --------------------------------- |
| `[Pp]ython`   | 匹配 “Python” 或 “python”         |
| `rub[ye]`     | 匹配 “ruby” 或 “rube”             |
| `[abcdef]`    | 匹配中括号内的任意一个字母        |
| `[0-9]`       | 匹配任何数字。类似于 [0123456789] |
| `[a-z]`       | 匹配任何小写字母                  |
| `[A-Z]`       | 匹配任何大写字母                  |
| `[a-zA-Z0-9]` | 匹配任何字母及数字                |
| `[^au]`       | 除了au字母以外的所有字符          |
| `[^0-9]`      | 匹配除了数字外的字符              |

| 实例 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| `.`  | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |
| `?`  | 匹配一个字符零次或一次，另一个作用是<a href="#tanlan">非贪婪模式</a> |
| `+`  | 匹配1次或多次                                                |
| `*`  | 匹配0次或多次                                                |
| `\b` | 匹配一个单词的边界，单词在这里被定义为**字母数字**或**下划线数字** |
| `\d` | 匹配一个数字字符。等价于 [0-9]                               |
| `\D` | 匹配一个非数字字符。等价于 [\^0-9]                           |
| `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\f\n\r\t\v] |
| `\S` | 匹配任何非空白字符。等价于 [\^\f\n\r\t\v]                    |
| `\w` | 匹配包括下划线的任何单词字符。等价于 [A-Za-z0-9_]            |
| `\W` | 匹配任何非单词字符。等价于 [\^A-Za-z0-9_]                    |
| `\b` | 匹配一个长度为`0`的子串                                      |

## 一、字符组

**字符组**（`[]`）允许匹配一组可能出现的字符。

例如：

![image2](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMi5wbmc=)

可以发现`[Pp]`既可以匹配大写的`P`也可以匹配小写的`p`

### 1.区间

有一些常见的字符组非常大，比如，我们要匹配任意的数字，如果依照上述代码，每次我们都需要使用`[0123456789]`。

为了适应这一点，正则表达式引擎在字符组中使用**连字符`(-)`代表区间**，依照这个规则，我们可以总结出三点：

1. 要匹配任意数字可以使用`[0-9]`；
2. 如果想要匹配所有小写字母，可以写成`[a-z]`；
3. 想要匹配所有大写字母可以写成`[A-Z]`。

例如：

![image4](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlNC5wbmc=)

### 2.匹配特殊字符

正则表达使用了 `-` 号代表了**区间**，但是我们有时候需要匹配的符号就是 `-`号，该怎么办呢？

这个时候我们需要对`-`号进行**转义**操作，即 `\-`。

在正则中使用 `\` 就可以进行对特殊符号进行转义，对 `-` 进行转义就可以表示为 `\-`，即 `\-` 就代表了 `-` 号本身。

> 偷偷告诉你，转义符 `\` 也适用于其他的符号，例如匹配圆括号可以使用 `\(`

例如：

![image4](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlNS5wbmc=)

### 3.匹配字母

> []`字符组中可以放多个条件例如，想要匹配数字的小写字母可以这样写：`[0-9a-z]

### 4.取反

到目前为止，我们定义的字符组都是由可能出现的字符定义，不过有时候我们可能希望根据不会出现的字符定义字符组。

例如：匹配不包含数字的字符组

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlNi5wbmc=)

可以通过在字符数组开头使用 `^` 字符实现取反操作，从而可以反转一个字符组（意味着会匹配任何指定字符之外的所有字符）。

再看一个例子：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlNy5wbmc=)

这里的 `n[^e]` 的意思就是`n`后面的字母不能为 `e`。

---

## 二、快捷方式

### 1.快捷匹配数字和字母

以目前学到的内容，如果想要匹配所有的字母，会使用`[A-Za-z]`，要匹配数字会使用`[0-9]`

还有没有更简洁的方式呢？

正则表达式引擎提供了一些快捷方式如：`\w` 可以与**任意单词字符**匹配。

当我们想要**匹配任意数字**的时候也可以使用快捷方式`\d`，`d`即`digit`数字的意思，等价于`[0-9]`。

### 2.匹配空白

`\s`快捷方式可以**匹配空白字符**，比如空格，tab、换行等。

例如：

![image8](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlOC5wbmc=)

### 3.单词边界

`\b` 匹配的是**单词的边界**，例如，

![image9](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlOS5wbmc=)

`\bmaster\b` 就仅匹配有边界的`master`单词。

当然其他类型的数据，比如数字也能匹配：

![image9](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTAucG5n)

### 4.快捷方式取反

快捷方式也可以取反，例如对于`\w`的取反为`\W`，将小写改写成大写即可，其他快捷方式也遵循这个规则。

示例：

![image11](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTEucG5n)

### 5.开始和结束

正则表达式中 `^` 或者 `\A` 指定的是一个字符串的开始，`$` 或者 `\Z` 指定的是一个字符串的结束。

例如：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTIucG5n)

指定字符串的结束：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTMucG5n)

### 6.任意字符

`.`字符代表匹配任何单个字符，它**只能出现在方括号以外**。

**值得注意的是：** `.`字符只有一个不能匹配的字符，也就是换行符（`\n`），不过要让`.`字符与换行符匹配也是可以的，以后会讨论。

示例：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTQucG5n)

### 7.可选字符

有时，我们可能想要匹配一个单词的不同写法，比如`color`和`colour`，或者`honor`与`honour`。

这个时候我们可以使用 `?` 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现**零次或一次**。

例如：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTUucG5n)

在这里 `u?` 表示`u`是可选的，即可以出现也可以不出现，可以匹配的是 `honor` 和 `honour` 。

通过这个案例可以知道`?`的作用就是匹配它之前的字符`0`次或`1`次。

---

## 三、匹配多个数据

### 1.重复

到目前为止，我们只是学习了关于仅出现一次的字符串匹配，在实际开发中，肯定不能满足需求，比如要匹配电话号码、身份证的时候就无法满足需求了。

如果遇到这样的情况，我们可能期望一个字符组连续匹配好几次。

在一个字符组后加上`{N}` 就可以表示在它之前的字符组出现`N`次。

例如：

![image16](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTYucG5n)

### 2.重复区间

可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有`15`位也有`18`位的。

这里重复区间就可以出场了，语法：`{M,N}`，`M`是下界而`N`是上界。

举个例子：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTcucG5n)

`\d{3,4}` 既可以匹配`3`个数字也可以匹配`4`个数字，不过当有`4`个数字的时候，优先匹配的是`4`个数字，这是因为正则表达式默认是**贪婪模式**，即在符合条件的情况下，==尽可能多的匹配更多字符==，而要使用<b name="tanlan">**非贪婪模式**</b>，我们要在**表达式后面加上 `?`号**。

![img](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTgucG5n)

### 3.开闭区间

有时候我们可能遇到字符组的重复次数没有边界，例如：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMTkucG5n)

闭区间不写即可表示匹配一个或无数个。

**速写**

还可以使用两个速写字符指定常见的重复情况，可以使用 `+` 匹配`1`个到无数个，使用 `*`代表`0`个到无数个。

即：`+`等价于`{1,}`，`*`等价于`{0,}`。

`+`号示例：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMjAucG5n)

`*`号示例：

![image](..\img\cmVnZXhfY2hhcHRlcjEvaW1hZ2VzL2NoYXB0ZXIxL2ltYWdlMjEucG5n)

---

## 四、进阶

### 1.分组

在正则表达式中还提供了一种将表达式**分组**的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。

要实现分组很简单，使用`()`即可。

例如：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlMS5wbmc=)

这段正则表达式将文本**分成了两组**，第一组为：`0731`，第二组为`8825951`。

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlMi5wbmc=)

分组有一个非常重要的功能——`捕获数据`。所以`()`被称为捕获分组，用来捕获数据，当我们想要从匹配好的数据中提取关键数据的时候可以使用分组。

`(\d{4})` 和 `(\d{7})`就分别捕获了两段数据：

1. 0731
2. 8825951

#### 1.1 或者条件

使用分组的同时还可以使用 **或者**（`or`）条件。

例如要提取所有图片文件的后缀名，可以在各个后缀名之间加上一个 `|`符号：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL29yLnBuZw==)

#### 1.2 非捕获分组

有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。

这个时候就可以使用非捕获组`(?:表达式)`，从而**不捕获数据**，还能使用分组的功能，例如使用回溯功能。

例如想要匹配**两个字母组成的单词**或者**四个字母组成的单词**就可以使用**非捕获分组**：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-mdnuaNleiOty5wbmc=)

#### 1.3 分组使用技巧

日期可以有很多格式，例如：

```python
20200102
2020-01-02
2020-1-2
2020.01.02
2020 01 02
2020 1 2
2020/01/02
```

Copy

现在我们想要使用正则表达式将其中的`年月日`全都提取出来。

可以发现他们唯一的区别就在于分隔符和月份与日期，这个时候可以使用`[]`来匹配多种情况。

例如：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlNS5wbmc=)

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlNC5wbmc=)

通过`(\d{4})[-./\s]?(\d{1,2})[-./\s]?(\d{1,2})` 就可以从文本中将年月日分别提取出来了。

虽然这段正则表达式看起来内容挺多，但是还是很容易理解的，`[-./\s]`表示匹配三个可能出现的分隔符`-./`和`空白`，`?`表示匹配它们`0`次或者`1`次，其他年月日的数据使用`\d{N}`与**分组**结合就可以提取到目标数据。

#### 1.4 分组的回溯引用

正则表达式还提供了一种引用之前匹配分组的机制，有些时候，我们或许会寻找到一个子匹配，该匹配接下来会再次出现。

例如，要匹配一段 HTML 代码，比如：`0123<font>提示</font>abcd`，可能会编写出这样一段正则表达式：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlNi5wbmc=)

这确实可以匹配，不过可能还有另一种情况，如果数据改成这样：`<font>提示</bar>`

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlNy5wbmc=)

在这里`font` 和 `bar` 明显不是一对正确的标签，但是我们编写的正则表达式还是将它们给匹配了，所以这个结果是错误的。

我们想让后面分组的正则也匹配`font`，但是现在所有形式的都会匹配。

那如果想让后面分组的正则和第一个分组的正则匹配同样的数据该如何做呢？

可以使用**分组的回溯引用**，使用`\N`可以引用编号为`N`的分组，因此上述例子的代码我们可以改为：

![image](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL2ltYWdlOC5wbmc=)

通过这个例子，可以发现 `\1` 表示的就是第一个分组，在这里第一个分组匹配的是 `font` 所以`\1` 就代表`font`。

### 2.先行断言

#### 2.1 正向先行断言

很多人也称先行断言和后行断言为**环视**，也有人叫**预搜索**，其实叫什么无所谓，重要的是知道如何使用它们！

先行断言和后行断言总共有四种：

1. 正向先行断言
2. 反向先行断言
3. 正向后行断言
4. 反向后行断言

**正向先行断言：**`(?=表达式)`，指在某个位置向右看，表示所在位置右侧必须能匹配`表达式`

例如：

```
我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你
```

如果要取出**喜欢**两个字，要求这个**喜欢**后面有你，这个时候就要这么写：`喜欢(?=你)`，这就是**正向先行断言**。

![start](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-WFiOihjOaWreiogC5wbmc=)

**提取包含大小写字母的字符串**

先行断言可以用来判断字符串是否符合特定的规则，例如提取包含至少一个大小写字母的字符串：

![start](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-WFiOihjOaWreiogDIucG5n)

`(?=.*?[a-z])(?=.*?[A-Z]).+` 这段正则表达式规定了匹配的字符串中必须包含**至少一个大写和小写的字母**。都表示在开头位置向右看。

判断第一个字符大写，第二个小写

![image-20220123173656864](..\img\image-20220123173656864.png)

#### 2.2 反向先行断言

**反向先行断言**`(?!表达式)`的作用是保证右边不能出现某字符。

例如： `我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你`

如果要取出**喜欢**两个字，要求这个**喜欢**后面没有你，这个时候就要这么写：`喜欢(?!你)`，这就是**反向先行断言**。

![start](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-WPjeWQkeWFiOihjC5wbmc=)

### 3.后行断言

#### 3.1 正向后行断言

本小节只需要你记住一句话：先行断言和后行断言只有一个区别，即**先行断言从左往右看，后行断言从右往左看。**

**正向后行断言：**`(?<=表达式)`，指在某个位置向左看，表示所在位置左侧必须能匹配`表达式`

例如：如果要取出喜欢两个字，要求喜欢的**前面有我**，**后面有你**，这个时候就要这么写：`(?<=我)喜欢(?=你)`。

![img](..\img\cmVnZXhfY2hhcHRlcjIvaW1hZ2VzL2NoYXB0ZXIyL-ato-WQkeWQjuihjOaWreiogC5wbmc=)

#### 3.2 反向后行断言

**反向后行断言：**`(?<!表达式)`，指在某个位置向左看，表示所在位置左侧不能匹配`表达式`

例如：如果要取出喜欢两个字，要求喜欢的**前面没有我**，**后面没有你**，这个时候就要这么写：`(?<!我)喜欢(?!你)`。

#### 3.3 练习

<img src="..\img\image-20220123163405658.png" alt="image-20220123163405658" style="zoom:67%;" />

### 4.编译标志

**Pattern.MULTILINE**

正则表达式中出现了^或者$，默认只会匹配第一行。设置了 Pattern.MULTILINE 模式，会匹配所有行。

```java
Pattern p1 = Pattern.compile("^.*b.*$");
//输出false,因为正则表达式中出现了^或$，默认只会匹配第一行，第二行的b匹配不到。
System.out.println(p1.matcher("a\nb").find());
Pattern p2 = Pattern.compile("^.*b.*$",Pattern.MULTILINE);
//输出true,指定了Pattern.MULTILINE模式，就可以匹配多行了。
System.out.println(p2.matcher("a\nb").find());
```

**Pattern.DOTALL**

默认情况下, 正则表达式中点(.)不会匹配换行符，设置了 Pattern.DOTALL 模式，才会匹配所有字符包括换行符。

```java
Pattern p1 = Pattern.compile("a.*b");
//输出false，默认点(.)没有匹配换行符
System.out.println(p1.matcher("a\nb").find());
Pattern p2 = Pattern.compile("a.*b", Pattern.DOTALL);
//输出true,指定Pattern.DOTALL模式，可以匹配换行符。
System.out.println(p2.matcher("a\nb").find());
```

**同时指定Pattern.MULTILINE和Pattern.DOTALL模式**

实际情况中要是比较复杂的情况，可能 Pattern.MULTILINE 模式和 Pattern.DOTALL 模式需要同时指定来匹配多行。

```java
Pattern p1 = Pattern.compile("^a.*b$");
//输出false
System.out.println(p1.matcher("cc\na\nb").find());
Pattern p2 = Pattern.compile("^a.*b$", Pattern.DOTALL);
//输出false,因为有^或&没有匹配到下一行
System.out.println(p2.matcher("cc\na\nb").find());
Pattern p3 = Pattern.compile("^a.*b$", Pattern.MULTILINE);
//输出false，匹配到下一行，但.没有匹配换行符
System.out.println(p3.matcher("cc\na\nb").find());
//指定多个模式，中间用|隔开
Pattern p4 = Pattern.compile("^a.*b$", Pattern.DOTALL|Pattern.MULTILINE);
//输出true
System.out.println(p4.matcher("cc\na\nb").find());
```

**Pattern.ASCII**

使得 \w, \W, \b, \B, \s, \S 只匹配 ASCII 字符，不匹配完整的 Unicode 字符，仅对 Unicode 模式有效

**Pattern.IGNORECASE**

字符类和文本字符串在匹配的时候不区分大小写，如 [A-Z] 将同样匹配小写

**Pattern.LOCALE**

使得 \w, \W, \b \B 依赖当前的语言环境，而不是 Unicode 数据库

**Pattern.VERBOSE**

空格会被忽略，`#` 会被当作注释

（除了在字符组中和使用反斜杠转义的）

```java
Pattern p1 = Pattern.compile(
    """
    	[#]  # 开始
		(
        	0[0-7]+  # 八进制格式
            |[0-9]+  # 十进制格式
            |x[0-9a-fA-F]+  # 十六进制格式
        );
    """
, Pattern.VERBOSE);

-------------- 不使用 VERBOSE -----------------
Pattern p1 = Pattern.compile("#(0[0-7]+|[0-9]+|x[0-9a-fA-F]+);");
```

