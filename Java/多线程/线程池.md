# 线程池

## 1.Java线程池创建

无论是创建何种类型线程池（FixedThreadPool、CachedThreadPool…），均会调用`ThreadPoolExecutor`构造函数，下面详细解读各个参数的作用：

```java
public ThreadPoolExecutor(int corePoolSize, // 核心线程池大小，线程池中常驻线程的最大数量
                          int maximumPoolSize, // 线程池中运行最大线程数（包括核心线程和非核心线程）
                          long keepAliveTime, // 线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间
                          TimeUnit unit, // 存活时间单位，与keepAliveTime搭配使用
                          // 存放任务的阻塞队列
                          BlockingQueue<Runnable> workQueue, 
                          // 线程工厂：创建线程的，一般不用动
                          ThreadFactory threadFactory,  
                          // 拒绝策略
                          RejectedExecutionHandler handle) {
```

- `corePoolSize`：核心线程最大数量，通俗点来讲就是，线程池中常驻线程的最大数量
- `maximumPoolSize`：线程池中运行最大线程数（包括核心线程和非核心线程）
- `keepAliveTime`：线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间
- `unit`：存活时间单位，与 keepAliveTime 搭配使用
- `workQueue`：存放任务的阻塞队列
- `handler`：线程池饱和策略

## 2.线程池执行流程

当提交一个新任务，线程池的处理流程如下：

- 判断线程池中核心线程数是否已达阈值 corePoolSize，若否，则创建一个新核心线程执行任务
- 若核心线程数已达阈值 corePoolSize，判断阻塞队列 workQueue 是否已满，若未满，则将新任务添加进阻塞队列
- 若阻塞队列满，再判断线程池中线程数是否达到阈值 maximumPoolSize，若否，则新建一个非核心线程执行任务。若达到阈值，则执行线程池饱和策略

从流程角度，更形象的图：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-5809ba30bc2296ef2a7d1fda1f195ce5-4f1b5a.png" alt="图片" style="zoom:80%;" />

从结构角度，更形象的图：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-16566418687396-94b8286ab2a1f7df715dfa606ca7bd34-c1b0aa.png" alt="图片" style="zoom:67%;" />

## 3.几种典型的工作队列

### 3.1 BlockingQueue接口

继承了 Queue 接口，多线程并发处理，线程池用的较多。

|     方式     | 抛出异常  | 有返回值，不抛出异常 | 阻塞等待 | 超时等待 |
| :----------: | :-------: | :------------------: | :------: | :------: |
|     添加     |   add()   |       offer()        |  put()   | offer()  |
|     移除     | remove()  |        poll()        |  take()  |  poll()  |
| 检测队首元素 | element() |        peek()        |    -     |    -     |

### 3.2 ArrayBlockingQueue

使用数组实现的有界阻塞队列，特性先进先出。

```java
public class Test {
    public static void main(String[] args) throws InterruptedException {
        test4();
    }
    /**
     * 1. 无返回值，抛出异常的方式
     */
    public static void test1(){
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.add("a"));// true
        System.out.println(blockingQueue.add("b"));// true
        System.out.println(blockingQueue.add("c"));// true
        // System.out.println(blockingQueue.add("d"));
        // IllegalStateException: Queue full 抛出异常---队列已满！
        System.out.println("===========================");
        System.out.println(blockingQueue.element());// a
        // 查看队首元素是谁，若无元素则抛出异常
        System.out.println(blockingQueue.remove());// a
        System.out.println(blockingQueue.remove());// b
        System.out.println(blockingQueue.remove());// c
        // System.out.println(blockingQueue.remove()); java.util.NoSuchElementException 抛出异常---队列已为空！
    }
    /**
     * 2. 有返回值，不抛出异常的方式
     */
    public static void test2(){
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        System.out.println(blockingQueue.peek());
        // System.out.println(blockingQueue.offer("d")); 
        // false 不抛出异常！
        System.out.println("===========================");
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll()); 
        // null 不抛出异常！
    }
    /**
     * 3. 等待，阻塞（一直阻塞）
     */
    public static void test3() throws InterruptedException {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        // 一直阻塞
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        // blockingQueue.put("d"); // 队列没有位置了，一直阻塞等待
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take()); 
        // 没有这个元素，一直阻塞等待
    }
    /**
     * 4. 等待，阻塞（等待超时）
     */
    public static void test4() throws InterruptedException {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
        blockingQueue.offer("a");
        blockingQueue.offer("b");
        blockingQueue.offer("c");
        blockingQueue.offer("d",2,TimeUnit.SECONDS); // 等待超过2秒就退出

        System.out.println("===============");
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        blockingQueue.poll(2,TimeUnit.SECONDS); // 等待超过2秒就退出
    }
}
```

### 3.3  LinkedBlockingQueue

使用链表实现的阻塞队列，特性先进先出，可以设置其容量，默认为`Interger.MAX_VALUE`，特性先进先出

### 3.4 PriorityBlockingQueue

使用平衡二叉树堆，实现的具有优先级的无界阻塞队列

### 3.5 DelayQueue

无界阻塞延迟队列，队列中每个元素均有过期时间，当从队列获取元素时，只有过期元素才会出队列，队列头元素是最块要过期的元素

### 3.6 SynchronousQueue

一个不存储元素的阻塞队列，每个插入操作，必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态

```java
/**
 * 同步队列:
 * 和其他的 BlockingQueue 不一样， SynchronousQueue 不存储元素
 * put 了一个元素，必须从里面先 take 取出来，否则不能在 put 进去值！
 */
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>(); // 同步队列
        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+" put 1");
                // put一个元素后阻塞
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName()+" put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName()+" put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T1").start();
        new Thread(()->{
            try {
                // 睡眠3s取出一个元素
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T2").start();
    }
}
```

执行结果如图所示：

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/image-20220222125303873-ddfd1664aaac18f9fd6366a268a56fe4-d2fdc4.png" alt="image-20220222125303873" style="zoom: 67%;" />

## 4.几种典型的饱和策略

- `AbortPolicy`：直接抛出一个异常，默认策略
- `DiscardPolicy`：直接丢弃任务
- `DiscardOldestPolicy`：会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去
- `CallerRunsPolicy`：主线程中执行任务

## 5.几种典型的线程池

### 5.1 SingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 
                                1,
                                0L, 
                                TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

创建单个线程。它适用于需要保证顺序地执行各个任务，并且在任意时间点，不会有多个线程是活动的应用场景。

`SingleThreadExecutor`的`corePoolSize`和`maximumPoolSize`被设置为 1，使用无界队列`LinkedBlockingQueue`作为线程池的工作队列。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-165664209621611-8587a8e99737f755e8e0baf16c72dcec-3b5db7.png" alt="图片" style="zoom:67%;" />

- 当线程池中没有线程时，会创建一个新线程来执行任务
- 当前线程池中有一个线程后，将新任务加入`LinkedBlockingQueue`
- 线程执行完第一个任务后，会在一个无限循环中反复从`LinkedBlockingQueue`获取任务来执行

使用场景：适用于串行执行任务场景

代码示例：

```java
public class Demo01 {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newSingleThreadExecutor();
        try {
            for (int i = 1; i < 100; i++) {
                // 使用了线程池之后，使用线程池来创建线程
                threadPool.execute(()->{
                    System.out.println(
                        Thread.currentThread().getName()+" ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
```

### 5.2 FixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, 
                                  nThreads,
                                  0L, 
                                  TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

`corePoolSize`等于`maximumPoolSize`，所以线程池中只有核心线程，使用无界阻塞队列`LinkedBlockingQueue`作为工作队列。

`FixedThreadPool`是一种线程数量固定的线程池，当线程处于空闲状态时，他们并不会被回收，除非线程池被关闭。当所有的线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-165664209621712-dd79c2ad253b7970448d7ff19f182bf3-ff096a.png" alt="图片" style="zoom:67%;" />

- 如果当前运行的线程数少于`corePoolSize`，则创建新线程来执行任务
- 在线程数目达到`corePoolSize`后，将新任务放到`LinkedBlockingQueue`阻塞队列中
- 线程执行完任务后，会在循环中反复从`LinkedBlockingQueue`获取任务来执行

使用场景：适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。

#### 面试题：使用无界队列的线程池会导致内存飙升吗？

答案 ：会的，`newFixedThreadPool`使用了无界的阻塞队列`LinkedBlockingQueue`，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升， 最终导致 OOM。

### 5.3 CachedThreadPool 

```java
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, 
                                      Integer.MAX_VALUE,
                                      60L, 
                                      TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

核心线程数为 0，总线程数量阈值为`Integer.MAX_VALUE`，即可以创建无限的非核心线程

**执行流程**

- 先执行`SynchronousQueue`的`offer`方法提交任务，并查询线程池中是否有空闲线程来执行`SynchronousQueue`的`poll`方法来移除任务。如果有，则配对成功，将任务交给这个空闲线程
- 否则配对失败，创建新的线程去处理任务
- 当线程池中的线程空闲时，会执行`SynchronousQueue`的`poll`方法等待执行`SynchronousQueue`中新提交的任务。若等待超过 60s，空闲线程就会终止

**流程形象图**

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-165664209621813-86060436969e3420f6109880425038d2-9e4f1a.jpeg" alt="图片" style="zoom:67%;" />

**结构形象图**

<img src="https://raw.githubusercontent.com/Famezyy/picture/master/notePictureBed/640-165664209621814-19a4529c26661d45314fb229295c2dfb-1b3279.png" alt="图片" style="zoom:67%;" />

使用场景：执行大量短生命周期任务。因为`maximumPoolSize`是无界的，所以提交任务的速度 > 线程池中线程处理任务的速度就要不断创建新线程；每次提交任务，都会立即有线程去处理，因此`CachedThreadPool`适用于处理大量、耗时少的任务。

### 5.4 ScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, 
          Integer.MAX_VALUE, 
          0, 
          NANOSECONDS,
          new DelayedWorkQueue());
}
```

线程总数阈值为`Integer.MAX_VALUE`，工作队列使用`DelayedWorkQueue`，非核心线程存活时间为 0，所以线程池仅仅包含固定数目的核心线程。

两种方式提交任务：

- `scheduleAtFixedRate`：按照固定速率周期执行
- `scheduleWithFixedDelay`：上个任务延迟固定时间后执行

使用场景：周期性执行任务，并且需要限制线程数量的场景

### 5.5 自定义线程池

```java
public class Demo01 {
    public static void main(String[] args) {
        // 自定义线程池！工作 ThreadPoolExecutor
        ExecutorService threadPool = new ThreadPoolExecutor(
            2, // int corePoolSize, 核心线程池大小(候客区窗口2个)
            5, // int maximumPoolSize, 最大线程池大小(总共5个窗口) 
            3, // long keepAliveTime, 超时 3 秒没有人调用就会释放关闭空闲线程，对核心线程无效
            TimeUnit.SECONDS,// TimeUnit unit, 超时单位：秒 
            new LinkedBlockingDeque<>(3),// 阻塞队列（候客区最多3人）
            Executors.defaultThreadFactory(),// 默认线程工厂
            // 队列满了，抛弃队列中最老的，代替他的位置进入队列中
            new ThreadPoolExecutor.DiscardOldestPolicy());  
        try {
            // 最大承载：Deque + max
            // 超过 RejectedExecutionException
            for (int i = 1; i <= 9; i++) {
                // 使用了线程池之后，使用线程池来创建线程
                threadPool.execute(()->{
                    System.out.println(
                        Thread.currentThread().getName()+" ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
```

## 6.IO密集型、CPU密集型

**最大线程到底该如何定义？**

1. CPU 密集型，可用处理器的数量是多少就设置多少，可以保持 CPU 的效率最高！ 
2. IO 密集型，判断你程序中十分耗 IO 的线程， 比如程序 15 个大型任务 IO 十分占用资源，密集型参数（最大线程数）就设置为大于 15 即可，一般选择两倍

```java
public class Demo01 {
    public static void main(String[] args) {
        // 获取CPU的可用处理器的数量
        System.out.println(Runtime.getRuntime().availableProcessors()); // 8 核
        
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                Runtime.getRuntime().availableProcessors(), // int maximumPoolSize, 最大核心线程池大小
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy());  
    }
}
```
